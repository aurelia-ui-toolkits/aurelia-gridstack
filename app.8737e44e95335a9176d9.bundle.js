/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessKeyed: () => (/* binding */ AccessKeyed),
/* harmony export */   AccessMember: () => (/* binding */ AccessMember),
/* harmony export */   AccessScope: () => (/* binding */ AccessScope),
/* harmony export */   AccessThis: () => (/* binding */ AccessThis),
/* harmony export */   Assign: () => (/* binding */ Assign),
/* harmony export */   Binary: () => (/* binding */ Binary),
/* harmony export */   Binding: () => (/* binding */ Binding),
/* harmony export */   BindingBehavior: () => (/* binding */ BindingBehavior),
/* harmony export */   BindingBehaviorResource: () => (/* binding */ BindingBehaviorResource),
/* harmony export */   BindingEngine: () => (/* binding */ BindingEngine),
/* harmony export */   BindingExpression: () => (/* binding */ BindingExpression),
/* harmony export */   Call: () => (/* binding */ Call),
/* harmony export */   CallExpression: () => (/* binding */ CallExpression),
/* harmony export */   CallFunction: () => (/* binding */ CallFunction),
/* harmony export */   CallMember: () => (/* binding */ CallMember),
/* harmony export */   CallScope: () => (/* binding */ CallScope),
/* harmony export */   CheckedObserver: () => (/* binding */ CheckedObserver),
/* harmony export */   ClassObserver: () => (/* binding */ ClassObserver),
/* harmony export */   CollectionLengthObserver: () => (/* binding */ CollectionLengthObserver),
/* harmony export */   ComputedExpression: () => (/* binding */ ComputedExpression),
/* harmony export */   Conditional: () => (/* binding */ Conditional),
/* harmony export */   DataAttributeObserver: () => (/* binding */ DataAttributeObserver),
/* harmony export */   DirtyCheckProperty: () => (/* binding */ DirtyCheckProperty),
/* harmony export */   DirtyChecker: () => (/* binding */ DirtyChecker),
/* harmony export */   EventManager: () => (/* binding */ EventManager),
/* harmony export */   EventSubscriber: () => (/* binding */ EventSubscriber),
/* harmony export */   Expression: () => (/* binding */ Expression),
/* harmony export */   ExpressionCloner: () => (/* binding */ ExpressionCloner),
/* harmony export */   ExpressionObserver: () => (/* binding */ ExpressionObserver),
/* harmony export */   Listener: () => (/* binding */ Listener),
/* harmony export */   ListenerExpression: () => (/* binding */ ListenerExpression),
/* harmony export */   LiteralArray: () => (/* binding */ LiteralArray),
/* harmony export */   LiteralObject: () => (/* binding */ LiteralObject),
/* harmony export */   LiteralPrimitive: () => (/* binding */ LiteralPrimitive),
/* harmony export */   LiteralString: () => (/* binding */ LiteralString),
/* harmony export */   LiteralTemplate: () => (/* binding */ LiteralTemplate),
/* harmony export */   ModifyCollectionObserver: () => (/* binding */ ModifyCollectionObserver),
/* harmony export */   NameExpression: () => (/* binding */ NameExpression),
/* harmony export */   ObjectObservationAdapter: () => (/* binding */ ObjectObservationAdapter),
/* harmony export */   ObserverLocator: () => (/* binding */ ObserverLocator),
/* harmony export */   Parser: () => (/* binding */ Parser),
/* harmony export */   ParserImplementation: () => (/* binding */ ParserImplementation),
/* harmony export */   PrimitiveObserver: () => (/* binding */ PrimitiveObserver),
/* harmony export */   SVGAnalyzer: () => (/* binding */ SVGAnalyzer),
/* harmony export */   SelectValueObserver: () => (/* binding */ SelectValueObserver),
/* harmony export */   SetterObserver: () => (/* binding */ SetterObserver),
/* harmony export */   StyleObserver: () => (/* binding */ StyleObserver),
/* harmony export */   Unary: () => (/* binding */ Unary),
/* harmony export */   Unparser: () => (/* binding */ Unparser),
/* harmony export */   ValueAttributeObserver: () => (/* binding */ ValueAttributeObserver),
/* harmony export */   ValueConverter: () => (/* binding */ ValueConverter),
/* harmony export */   ValueConverterResource: () => (/* binding */ ValueConverterResource),
/* harmony export */   XLinkAttributeObserver: () => (/* binding */ XLinkAttributeObserver),
/* harmony export */   bindingBehavior: () => (/* binding */ bindingBehavior),
/* harmony export */   bindingMode: () => (/* binding */ bindingMode),
/* harmony export */   calcSplices: () => (/* binding */ calcSplices),
/* harmony export */   camelCase: () => (/* binding */ camelCase),
/* harmony export */   cloneExpression: () => (/* binding */ cloneExpression),
/* harmony export */   computedFrom: () => (/* binding */ computedFrom),
/* harmony export */   connectBindingToSignal: () => (/* binding */ connectBindingToSignal),
/* harmony export */   connectable: () => (/* binding */ connectable),
/* harmony export */   createComputedObserver: () => (/* binding */ createComputedObserver),
/* harmony export */   createOverrideContext: () => (/* binding */ createOverrideContext),
/* harmony export */   createScopeForTest: () => (/* binding */ createScopeForTest),
/* harmony export */   dataAttributeAccessor: () => (/* binding */ dataAttributeAccessor),
/* harmony export */   declarePropertyDependencies: () => (/* binding */ declarePropertyDependencies),
/* harmony export */   delegationStrategy: () => (/* binding */ delegationStrategy),
/* harmony export */   disableConnectQueue: () => (/* binding */ disableConnectQueue),
/* harmony export */   elements: () => (/* binding */ elements),
/* harmony export */   enableConnectQueue: () => (/* binding */ enableConnectQueue),
/* harmony export */   enqueueBindingConnect: () => (/* binding */ enqueueBindingConnect),
/* harmony export */   getArrayObserver: () => (/* binding */ getArrayObserver),
/* harmony export */   getChangeRecords: () => (/* binding */ getChangeRecords),
/* harmony export */   getConnectQueueSize: () => (/* binding */ getConnectQueueSize),
/* harmony export */   getContextFor: () => (/* binding */ getContextFor),
/* harmony export */   getMapObserver: () => (/* binding */ getMapObserver),
/* harmony export */   getSetObserver: () => (/* binding */ getSetObserver),
/* harmony export */   hasDeclaredDependencies: () => (/* binding */ hasDeclaredDependencies),
/* harmony export */   mergeSplice: () => (/* binding */ mergeSplice),
/* harmony export */   observable: () => (/* binding */ observable),
/* harmony export */   presentationAttributes: () => (/* binding */ presentationAttributes),
/* harmony export */   presentationElements: () => (/* binding */ presentationElements),
/* harmony export */   projectArraySplices: () => (/* binding */ projectArraySplices),
/* harmony export */   propertyAccessor: () => (/* binding */ propertyAccessor),
/* harmony export */   setConnectQueueThreshold: () => (/* binding */ setConnectQueueThreshold),
/* harmony export */   signalBindings: () => (/* binding */ signalBindings),
/* harmony export */   sourceContext: () => (/* binding */ sourceContext),
/* harmony export */   subscriberCollection: () => (/* binding */ subscriberCollection),
/* harmony export */   targetContext: () => (/* binding */ targetContext),
/* harmony export */   valueConverter: () => (/* binding */ valueConverter)
/* harmony export */ });
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
/* harmony import */ var aurelia_task_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-task-queue */ "../../node_modules/aurelia-task-queue/dist/es2015/aurelia-task-queue.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
var _dec, _dec2, _class, _dec3, _class2, _dec4, _class3, _dec5, _class5, _dec6, _class7, _dec7, _class8, _dec8, _class9, _dec9, _class10, _class11, _temp, _dec10, _class12, _class13, _temp2;






const targetContext = 'Binding:target';
const sourceContext = 'Binding:source';

const map = Object.create(null);

function camelCase(name) {
  if (name in map) {
    return map[name];
  }
  const result = name.charAt(0).toLowerCase() + name.slice(1).replace(/[_.-](\w|$)/g, (_, x) => x.toUpperCase());
  map[name] = result;
  return result;
}

function createOverrideContext(bindingContext, parentOverrideContext) {
  return {
    bindingContext: bindingContext,
    parentOverrideContext: parentOverrideContext || null
  };
}

function getContextFor(name, scope, ancestor) {
  let oc = scope.overrideContext;

  if (ancestor) {
    while (ancestor && oc) {
      ancestor--;
      oc = oc.parentOverrideContext;
    }
    if (ancestor || !oc) {
      return undefined;
    }
    return name in oc ? oc : oc.bindingContext;
  }

  while (oc && !(name in oc) && !(oc.bindingContext && name in oc.bindingContext)) {
    oc = oc.parentOverrideContext;
  }
  if (oc) {
    return name in oc ? oc : oc.bindingContext;
  }

  return scope.bindingContext || scope.overrideContext;
}

function createScopeForTest(bindingContext, parentBindingContext) {
  if (parentBindingContext) {
    return {
      bindingContext,
      overrideContext: createOverrideContext(bindingContext, createOverrideContext(parentBindingContext))
    };
  }
  return {
    bindingContext,
    overrideContext: createOverrideContext(bindingContext)
  };
}

const slotNames = [];
const versionSlotNames = [];
let lastSlot = -1;
function ensureEnoughSlotNames(currentSlot) {
  if (currentSlot === lastSlot) {
    lastSlot += 5;
    const ii = slotNames.length = versionSlotNames.length = lastSlot + 1;
    for (let i = currentSlot + 1; i < ii; ++i) {
      slotNames[i] = `_observer${i}`;
      versionSlotNames[i] = `_observerVersion${i}`;
    }
  }
}
ensureEnoughSlotNames(-1);

function addObserver(observer) {
  let observerSlots = this._observerSlots === undefined ? 0 : this._observerSlots;
  let i = observerSlots;
  while (i-- && this[slotNames[i]] !== observer) {}

  if (i === -1) {
    i = 0;
    while (this[slotNames[i]]) {
      i++;
    }
    this[slotNames[i]] = observer;
    observer.subscribe(sourceContext, this);

    if (i === observerSlots) {
      this._observerSlots = i + 1;
    }
  }

  if (this._version === undefined) {
    this._version = 0;
  }
  this[versionSlotNames[i]] = this._version;
  ensureEnoughSlotNames(i);
}

function observeProperty(obj, propertyName) {
  let observer = this.observerLocator.getObserver(obj, propertyName);
  addObserver.call(this, observer);
}

function observeArray(array) {
  let observer = this.observerLocator.getArrayObserver(array);
  addObserver.call(this, observer);
}

function unobserve(all) {
  let i = this._observerSlots;
  while (i--) {
    if (all || this[versionSlotNames[i]] !== this._version) {
      let observer = this[slotNames[i]];
      this[slotNames[i]] = null;
      if (observer) {
        observer.unsubscribe(sourceContext, this);
      }
    }
  }
}

function connectable() {
  return function (target) {
    target.prototype.observeProperty = observeProperty;
    target.prototype.observeArray = observeArray;
    target.prototype.unobserve = unobserve;
    target.prototype.addObserver = addObserver;
  };
}

const queue = [];
const queued = {};
let nextId = 0;
let minimumImmediate = 100;
const frameBudget = 15;

let isFlushRequested = false;
let immediate = 0;

function flush(animationFrameStart) {
  const length = queue.length;
  let i = 0;
  while (i < length) {
    const binding = queue[i];
    queued[binding.__connectQueueId] = false;
    binding.connect(true);
    i++;

    if (i % 100 === 0 && aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.performance.now() - animationFrameStart > frameBudget) {
      break;
    }
  }
  queue.splice(0, i);

  if (queue.length) {
    aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.requestAnimationFrame(flush);
  } else {
    isFlushRequested = false;
    immediate = 0;
  }
}

function enqueueBindingConnect(binding) {
  if (immediate < minimumImmediate) {
    immediate++;
    binding.connect(false);
  } else {
    let id = binding.__connectQueueId;
    if (id === undefined) {
      id = nextId;
      nextId++;
      binding.__connectQueueId = id;
    }

    if (!queued[id]) {
      queue.push(binding);
      queued[id] = true;
    }
  }
  if (!isFlushRequested) {
    isFlushRequested = true;
    aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.requestAnimationFrame(flush);
  }
}

function setConnectQueueThreshold(value) {
  minimumImmediate = value;
}

function enableConnectQueue() {
  setConnectQueueThreshold(100);
}

function disableConnectQueue() {
  setConnectQueueThreshold(Number.MAX_SAFE_INTEGER);
}

function getConnectQueueSize() {
  return queue.length;
}

function addSubscriber(context, callable) {
  if (this.hasSubscriber(context, callable)) {
    return false;
  }
  if (!this._context0) {
    this._context0 = context;
    this._callable0 = callable;
    return true;
  }
  if (!this._context1) {
    this._context1 = context;
    this._callable1 = callable;
    return true;
  }
  if (!this._context2) {
    this._context2 = context;
    this._callable2 = callable;
    return true;
  }
  if (!this._contextsRest) {
    this._contextsRest = [context];
    this._callablesRest = [callable];
    return true;
  }
  this._contextsRest.push(context);
  this._callablesRest.push(callable);
  return true;
}

function removeSubscriber(context, callable) {
  if (this._context0 === context && this._callable0 === callable) {
    this._context0 = null;
    this._callable0 = null;
    return true;
  }
  if (this._context1 === context && this._callable1 === callable) {
    this._context1 = null;
    this._callable1 = null;
    return true;
  }
  if (this._context2 === context && this._callable2 === callable) {
    this._context2 = null;
    this._callable2 = null;
    return true;
  }
  const callables = this._callablesRest;
  if (callables === undefined || callables.length === 0) {
    return false;
  }
  const contexts = this._contextsRest;
  let i = 0;
  while (!(callables[i] === callable && contexts[i] === context) && callables.length > i) {
    i++;
  }
  if (i >= callables.length) {
    return false;
  }
  contexts.splice(i, 1);
  callables.splice(i, 1);
  return true;
}

let arrayPool1 = [];
let arrayPool2 = [];
let poolUtilization = [];

function callSubscribers(newValue, oldValue) {
  let context0 = this._context0;
  let callable0 = this._callable0;
  let context1 = this._context1;
  let callable1 = this._callable1;
  let context2 = this._context2;
  let callable2 = this._callable2;
  let length = this._contextsRest ? this._contextsRest.length : 0;
  let contextsRest;
  let callablesRest;
  let poolIndex;
  let i;
  if (length) {
    poolIndex = poolUtilization.length;
    while (poolIndex-- && poolUtilization[poolIndex]) {}
    if (poolIndex < 0) {
      poolIndex = poolUtilization.length;
      contextsRest = [];
      callablesRest = [];
      poolUtilization.push(true);
      arrayPool1.push(contextsRest);
      arrayPool2.push(callablesRest);
    } else {
      poolUtilization[poolIndex] = true;
      contextsRest = arrayPool1[poolIndex];
      callablesRest = arrayPool2[poolIndex];
    }

    i = length;
    while (i--) {
      contextsRest[i] = this._contextsRest[i];
      callablesRest[i] = this._callablesRest[i];
    }
  }

  if (context0) {
    if (callable0) {
      callable0.call(context0, newValue, oldValue);
    } else {
      context0(newValue, oldValue);
    }
  }
  if (context1) {
    if (callable1) {
      callable1.call(context1, newValue, oldValue);
    } else {
      context1(newValue, oldValue);
    }
  }
  if (context2) {
    if (callable2) {
      callable2.call(context2, newValue, oldValue);
    } else {
      context2(newValue, oldValue);
    }
  }
  if (length) {
    for (i = 0; i < length; i++) {
      let callable = callablesRest[i];
      let context = contextsRest[i];
      if (callable) {
        callable.call(context, newValue, oldValue);
      } else {
        context(newValue, oldValue);
      }
      contextsRest[i] = null;
      callablesRest[i] = null;
    }
    poolUtilization[poolIndex] = false;
  }
}

function hasSubscribers() {
  return !!(this._context0 || this._context1 || this._context2 || this._contextsRest && this._contextsRest.length);
}

function hasSubscriber(context, callable) {
  let has = this._context0 === context && this._callable0 === callable || this._context1 === context && this._callable1 === callable || this._context2 === context && this._callable2 === callable;
  if (has) {
    return true;
  }
  let index;
  let contexts = this._contextsRest;
  if (!contexts || (index = contexts.length) === 0) {
    return false;
  }
  let callables = this._callablesRest;
  while (index--) {
    if (contexts[index] === context && callables[index] === callable) {
      return true;
    }
  }
  return false;
}

function subscriberCollection() {
  return function (target) {
    target.prototype.addSubscriber = addSubscriber;
    target.prototype.removeSubscriber = removeSubscriber;
    target.prototype.callSubscribers = callSubscribers;
    target.prototype.hasSubscribers = hasSubscribers;
    target.prototype.hasSubscriber = hasSubscriber;
  };
}

let ExpressionObserver = (_dec = connectable(), _dec2 = subscriberCollection(), _dec(_class = _dec2(_class = class ExpressionObserver {
  constructor(scope, expression, observerLocator, lookupFunctions) {
    this.scope = scope;
    this.expression = expression;
    this.observerLocator = observerLocator;
    this.lookupFunctions = lookupFunctions;
  }

  getValue() {
    return this.expression.evaluate(this.scope, this.lookupFunctions);
  }

  setValue(newValue) {
    this.expression.assign(this.scope, newValue);
  }

  subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.oldValue = this.expression.evaluate(this.scope, this.lookupFunctions);
      this.expression.connect(this, this.scope);
    }
    this.addSubscriber(context, callable);
    if (arguments.length === 1 && context instanceof Function) {
      return {
        dispose: () => {
          this.unsubscribe(context, callable);
        }
      };
    }
  }

  unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.unobserve(true);
      this.oldValue = undefined;
    }
  }

  call() {
    let newValue = this.expression.evaluate(this.scope, this.lookupFunctions);
    let oldValue = this.oldValue;
    if (newValue !== oldValue) {
      this.oldValue = newValue;
      this.callSubscribers(newValue, oldValue);
    }
    this._version++;
    this.expression.connect(this, this.scope);
    this.unobserve(false);
  }
}) || _class) || _class);

function isIndex(s) {
  return +s === s >>> 0;
}

function toNumber(s) {
  return +s;
}

function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;

function ArraySplice() {}

ArraySplice.prototype = {
  calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
    let rowCount = oldEnd - oldStart + 1;
    let columnCount = currentEnd - currentStart + 1;
    let distances = new Array(rowCount);
    let north;
    let west;

    for (let i = 0; i < rowCount; ++i) {
      distances[i] = new Array(columnCount);
      distances[i][0] = i;
    }

    for (let j = 0; j < columnCount; ++j) {
      distances[0][j] = j;
    }

    for (let i = 1; i < rowCount; ++i) {
      for (let j = 1; j < columnCount; ++j) {
        if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) {
          distances[i][j] = distances[i - 1][j - 1];
        } else {
          north = distances[i - 1][j] + 1;
          west = distances[i][j - 1] + 1;
          distances[i][j] = north < west ? north : west;
        }
      }
    }

    return distances;
  },

  spliceOperationsFromEditDistances: function (distances) {
    let i = distances.length - 1;
    let j = distances[0].length - 1;
    let current = distances[i][j];
    let edits = [];
    while (i > 0 || j > 0) {
      if (i === 0) {
        edits.push(EDIT_ADD);
        j--;
        continue;
      }
      if (j === 0) {
        edits.push(EDIT_DELETE);
        i--;
        continue;
      }
      let northWest = distances[i - 1][j - 1];
      let west = distances[i - 1][j];
      let north = distances[i][j - 1];

      let min;
      if (west < north) {
        min = west < northWest ? west : northWest;
      } else {
        min = north < northWest ? north : northWest;
      }

      if (min === northWest) {
        if (northWest === current) {
          edits.push(EDIT_LEAVE);
        } else {
          edits.push(EDIT_UPDATE);
          current = northWest;
        }
        i--;
        j--;
      } else if (min === west) {
        edits.push(EDIT_DELETE);
        i--;
        current = west;
      } else {
        edits.push(EDIT_ADD);
        j--;
        current = north;
      }
    }

    edits.reverse();
    return edits;
  },

  calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
    let prefixCount = 0;
    let suffixCount = 0;

    let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
    if (currentStart === 0 && oldStart === 0) {
      prefixCount = this.sharedPrefix(current, old, minLength);
    }

    if (currentEnd === current.length && oldEnd === old.length) {
      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
    }

    currentStart += prefixCount;
    oldStart += prefixCount;
    currentEnd -= suffixCount;
    oldEnd -= suffixCount;

    if (currentEnd - currentStart === 0 && oldEnd - oldStart === 0) {
      return [];
    }

    if (currentStart === currentEnd) {
      let splice = newSplice(currentStart, [], 0);
      while (oldStart < oldEnd) {
        splice.removed.push(old[oldStart++]);
      }

      return [splice];
    } else if (oldStart === oldEnd) {
      return [newSplice(currentStart, [], currentEnd - currentStart)];
    }

    let ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

    let splice = undefined;
    let splices = [];
    let index = currentStart;
    let oldIndex = oldStart;
    for (let i = 0; i < ops.length; ++i) {
      switch (ops[i]) {
        case EDIT_LEAVE:
          if (splice) {
            splices.push(splice);
            splice = undefined;
          }

          index++;
          oldIndex++;
          break;
        case EDIT_UPDATE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.addedCount++;
          index++;

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
        case EDIT_ADD:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.addedCount++;
          index++;
          break;
        case EDIT_DELETE:
          if (!splice) {
            splice = newSplice(index, [], 0);
          }

          splice.removed.push(old[oldIndex]);
          oldIndex++;
          break;
      }
    }

    if (splice) {
      splices.push(splice);
    }
    return splices;
  },

  sharedPrefix: function (current, old, searchLength) {
    for (let i = 0; i < searchLength; ++i) {
      if (!this.equals(current[i], old[i])) {
        return i;
      }
    }

    return searchLength;
  },

  sharedSuffix: function (current, old, searchLength) {
    let index1 = current.length;
    let index2 = old.length;
    let count = 0;
    while (count < searchLength && this.equals(current[--index1], old[--index2])) {
      count++;
    }

    return count;
  },

  calculateSplices: function (current, previous) {
    return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
  },

  equals: function (currentValue, previousValue) {
    return currentValue === previousValue;
  }
};

let arraySplice = new ArraySplice();

function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  return arraySplice.calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd);
}

function intersect(start1, end1, start2, end2) {
  if (end1 < start2 || end2 < start1) {
    return -1;
  }

  if (end1 === start2 || end2 === start1) {
    return 0;
  }

  if (start1 < start2) {
    if (end1 < end2) {
      return end1 - start2;
    }

    return end2 - start2;
  }

  if (end2 < end1) {
    return end2 - start1;
  }

  return end1 - start1;
}

function mergeSplice(splices, index, removed, addedCount) {
  let splice = newSplice(index, removed, addedCount);

  let inserted = false;
  let insertionOffset = 0;

  for (let i = 0; i < splices.length; i++) {
    let current = splices[i];
    current.index += insertionOffset;

    if (inserted) {
      continue;
    }

    let intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);

    if (intersectCount >= 0) {

      splices.splice(i, 1);
      i--;

      insertionOffset -= current.addedCount - current.removed.length;

      splice.addedCount += current.addedCount - intersectCount;
      let deleteCount = splice.removed.length + current.removed.length - intersectCount;

      if (!splice.addedCount && !deleteCount) {
        inserted = true;
      } else {
        let currentRemoved = current.removed;

        if (splice.index < current.index) {
          let prepend = splice.removed.slice(0, current.index - splice.index);
          Array.prototype.push.apply(prepend, currentRemoved);
          currentRemoved = prepend;
        }

        if (splice.index + splice.removed.length > current.index + current.addedCount) {
          let append = splice.removed.slice(current.index + current.addedCount - splice.index);
          Array.prototype.push.apply(currentRemoved, append);
        }

        splice.removed = currentRemoved;
        if (current.index < splice.index) {
          splice.index = current.index;
        }
      }
    } else if (splice.index < current.index) {

      inserted = true;

      splices.splice(i, 0, splice);
      i++;

      let offset = splice.addedCount - splice.removed.length;
      current.index += offset;
      insertionOffset += offset;
    }
  }

  if (!inserted) {
    splices.push(splice);
  }
}

function createInitialSplices(array, changeRecords) {
  let splices = [];

  for (let i = 0; i < changeRecords.length; i++) {
    let record = changeRecords[i];
    switch (record.type) {
      case 'splice':
        mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
        break;
      case 'add':
      case 'update':
      case 'delete':
        if (!isIndex(record.name)) {
          continue;
        }

        let index = toNumber(record.name);
        if (index < 0) {
          continue;
        }

        mergeSplice(splices, index, [record.oldValue], record.type === 'delete' ? 0 : 1);
        break;
      default:
        console.error('Unexpected record type: ' + JSON.stringify(record));
        break;
    }
  }

  return splices;
}

function projectArraySplices(array, changeRecords) {
  let splices = [];

  createInitialSplices(array, changeRecords).forEach(function (splice) {
    if (splice.addedCount === 1 && splice.removed.length === 1) {
      if (splice.removed[0] !== array[splice.index]) {
        splices.push(splice);
      }

      return;
    }

    splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
  });

  return splices;
}

function newRecord(type, object, key, oldValue) {
  return {
    type: type,
    object: object,
    key: key,
    oldValue: oldValue
  };
}

function getChangeRecords(map) {
  let entries = new Array(map.size);
  let keys = map.keys();
  let i = 0;
  let item;

  while (item = keys.next()) {
    if (item.done) {
      break;
    }

    entries[i] = newRecord('added', map, item.value);
    i++;
  }

  return entries;
}

let ModifyCollectionObserver = (_dec3 = subscriberCollection(), _dec3(_class2 = class ModifyCollectionObserver {
  constructor(taskQueue, collection) {
    this.taskQueue = taskQueue;
    this.queued = false;
    this.changeRecords = null;
    this.oldCollection = null;
    this.collection = collection;
    this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
  }

  subscribe(context, callable) {
    this.addSubscriber(context, callable);
  }

  unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  }

  addChangeRecord(changeRecord) {
    if (!this.hasSubscribers() && !this.lengthObserver) {
      return;
    }

    if (changeRecord.type === 'splice') {
      let index = changeRecord.index;
      let arrayLength = changeRecord.object.length;
      if (index > arrayLength) {
        index = arrayLength - changeRecord.addedCount;
      } else if (index < 0) {
        index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
      }
      if (index < 0) {
        index = 0;
      }
      changeRecord.index = index;
    }

    if (this.changeRecords === null) {
      this.changeRecords = [changeRecord];
    } else {
      this.changeRecords.push(changeRecord);
    }

    if (!this.queued) {
      this.queued = true;
      this.taskQueue.queueMicroTask(this);
    }
  }

  flushChangeRecords() {
    if (this.changeRecords && this.changeRecords.length || this.oldCollection) {
      this.call();
    }
  }

  reset(oldCollection) {
    this.oldCollection = oldCollection;

    if (this.hasSubscribers() && !this.queued) {
      this.queued = true;
      this.taskQueue.queueMicroTask(this);
    }
  }

  getLengthObserver() {
    return this.lengthObserver || (this.lengthObserver = new CollectionLengthObserver(this.collection));
  }

  call() {
    let changeRecords = this.changeRecords;
    let oldCollection = this.oldCollection;
    let records;

    this.queued = false;
    this.changeRecords = [];
    this.oldCollection = null;

    if (this.hasSubscribers()) {
      if (oldCollection) {
        if (this.collection instanceof Map || this.collection instanceof Set) {
          records = getChangeRecords(oldCollection);
        } else {
          records = calcSplices(this.collection, 0, this.collection.length, oldCollection, 0, oldCollection.length);
        }
      } else {
        if (this.collection instanceof Map || this.collection instanceof Set) {
          records = changeRecords;
        } else {
          records = projectArraySplices(this.collection, changeRecords);
        }
      }

      this.callSubscribers(records);
    }

    if (this.lengthObserver) {
      this.lengthObserver.call(this.collection[this.lengthPropertyName]);
    }
  }
}) || _class2);

let CollectionLengthObserver = (_dec4 = subscriberCollection(), _dec4(_class3 = class CollectionLengthObserver {
  constructor(collection) {
    this.collection = collection;
    this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
    this.currentValue = collection[this.lengthPropertyName];
  }

  getValue() {
    return this.collection[this.lengthPropertyName];
  }

  setValue(newValue) {
    this.collection[this.lengthPropertyName] = newValue;
  }

  subscribe(context, callable) {
    this.addSubscriber(context, callable);
  }

  unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  }

  call(newValue) {
    let oldValue = this.currentValue;
    this.callSubscribers(newValue, oldValue);
    this.currentValue = newValue;
  }
}) || _class3);

const arrayProto = Array.prototype;
const pop = arrayProto.pop;
const push = arrayProto.push;
const reverse = arrayProto.reverse;
const shift = arrayProto.shift;
const sort = arrayProto.sort;
const splice = arrayProto.splice;
const unshift = arrayProto.unshift;

if (arrayProto.__au_patched__) {
  aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('array-observation').warn('Detected 2nd attempt of patching array from Aurelia binding.' + ' This is probably caused by dependency mismatch between core modules and a 3rd party plugin.' + ' Please see https://github.com/aurelia/cli/pull/906 if you are using webpack.');
} else {
  Reflect.defineProperty(arrayProto, '__au_patched__', { value: 1 });
  arrayProto.pop = function () {
    let notEmpty = this.length > 0;
    let methodCallResult = pop.apply(this, arguments);
    if (notEmpty && this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'delete',
        object: this,
        name: this.length,
        oldValue: methodCallResult
      });
    }
    return methodCallResult;
  };

  arrayProto.push = function () {
    let methodCallResult = push.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'splice',
        object: this,
        index: this.length - arguments.length,
        removed: [],
        addedCount: arguments.length
      });
    }
    return methodCallResult;
  };

  arrayProto.reverse = function () {
    let oldArray;
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.flushChangeRecords();
      oldArray = this.slice();
    }
    let methodCallResult = reverse.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.reset(oldArray);
    }
    return methodCallResult;
  };

  arrayProto.shift = function () {
    let notEmpty = this.length > 0;
    let methodCallResult = shift.apply(this, arguments);
    if (notEmpty && this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'delete',
        object: this,
        name: 0,
        oldValue: methodCallResult
      });
    }
    return methodCallResult;
  };

  arrayProto.sort = function () {
    let oldArray;
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.flushChangeRecords();
      oldArray = this.slice();
    }
    let methodCallResult = sort.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.reset(oldArray);
    }
    return methodCallResult;
  };

  arrayProto.splice = function () {
    let methodCallResult = splice.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'splice',
        object: this,
        index: +arguments[0],
        removed: methodCallResult,
        addedCount: arguments.length > 2 ? arguments.length - 2 : 0
      });
    }
    return methodCallResult;
  };

  arrayProto.unshift = function () {
    let methodCallResult = unshift.apply(this, arguments);
    if (this.__array_observer__ !== undefined) {
      this.__array_observer__.addChangeRecord({
        type: 'splice',
        object: this,
        index: 0,
        removed: [],
        addedCount: arguments.length
      });
    }
    return methodCallResult;
  };
}

function getArrayObserver(taskQueue, array) {
  return ModifyArrayObserver.for(taskQueue, array);
}

let ModifyArrayObserver = class ModifyArrayObserver extends ModifyCollectionObserver {
  constructor(taskQueue, array) {
    super(taskQueue, array);
  }

  static for(taskQueue, array) {
    if (!('__array_observer__' in array)) {
      Reflect.defineProperty(array, '__array_observer__', {
        value: ModifyArrayObserver.create(taskQueue, array),
        enumerable: false, configurable: false
      });
    }
    return array.__array_observer__;
  }

  static create(taskQueue, array) {
    return new ModifyArrayObserver(taskQueue, array);
  }
};


let Expression = class Expression {
  constructor() {
    this.isAssignable = false;
  }

  evaluate(scope, lookupFunctions, args) {
    throw new Error(`Binding expression "${this}" cannot be evaluated.`);
  }

  assign(scope, value, lookupFunctions) {
    throw new Error(`Binding expression "${this}" cannot be assigned to.`);
  }

  toString() {
    return typeof FEATURE_NO_UNPARSER === 'undefined' ? Unparser.unparse(this) : super.toString();
  }
};

let BindingBehavior = class BindingBehavior extends Expression {
  constructor(expression, name, args) {
    super();

    this.expression = expression;
    this.name = name;
    this.args = args;
  }

  evaluate(scope, lookupFunctions) {
    return this.expression.evaluate(scope, lookupFunctions);
  }

  assign(scope, value, lookupFunctions) {
    return this.expression.assign(scope, value, lookupFunctions);
  }

  accept(visitor) {
    return visitor.visitBindingBehavior(this);
  }

  connect(binding, scope) {
    this.expression.connect(binding, scope);
  }

  bind(binding, scope, lookupFunctions) {
    if (this.expression.expression && this.expression.bind) {
      this.expression.bind(binding, scope, lookupFunctions);
    }
    let behavior = lookupFunctions.bindingBehaviors(this.name);
    if (!behavior) {
      throw new Error(`No BindingBehavior named "${this.name}" was found!`);
    }
    let behaviorKey = `behavior-${this.name}`;
    if (binding[behaviorKey]) {
      throw new Error(`A binding behavior named "${this.name}" has already been applied to "${this.expression}"`);
    }
    binding[behaviorKey] = behavior;
    behavior.bind.apply(behavior, [binding, scope].concat(evalList(scope, this.args, binding.lookupFunctions)));
  }

  unbind(binding, scope) {
    let behaviorKey = `behavior-${this.name}`;
    binding[behaviorKey].unbind(binding, scope);
    binding[behaviorKey] = null;
    if (this.expression.expression && this.expression.unbind) {
      this.expression.unbind(binding, scope);
    }
  }
};

let ValueConverter = class ValueConverter extends Expression {
  constructor(expression, name, args) {
    super();

    this.expression = expression;
    this.name = name;
    this.args = args;
    this.allArgs = [expression].concat(args);
  }

  evaluate(scope, lookupFunctions) {
    let converter = lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error(`No ValueConverter named "${this.name}" was found!`);
    }

    if ('toView' in converter) {
      return converter.toView.apply(converter, evalList(scope, this.allArgs, lookupFunctions));
    }

    return this.allArgs[0].evaluate(scope, lookupFunctions);
  }

  assign(scope, value, lookupFunctions) {
    let converter = lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error(`No ValueConverter named "${this.name}" was found!`);
    }

    if ('fromView' in converter) {
      value = converter.fromView.apply(converter, [value].concat(evalList(scope, this.args, lookupFunctions)));
    }

    return this.allArgs[0].assign(scope, value, lookupFunctions);
  }

  accept(visitor) {
    return visitor.visitValueConverter(this);
  }

  connect(binding, scope) {
    let expressions = this.allArgs;
    let i = expressions.length;
    while (i--) {
      expressions[i].connect(binding, scope);
    }
    let converter = binding.lookupFunctions.valueConverters(this.name);
    if (!converter) {
      throw new Error(`No ValueConverter named "${this.name}" was found!`);
    }
    let signals = converter.signals;
    if (signals === undefined) {
      return;
    }
    i = signals.length;
    while (i--) {
      connectBindingToSignal(binding, signals[i]);
    }
  }
};

let Assign = class Assign extends Expression {
  constructor(target, value) {
    super();

    this.target = target;
    this.value = value;
    this.isAssignable = true;
  }

  evaluate(scope, lookupFunctions) {
    return this.target.assign(scope, this.value.evaluate(scope, lookupFunctions));
  }

  accept(vistor) {
    vistor.visitAssign(this);
  }

  connect(binding, scope) {}

  assign(scope, value) {
    this.value.assign(scope, value);
    this.target.assign(scope, value);
  }
};

let Conditional = class Conditional extends Expression {
  constructor(condition, yes, no) {
    super();

    this.condition = condition;
    this.yes = yes;
    this.no = no;
  }

  evaluate(scope, lookupFunctions) {
    return !!this.condition.evaluate(scope, lookupFunctions) ? this.yes.evaluate(scope, lookupFunctions) : this.no.evaluate(scope, lookupFunctions);
  }

  accept(visitor) {
    return visitor.visitConditional(this);
  }

  connect(binding, scope) {
    this.condition.connect(binding, scope);
    if (this.condition.evaluate(scope)) {
      this.yes.connect(binding, scope);
    } else {
      this.no.connect(binding, scope);
    }
  }
};

let AccessThis = class AccessThis extends Expression {
  constructor(ancestor) {
    super();
    this.ancestor = ancestor;
  }

  evaluate(scope, lookupFunctions) {
    let oc = scope.overrideContext;
    let i = this.ancestor;
    while (i-- && oc) {
      oc = oc.parentOverrideContext;
    }
    return i < 1 && oc ? oc.bindingContext : undefined;
  }

  accept(visitor) {
    return visitor.visitAccessThis(this);
  }

  connect(binding, scope) {}
};

let AccessScope = class AccessScope extends Expression {
  constructor(name, ancestor) {
    super();

    this.name = name;
    this.ancestor = ancestor;
    this.isAssignable = true;
  }

  evaluate(scope, lookupFunctions) {
    let context = getContextFor(this.name, scope, this.ancestor);
    return context[this.name];
  }

  assign(scope, value) {
    let context = getContextFor(this.name, scope, this.ancestor);
    return context ? context[this.name] = value : undefined;
  }

  accept(visitor) {
    return visitor.visitAccessScope(this);
  }

  connect(binding, scope) {
    let context = getContextFor(this.name, scope, this.ancestor);
    binding.observeProperty(context, this.name);
  }
};

let AccessMember = class AccessMember extends Expression {
  constructor(object, name) {
    super();

    this.object = object;
    this.name = name;
    this.isAssignable = true;
  }

  evaluate(scope, lookupFunctions) {
    let instance = this.object.evaluate(scope, lookupFunctions);
    return instance === null || instance === undefined ? instance : instance[this.name];
  }

  assign(scope, value) {
    let instance = this.object.evaluate(scope);

    if (instance === null || instance === undefined) {
      instance = {};
      this.object.assign(scope, instance);
    }

    instance[this.name] = value;
    return value;
  }

  accept(visitor) {
    return visitor.visitAccessMember(this);
  }

  connect(binding, scope) {
    this.object.connect(binding, scope);
    let obj = this.object.evaluate(scope);
    if (obj) {
      binding.observeProperty(obj, this.name);
    }
  }
};

let AccessKeyed = class AccessKeyed extends Expression {
  constructor(object, key) {
    super();

    this.object = object;
    this.key = key;
    this.isAssignable = true;
  }

  evaluate(scope, lookupFunctions) {
    let instance = this.object.evaluate(scope, lookupFunctions);
    let lookup = this.key.evaluate(scope, lookupFunctions);
    return getKeyed(instance, lookup);
  }

  assign(scope, value) {
    let instance = this.object.evaluate(scope);
    let lookup = this.key.evaluate(scope);
    return setKeyed(instance, lookup, value);
  }

  accept(visitor) {
    return visitor.visitAccessKeyed(this);
  }

  connect(binding, scope) {
    this.object.connect(binding, scope);
    let obj = this.object.evaluate(scope);
    if (obj instanceof Object) {
      this.key.connect(binding, scope);
      let key = this.key.evaluate(scope);

      if (key !== null && key !== undefined && !(Array.isArray(obj) && typeof key === 'number')) {
        binding.observeProperty(obj, key);
      }
    }
  }
};

let CallScope = class CallScope extends Expression {
  constructor(name, args, ancestor) {
    super();

    this.name = name;
    this.args = args;
    this.ancestor = ancestor;
  }

  evaluate(scope, lookupFunctions, mustEvaluate) {
    let args = evalList(scope, this.args, lookupFunctions);
    let context = getContextFor(this.name, scope, this.ancestor);
    let func = getFunction(context, this.name, mustEvaluate);
    if (func) {
      return func.apply(context, args);
    }
    return undefined;
  }

  accept(visitor) {
    return visitor.visitCallScope(this);
  }

  connect(binding, scope) {
    let args = this.args;
    let i = args.length;
    while (i--) {
      args[i].connect(binding, scope);
    }
  }
};

let CallMember = class CallMember extends Expression {
  constructor(object, name, args) {
    super();

    this.object = object;
    this.name = name;
    this.args = args;
  }

  evaluate(scope, lookupFunctions, mustEvaluate) {
    let instance = this.object.evaluate(scope, lookupFunctions);
    let args = evalList(scope, this.args, lookupFunctions);
    let func = getFunction(instance, this.name, mustEvaluate);
    if (func) {
      return func.apply(instance, args);
    }
    return undefined;
  }

  accept(visitor) {
    return visitor.visitCallMember(this);
  }

  connect(binding, scope) {
    this.object.connect(binding, scope);
    let obj = this.object.evaluate(scope);
    if (getFunction(obj, this.name, false)) {
      let args = this.args;
      let i = args.length;
      while (i--) {
        args[i].connect(binding, scope);
      }
    }
  }
};

let CallFunction = class CallFunction extends Expression {
  constructor(func, args) {
    super();

    this.func = func;
    this.args = args;
  }

  evaluate(scope, lookupFunctions, mustEvaluate) {
    let func = this.func.evaluate(scope, lookupFunctions);
    if (typeof func === 'function') {
      return func.apply(null, evalList(scope, this.args, lookupFunctions));
    }
    if (!mustEvaluate && (func === null || func === undefined)) {
      return undefined;
    }
    throw new Error(`${this.func} is not a function`);
  }

  accept(visitor) {
    return visitor.visitCallFunction(this);
  }

  connect(binding, scope) {
    this.func.connect(binding, scope);
    let func = this.func.evaluate(scope);
    if (typeof func === 'function') {
      let args = this.args;
      let i = args.length;
      while (i--) {
        args[i].connect(binding, scope);
      }
    }
  }
};

let Binary = class Binary extends Expression {
  constructor(operation, left, right) {
    super();

    this.operation = operation;
    this.left = left;
    this.right = right;
  }

  evaluate(scope, lookupFunctions) {
    let left = this.left.evaluate(scope, lookupFunctions);

    switch (this.operation) {
      case '&&':
        return left && this.right.evaluate(scope, lookupFunctions);
      case '||':
        return left || this.right.evaluate(scope, lookupFunctions);
    }

    let right = this.right.evaluate(scope, lookupFunctions);

    switch (this.operation) {
      case '==':
        return left == right;
      case '===':
        return left === right;
      case '!=':
        return left != right;
      case '!==':
        return left !== right;
      case 'instanceof':
        return typeof right === 'function' && left instanceof right;
      case 'in':
        return typeof right === 'object' && right !== null && left in right;
    }

    if (left === null || right === null || left === undefined || right === undefined) {
      switch (this.operation) {
        case '+':
          if (left !== null && left !== undefined) return left;
          if (right !== null && right !== undefined) return right;
          return 0;
        case '-':
          if (left !== null && left !== undefined) return left;
          if (right !== null && right !== undefined) return 0 - right;
          return 0;
      }

      return null;
    }

    switch (this.operation) {
      case '+':
        return autoConvertAdd(left, right);
      case '-':
        return left - right;
      case '*':
        return left * right;
      case '/':
        return left / right;
      case '%':
        return left % right;
      case '<':
        return left < right;
      case '>':
        return left > right;
      case '<=':
        return left <= right;
      case '>=':
        return left >= right;
      case '^':
        return left ^ right;
    }

    throw new Error(`Internal error [${this.operation}] not handled`);
  }

  accept(visitor) {
    return visitor.visitBinary(this);
  }

  connect(binding, scope) {
    this.left.connect(binding, scope);
    let left = this.left.evaluate(scope);
    if (this.operation === '&&' && !left || this.operation === '||' && left) {
      return;
    }
    this.right.connect(binding, scope);
  }
};

let Unary = class Unary extends Expression {
  constructor(operation, expression) {
    super();

    this.operation = operation;
    this.expression = expression;
  }

  evaluate(scope, lookupFunctions) {
    switch (this.operation) {
      case '!':
        return !this.expression.evaluate(scope, lookupFunctions);
      case 'typeof':
        return typeof this.expression.evaluate(scope, lookupFunctions);
      case 'void':
        return void this.expression.evaluate(scope, lookupFunctions);
    }

    throw new Error(`Internal error [${this.operation}] not handled`);
  }

  accept(visitor) {
    return visitor.visitPrefix(this);
  }

  connect(binding, scope) {
    this.expression.connect(binding, scope);
  }
};

let LiteralPrimitive = class LiteralPrimitive extends Expression {
  constructor(value) {
    super();

    this.value = value;
  }

  evaluate(scope, lookupFunctions) {
    return this.value;
  }

  accept(visitor) {
    return visitor.visitLiteralPrimitive(this);
  }

  connect(binding, scope) {}
};

let LiteralString = class LiteralString extends Expression {
  constructor(value) {
    super();

    this.value = value;
  }

  evaluate(scope, lookupFunctions) {
    return this.value;
  }

  accept(visitor) {
    return visitor.visitLiteralString(this);
  }

  connect(binding, scope) {}
};

let LiteralTemplate = class LiteralTemplate extends Expression {
  constructor(cooked, expressions, raw, tag) {
    super();
    this.cooked = cooked;
    this.expressions = expressions || [];
    this.length = this.expressions.length;
    this.tagged = tag !== undefined;
    if (this.tagged) {
      this.cooked.raw = raw;
      this.tag = tag;
      if (tag instanceof AccessScope) {
        this.contextType = 'Scope';
      } else if (tag instanceof AccessMember || tag instanceof AccessKeyed) {
        this.contextType = 'Object';
      } else {
        throw new Error(`${this.tag} is not a valid template tag`);
      }
    }
  }

  getScopeContext(scope, lookupFunctions) {
    return getContextFor(this.tag.name, scope, this.tag.ancestor);
  }

  getObjectContext(scope, lookupFunctions) {
    return this.tag.object.evaluate(scope, lookupFunctions);
  }

  evaluate(scope, lookupFunctions, mustEvaluate) {
    const results = new Array(this.length);
    for (let i = 0; i < this.length; i++) {
      results[i] = this.expressions[i].evaluate(scope, lookupFunctions);
    }
    if (this.tagged) {
      const func = this.tag.evaluate(scope, lookupFunctions);
      if (typeof func === 'function') {
        const context = this[`get${this.contextType}Context`](scope, lookupFunctions);
        return func.call(context, this.cooked, ...results);
      }
      if (!mustEvaluate) {
        return null;
      }
      throw new Error(`${this.tag} is not a function`);
    }
    let result = this.cooked[0];
    for (let i = 0; i < this.length; i++) {
      result = String.prototype.concat(result, results[i], this.cooked[i + 1]);
    }
    return result;
  }

  accept(visitor) {
    return visitor.visitLiteralTemplate(this);
  }

  connect(binding, scope) {
    for (let i = 0; i < this.length; i++) {
      this.expressions[i].connect(binding, scope);
    }
    if (this.tagged) {
      this.tag.connect(binding, scope);
    }
  }
};

let LiteralArray = class LiteralArray extends Expression {
  constructor(elements) {
    super();

    this.elements = elements;
  }

  evaluate(scope, lookupFunctions) {
    let elements = this.elements;
    let result = [];

    for (let i = 0, length = elements.length; i < length; ++i) {
      result[i] = elements[i].evaluate(scope, lookupFunctions);
    }

    return result;
  }

  accept(visitor) {
    return visitor.visitLiteralArray(this);
  }

  connect(binding, scope) {
    let length = this.elements.length;
    for (let i = 0; i < length; i++) {
      this.elements[i].connect(binding, scope);
    }
  }
};

let LiteralObject = class LiteralObject extends Expression {
  constructor(keys, values) {
    super();

    this.keys = keys;
    this.values = values;
  }

  evaluate(scope, lookupFunctions) {
    let instance = {};
    let keys = this.keys;
    let values = this.values;

    for (let i = 0, length = keys.length; i < length; ++i) {
      instance[keys[i]] = values[i].evaluate(scope, lookupFunctions);
    }

    return instance;
  }

  accept(visitor) {
    return visitor.visitLiteralObject(this);
  }

  connect(binding, scope) {
    let length = this.keys.length;
    for (let i = 0; i < length; i++) {
      this.values[i].connect(binding, scope);
    }
  }
};

function evalList(scope, list, lookupFunctions) {
  const length = list.length;
  const result = [];
  for (let i = 0; i < length; i++) {
    result[i] = list[i].evaluate(scope, lookupFunctions);
  }
  return result;
}

function autoConvertAdd(a, b) {
  if (a !== null && b !== null) {
    if (typeof a === 'string' && typeof b !== 'string') {
      return a + b.toString();
    }

    if (typeof a !== 'string' && typeof b === 'string') {
      return a.toString() + b;
    }

    return a + b;
  }

  if (a !== null) {
    return a;
  }

  if (b !== null) {
    return b;
  }

  return 0;
}

function getFunction(obj, name, mustExist) {
  let func = obj === null || obj === undefined ? null : obj[name];
  if (typeof func === 'function') {
    return func;
  }
  if (!mustExist && (func === null || func === undefined)) {
    return null;
  }
  throw new Error(`${name} is not a function`);
}

function getKeyed(obj, key) {
  if (Array.isArray(obj)) {
    return obj[parseInt(key, 10)];
  } else if (obj) {
    return obj[key];
  } else if (obj === null || obj === undefined) {
    return undefined;
  }

  return obj[key];
}

function setKeyed(obj, key, value) {
  if (Array.isArray(obj)) {
    let index = parseInt(key, 10);

    if (obj.length <= index) {
      obj.length = index + 1;
    }

    obj[index] = value;
  } else {
    obj[key] = value;
  }

  return value;
}

let Unparser = null;

if (typeof FEATURE_NO_UNPARSER === 'undefined') {
  Unparser = class {
    constructor(buffer) {
      this.buffer = buffer;
    }

    static unparse(expression) {
      let buffer = [];
      let visitor = new Unparser(buffer);

      expression.accept(visitor);

      return buffer.join('');
    }

    write(text) {
      this.buffer.push(text);
    }

    writeArgs(args) {
      this.write('(');

      for (let i = 0, length = args.length; i < length; ++i) {
        if (i !== 0) {
          this.write(',');
        }

        args[i].accept(this);
      }

      this.write(')');
    }

    visitBindingBehavior(behavior) {
      let args = behavior.args;

      behavior.expression.accept(this);
      this.write(`&${behavior.name}`);

      for (let i = 0, length = args.length; i < length; ++i) {
        this.write(':');
        args[i].accept(this);
      }
    }

    visitValueConverter(converter) {
      let args = converter.args;

      converter.expression.accept(this);
      this.write(`|${converter.name}`);

      for (let i = 0, length = args.length; i < length; ++i) {
        this.write(':');
        args[i].accept(this);
      }
    }

    visitAssign(assign) {
      assign.target.accept(this);
      this.write('=');
      assign.value.accept(this);
    }

    visitConditional(conditional) {
      conditional.condition.accept(this);
      this.write('?');
      conditional.yes.accept(this);
      this.write(':');
      conditional.no.accept(this);
    }

    visitAccessThis(access) {
      if (access.ancestor === 0) {
        this.write('$this');
        return;
      }
      this.write('$parent');
      let i = access.ancestor - 1;
      while (i--) {
        this.write('.$parent');
      }
    }

    visitAccessScope(access) {
      let i = access.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(access.name);
    }

    visitAccessMember(access) {
      access.object.accept(this);
      this.write(`.${access.name}`);
    }

    visitAccessKeyed(access) {
      access.object.accept(this);
      this.write('[');
      access.key.accept(this);
      this.write(']');
    }

    visitCallScope(call) {
      let i = call.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(call.name);
      this.writeArgs(call.args);
    }

    visitCallFunction(call) {
      call.func.accept(this);
      this.writeArgs(call.args);
    }

    visitCallMember(call) {
      call.object.accept(this);
      this.write(`.${call.name}`);
      this.writeArgs(call.args);
    }

    visitPrefix(prefix) {
      this.write(`(${prefix.operation}`);
      if (prefix.operation.charCodeAt(0) >= 97) {
        this.write(' ');
      }
      prefix.expression.accept(this);
      this.write(')');
    }

    visitBinary(binary) {
      binary.left.accept(this);
      if (binary.operation.charCodeAt(0) === 105) {
        this.write(` ${binary.operation} `);
      } else {
        this.write(binary.operation);
      }
      binary.right.accept(this);
    }

    visitLiteralPrimitive(literal) {
      this.write(`${literal.value}`);
    }

    visitLiteralArray(literal) {
      let elements = literal.elements;

      this.write('[');

      for (let i = 0, length = elements.length; i < length; ++i) {
        if (i !== 0) {
          this.write(',');
        }

        elements[i].accept(this);
      }

      this.write(']');
    }

    visitLiteralObject(literal) {
      let keys = literal.keys;
      let values = literal.values;

      this.write('{');

      for (let i = 0, length = keys.length; i < length; ++i) {
        if (i !== 0) {
          this.write(',');
        }

        this.write(`'${keys[i]}':`);
        values[i].accept(this);
      }

      this.write('}');
    }

    visitLiteralString(literal) {
      let escaped = literal.value.replace(/'/g, "\'");
      this.write(`'${escaped}'`);
    }

    visitLiteralTemplate(literal) {
      const { cooked, expressions } = literal;
      const length = expressions.length;
      this.write('`');
      this.write(cooked[0]);
      for (let i = 0; i < length; i++) {
        expressions[i].accept(this);
        this.write(cooked[i + 1]);
      }
      this.write('`');
    }
  };
}

let ExpressionCloner = class ExpressionCloner {
  cloneExpressionArray(array) {
    let clonedArray = [];
    let i = array.length;
    while (i--) {
      clonedArray[i] = array[i].accept(this);
    }
    return clonedArray;
  }

  visitBindingBehavior(behavior) {
    return new BindingBehavior(behavior.expression.accept(this), behavior.name, this.cloneExpressionArray(behavior.args));
  }

  visitValueConverter(converter) {
    return new ValueConverter(converter.expression.accept(this), converter.name, this.cloneExpressionArray(converter.args));
  }

  visitAssign(assign) {
    return new Assign(assign.target.accept(this), assign.value.accept(this));
  }

  visitConditional(conditional) {
    return new Conditional(conditional.condition.accept(this), conditional.yes.accept(this), conditional.no.accept(this));
  }

  visitAccessThis(access) {
    return new AccessThis(access.ancestor);
  }

  visitAccessScope(access) {
    return new AccessScope(access.name, access.ancestor);
  }

  visitAccessMember(access) {
    return new AccessMember(access.object.accept(this), access.name);
  }

  visitAccessKeyed(access) {
    return new AccessKeyed(access.object.accept(this), access.key.accept(this));
  }

  visitCallScope(call) {
    return new CallScope(call.name, this.cloneExpressionArray(call.args), call.ancestor);
  }

  visitCallFunction(call) {
    return new CallFunction(call.func.accept(this), this.cloneExpressionArray(call.args));
  }

  visitCallMember(call) {
    return new CallMember(call.object.accept(this), call.name, this.cloneExpressionArray(call.args));
  }

  visitUnary(unary) {
    return new Unary(prefix.operation, prefix.expression.accept(this));
  }

  visitBinary(binary) {
    return new Binary(binary.operation, binary.left.accept(this), binary.right.accept(this));
  }

  visitLiteralPrimitive(literal) {
    return new LiteralPrimitive(literal);
  }

  visitLiteralArray(literal) {
    return new LiteralArray(this.cloneExpressionArray(literal.elements));
  }

  visitLiteralObject(literal) {
    return new LiteralObject(literal.keys, this.cloneExpressionArray(literal.values));
  }

  visitLiteralString(literal) {
    return new LiteralString(literal.value);
  }

  visitLiteralTemplate(literal) {
    return new LiteralTemplate(literal.cooked, this.cloneExpressionArray(literal.expressions), literal.raw, literal.tag && literal.tag.accept(this));
  }
};

function cloneExpression(expression) {
  let visitor = new ExpressionCloner();
  return expression.accept(visitor);
}

const bindingMode = {
  oneTime: 0,
  toView: 1,
  oneWay: 1,
  twoWay: 2,
  fromView: 3
};

let Parser = class Parser {
  constructor() {
    this.cache = Object.create(null);
  }

  parse(src) {
    src = src || '';

    return this.cache[src] || (this.cache[src] = new ParserImplementation(src).parseBindingBehavior());
  }
};

const fromCharCode = String.fromCharCode;

let ParserImplementation = class ParserImplementation {
  get raw() {
    return this.src.slice(this.start, this.idx);
  }

  constructor(src) {
    this.idx = 0;

    this.start = 0;

    this.src = src;
    this.len = src.length;

    this.tkn = T$EOF;

    this.val = undefined;

    this.ch = src.charCodeAt(0);
  }

  parseBindingBehavior() {
    this.nextToken();
    if (this.tkn & T$ExpressionTerminal) {
      this.err('Invalid start of expression');
    }
    let result = this.parseValueConverter();
    while (this.opt(T$Ampersand)) {
      result = new BindingBehavior(result, this.val, this.parseVariadicArgs());
    }
    if (this.tkn !== T$EOF) {
      this.err(`Unconsumed token ${this.raw}`);
    }
    return result;
  }

  parseValueConverter() {
    let result = this.parseExpression();
    while (this.opt(T$Bar)) {
      result = new ValueConverter(result, this.val, this.parseVariadicArgs());
    }
    return result;
  }

  parseVariadicArgs() {
    this.nextToken();
    const result = [];
    while (this.opt(T$Colon)) {
      result.push(this.parseExpression());
    }
    return result;
  }

  parseExpression() {
    let exprStart = this.idx;
    let result = this.parseConditional();

    while (this.tkn === T$Eq) {
      if (!result.isAssignable) {
        this.err(`Expression ${this.src.slice(exprStart, this.start)} is not assignable`);
      }
      this.nextToken();
      exprStart = this.idx;
      result = new Assign(result, this.parseConditional());
    }
    return result;
  }

  parseConditional() {
    let result = this.parseBinary(0);

    if (this.opt(T$Question)) {
      let yes = this.parseExpression();
      this.expect(T$Colon);
      result = new Conditional(result, yes, this.parseExpression());
    }
    return result;
  }

  parseBinary(minPrecedence) {
    let left = this.parseLeftHandSide(0);

    while (this.tkn & T$BinaryOp) {
      const opToken = this.tkn;
      if ((opToken & T$Precedence) <= minPrecedence) {
        break;
      }
      this.nextToken();
      left = new Binary(TokenValues[opToken & T$TokenMask], left, this.parseBinary(opToken & T$Precedence));
    }
    return left;
  }

  parseLeftHandSide(context) {
    let result;

    primary: switch (this.tkn) {
      case T$Plus:
        this.nextToken();
        return this.parseLeftHandSide(0);
      case T$Minus:
        this.nextToken();
        return new Binary('-', new LiteralPrimitive(0), this.parseLeftHandSide(0));
      case T$Bang:
      case T$TypeofKeyword:
      case T$VoidKeyword:
        const op = TokenValues[this.tkn & T$TokenMask];
        this.nextToken();
        return new Unary(op, this.parseLeftHandSide(0));
      case T$ParentScope:
        {
          do {
            this.nextToken();
            context++;
            if (this.opt(T$Period)) {
              if (this.tkn === T$Period) {
                this.err();
              }
              continue;
            } else if (this.tkn & T$AccessScopeTerminal) {
              result = new AccessThis(context & C$Ancestor);

              context = context & C$ShorthandProp | C$This;
              break primary;
            } else {
              this.err();
            }
          } while (this.tkn === T$ParentScope);
        }

      case T$Identifier:
        {
          result = new AccessScope(this.val, context & C$Ancestor);
          this.nextToken();
          context = context & C$ShorthandProp | C$Scope;
          break;
        }
      case T$ThisScope:
        this.nextToken();
        result = new AccessThis(0);
        context = context & C$ShorthandProp | C$This;
        break;
      case T$LParen:
        this.nextToken();
        result = this.parseExpression();
        this.expect(T$RParen);
        context = C$Primary;
        break;
      case T$LBracket:
        {
          this.nextToken();
          const elements = [];
          if (this.tkn !== T$RBracket) {
            do {
              elements.push(this.parseExpression());
            } while (this.opt(T$Comma));
          }
          this.expect(T$RBracket);
          result = new LiteralArray(elements);
          context = C$Primary;
          break;
        }
      case T$LBrace:
        {
          const keys = [];
          const values = [];
          this.nextToken();
          while (this.tkn !== T$RBrace) {
            if (this.tkn & T$IdentifierOrKeyword) {
              const { ch, tkn, idx } = this;
              keys.push(this.val);
              this.nextToken();
              if (this.opt(T$Colon)) {
                values.push(this.parseExpression());
              } else {
                this.ch = ch;
                this.tkn = tkn;
                this.idx = idx;
                values.push(this.parseLeftHandSide(C$ShorthandProp));
              }
            } else if (this.tkn & T$Literal) {
              keys.push(this.val);
              this.nextToken();
              this.expect(T$Colon);
              values.push(this.parseExpression());
            } else {
              this.err();
            }
            if (this.tkn !== T$RBrace) {
              this.expect(T$Comma);
            }
          }
          this.expect(T$RBrace);
          result = new LiteralObject(keys, values);
          context = C$Primary;
          break;
        }
      case T$StringLiteral:
        result = new LiteralString(this.val);
        this.nextToken();
        context = C$Primary;
        break;
      case T$TemplateTail:
        result = new LiteralTemplate([this.val]);
        this.nextToken();
        context = C$Primary;
        break;
      case T$TemplateContinuation:
        result = this.parseTemplate(0);
        context = C$Primary;
        break;
      case T$NumericLiteral:
        {
          result = new LiteralPrimitive(this.val);
          this.nextToken();

          break;
        }
      case T$NullKeyword:
      case T$UndefinedKeyword:
      case T$TrueKeyword:
      case T$FalseKeyword:
        result = new LiteralPrimitive(TokenValues[this.tkn & T$TokenMask]);
        this.nextToken();
        context = C$Primary;
        break;
      default:
        if (this.idx >= this.len) {
          this.err('Unexpected end of expression');
        } else {
          this.err();
        }
    }

    if (context & C$ShorthandProp) {
      return result;
    }

    let name = this.val;
    while (this.tkn & T$MemberOrCallExpression) {
      switch (this.tkn) {
        case T$Period:
          this.nextToken();
          if (!(this.tkn & T$IdentifierOrKeyword)) {
            this.err();
          }
          name = this.val;
          this.nextToken();

          context = context & C$Primary | (context & (C$This | C$Scope)) << 1 | context & C$Member | (context & C$Keyed) >> 1 | (context & C$Call) >> 2;
          if (this.tkn === T$LParen) {
            continue;
          }
          if (context & C$Scope) {
            result = new AccessScope(name, result.ancestor);
          } else {
            result = new AccessMember(result, name);
          }
          continue;
        case T$LBracket:
          this.nextToken();
          context = C$Keyed;
          result = new AccessKeyed(result, this.parseExpression());
          this.expect(T$RBracket);
          break;
        case T$LParen:
          this.nextToken();
          const args = [];
          while (this.tkn !== T$RParen) {
            args.push(this.parseExpression());
            if (!this.opt(T$Comma)) {
              break;
            }
          }
          this.expect(T$RParen);
          if (context & C$Scope) {
            result = new CallScope(name, args, result.ancestor);
          } else if (context & (C$Member | C$Primary)) {
            result = new CallMember(result, name, args);
          } else {
            result = new CallFunction(result, args);
          }
          context = C$Call;
          break;
        case T$TemplateTail:
          result = new LiteralTemplate([this.val], [], [this.raw], result);
          this.nextToken();
          break;
        case T$TemplateContinuation:
          result = this.parseTemplate(context | C$Tagged, result);
      }
    }

    return result;
  }

  parseTemplate(context, func) {
    const cooked = [this.val];
    const raw = context & C$Tagged ? [this.raw] : undefined;
    this.expect(T$TemplateContinuation);
    const expressions = [this.parseExpression()];

    while ((this.tkn = this.scanTemplateTail()) !== T$TemplateTail) {
      cooked.push(this.val);
      if (context & C$Tagged) {
        raw.push(this.raw);
      }
      this.expect(T$TemplateContinuation);
      expressions.push(this.parseExpression());
    }

    cooked.push(this.val);
    if (context & C$Tagged) {
      raw.push(this.raw);
    }
    this.nextToken();
    return new LiteralTemplate(cooked, expressions, raw, func);
  }

  nextToken() {
    while (this.idx < this.len) {
      if (this.ch <= 0x20) {
        this.next();
        continue;
      }
      this.start = this.idx;
      if (this.ch === 0x24 || this.ch >= 0x61 && this.ch <= 0x7A) {
        this.tkn = this.scanIdentifier();
        return;
      }

      if ((this.tkn = CharScanners[this.ch](this)) !== null) {
        return;
      }
    }
    this.tkn = T$EOF;
  }

  next() {
    return this.ch = this.src.charCodeAt(++this.idx);
  }

  scanIdentifier() {
    while (AsciiIdParts.has(this.next()) || this.ch > 0x7F && IdParts[this.ch]) {}

    return KeywordLookup[this.val = this.raw] || T$Identifier;
  }

  scanNumber(isFloat) {
    if (isFloat) {
      this.val = 0;
    } else {
      this.val = this.ch - 0x30;
      while (this.next() <= 0x39 && this.ch >= 0x30) {
        this.val = this.val * 10 + this.ch - 0x30;
      }
    }

    if (isFloat || this.ch === 0x2E) {
      if (!isFloat) {
        this.next();
      }
      const start = this.idx;
      let value = this.ch - 0x30;
      while (this.next() <= 0x39 && this.ch >= 0x30) {
        value = value * 10 + this.ch - 0x30;
      }
      this.val = this.val + value / Math.pow(10, this.idx - start);
    }

    if (this.ch === 0x65 || this.ch === 0x45) {
      const start = this.idx;

      this.next();
      if (this.ch === 0x2D || this.ch === 0x2B) {
        this.next();
      }

      if (!(this.ch >= 0x30 && this.ch <= 0x39)) {
        this.idx = start;
        this.err('Invalid exponent');
      }
      while (this.next() <= 0x39 && this.ch >= 0x30) {}
      this.val = parseFloat(this.src.slice(this.start, this.idx));
    }

    return T$NumericLiteral;
  }

  scanString() {
    let quote = this.ch;
    this.next();

    let buffer;
    let marker = this.idx;

    while (this.ch !== quote) {
      if (this.ch === 0x5C) {
        if (!buffer) {
          buffer = [];
        }

        buffer.push(this.src.slice(marker, this.idx));

        this.next();

        let unescaped;

        if (this.ch === 0x75) {
          this.next();

          if (this.idx + 4 < this.len) {
            let hex = this.src.slice(this.idx, this.idx + 4);

            if (!/[A-Z0-9]{4}/i.test(hex)) {
              this.err(`Invalid unicode escape [\\u${hex}]`);
            }

            unescaped = parseInt(hex, 16);
            this.idx += 4;
            this.ch = this.src.charCodeAt(this.idx);
          } else {
            this.err();
          }
        } else {
          unescaped = unescape(this.ch);
          this.next();
        }

        buffer.push(fromCharCode(unescaped));
        marker = this.idx;
      } else if (this.ch === 0 || this.idx >= this.len) {
        this.err('Unterminated quote');
      } else {
        this.next();
      }
    }

    let last = this.src.slice(marker, this.idx);
    this.next();
    let unescaped = last;

    if (buffer !== null && buffer !== undefined) {
      buffer.push(last);
      unescaped = buffer.join('');
    }

    this.val = unescaped;
    return T$StringLiteral;
  }

  scanTemplate() {
    let tail = true;
    let result = '';

    while (this.next() !== 0x60) {
      if (this.ch === 0x24) {
        if (this.idx + 1 < this.len && this.src.charCodeAt(this.idx + 1) === 0x7B) {
          this.idx++;
          tail = false;
          break;
        } else {
          result += '$';
        }
      } else if (this.ch === 0x5C) {
        result += fromCharCode(unescape(this.next()));
      } else if (this.ch === 0 || this.idx >= this.len) {
        this.err('Unterminated template literal');
      } else {
        result += fromCharCode(this.ch);
      }
    }

    this.next();
    this.val = result;
    if (tail) {
      return T$TemplateTail;
    }
    return T$TemplateContinuation;
  }

  scanTemplateTail() {
    if (this.idx >= this.len) {
      this.err('Unterminated template');
    }
    this.idx--;
    return this.scanTemplate();
  }

  err(message = `Unexpected token ${this.raw}`, column = this.start) {
    throw new Error(`Parser Error: ${message} at column ${column} in expression [${this.src}]`);
  }

  opt(token) {
    if (this.tkn === token) {
      this.nextToken();
      return true;
    }

    return false;
  }

  expect(token) {
    if (this.tkn === token) {
      this.nextToken();
    } else {
      this.err(`Missing expected token ${TokenValues[token & T$TokenMask]}`, this.idx);
    }
  }
};

function unescape(code) {
  switch (code) {
    case 0x66:
      return 0xC;
    case 0x6E:
      return 0xA;
    case 0x72:
      return 0xD;
    case 0x74:
      return 0x9;
    case 0x76:
      return 0xB;
    default:
      return code;
  }
}

const C$This = 1 << 10;
const C$Scope = 1 << 11;
const C$Member = 1 << 12;
const C$Keyed = 1 << 13;
const C$Call = 1 << 14;
const C$Primary = 1 << 15;
const C$ShorthandProp = 1 << 16;
const C$Tagged = 1 << 17;

const C$Ancestor = (1 << 9) - 1;

const T$TokenMask = (1 << 6) - 1;

const T$PrecShift = 6;

const T$Precedence = 7 << T$PrecShift;

const T$ExpressionTerminal = 1 << 11;

const T$ClosingToken = 1 << 12;

const T$OpeningToken = 1 << 13;

const T$AccessScopeTerminal = 1 << 14;
const T$Keyword = 1 << 15;
const T$EOF = 1 << 16 | T$AccessScopeTerminal | T$ExpressionTerminal;
const T$Identifier = 1 << 17;
const T$IdentifierOrKeyword = T$Identifier | T$Keyword;
const T$Literal = 1 << 18;
const T$NumericLiteral = 1 << 19 | T$Literal;
const T$StringLiteral = 1 << 20 | T$Literal;
const T$BinaryOp = 1 << 21;

const T$UnaryOp = 1 << 22;

const T$MemberExpression = 1 << 23;

const T$MemberOrCallExpression = 1 << 24;
const T$TemplateTail = 1 << 25 | T$MemberOrCallExpression;
const T$TemplateContinuation = 1 << 26 | T$MemberOrCallExpression;

const T$FalseKeyword = 0 | T$Keyword | T$Literal;
const T$TrueKeyword = 1 | T$Keyword | T$Literal;
const T$NullKeyword = 2 | T$Keyword | T$Literal;
const T$UndefinedKeyword = 3 | T$Keyword | T$Literal;
const T$ThisScope = 4 | T$IdentifierOrKeyword;
const T$ParentScope = 5 | T$IdentifierOrKeyword;

const T$LParen = 6 | T$OpeningToken | T$AccessScopeTerminal | T$MemberOrCallExpression;
const T$LBrace = 7 | T$OpeningToken;
const T$Period = 8 | T$MemberExpression | T$MemberOrCallExpression;
const T$RBrace = 9 | T$AccessScopeTerminal | T$ClosingToken | T$ExpressionTerminal;
const T$RParen = 10 | T$AccessScopeTerminal | T$ClosingToken | T$ExpressionTerminal;
const T$Comma = 11 | T$AccessScopeTerminal;
const T$LBracket = 12 | T$OpeningToken | T$AccessScopeTerminal | T$MemberExpression | T$MemberOrCallExpression;
const T$RBracket = 13 | T$ClosingToken | T$ExpressionTerminal;
const T$Colon = 14 | T$AccessScopeTerminal;
const T$Question = 15;

const T$Ampersand = 18 | T$AccessScopeTerminal;
const T$Bar = 19 | T$AccessScopeTerminal;
const T$BarBar = 20 | 1 << T$PrecShift | T$BinaryOp;
const T$AmpersandAmpersand = 21 | 2 << T$PrecShift | T$BinaryOp;
const T$Caret = 22 | 3 << T$PrecShift | T$BinaryOp;
const T$EqEq = 23 | 4 << T$PrecShift | T$BinaryOp;
const T$BangEq = 24 | 4 << T$PrecShift | T$BinaryOp;
const T$EqEqEq = 25 | 4 << T$PrecShift | T$BinaryOp;
const T$BangEqEq = 26 | 4 << T$PrecShift | T$BinaryOp;
const T$Lt = 27 | 5 << T$PrecShift | T$BinaryOp;
const T$Gt = 28 | 5 << T$PrecShift | T$BinaryOp;
const T$LtEq = 29 | 5 << T$PrecShift | T$BinaryOp;
const T$GtEq = 30 | 5 << T$PrecShift | T$BinaryOp;
const T$InKeyword = 31 | 5 << T$PrecShift | T$BinaryOp | T$Keyword;
const T$InstanceOfKeyword = 32 | 5 << T$PrecShift | T$BinaryOp | T$Keyword;
const T$Plus = 33 | 6 << T$PrecShift | T$BinaryOp | T$UnaryOp;
const T$Minus = 34 | 6 << T$PrecShift | T$BinaryOp | T$UnaryOp;
const T$TypeofKeyword = 35 | T$UnaryOp | T$Keyword;
const T$VoidKeyword = 36 | T$UnaryOp | T$Keyword;
const T$Star = 37 | 7 << T$PrecShift | T$BinaryOp;
const T$Percent = 38 | 7 << T$PrecShift | T$BinaryOp;
const T$Slash = 39 | 7 << T$PrecShift | T$BinaryOp;
const T$Eq = 40;
const T$Bang = 41 | T$UnaryOp;

const KeywordLookup = Object.create(null);
KeywordLookup.true = T$TrueKeyword;
KeywordLookup.null = T$NullKeyword;
KeywordLookup.false = T$FalseKeyword;
KeywordLookup.undefined = T$UndefinedKeyword;
KeywordLookup.$this = T$ThisScope;
KeywordLookup.$parent = T$ParentScope;
KeywordLookup.in = T$InKeyword;
KeywordLookup.instanceof = T$InstanceOfKeyword;
KeywordLookup.typeof = T$TypeofKeyword;
KeywordLookup.void = T$VoidKeyword;

const TokenValues = [false, true, null, undefined, '$this', '$parent', '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\'', '"', '&', '|', '||', '&&', '^', '==', '!=', '===', '!==', '<', '>', '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!'];

const codes = {
  AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],
  IdStart: [0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],
  Digit: [0x30, 0x3A],
  Skip: [0, 0x21, 0x7F, 0xA1]
};

function decompress(lookup, set, compressed, value) {
  let rangeCount = compressed.length;
  for (let i = 0; i < rangeCount; i += 2) {
    const start = compressed[i];
    let end = compressed[i + 1];
    end = end > 0 ? end : start + 1;
    if (lookup) {
      let j = start;
      while (j < end) {
        lookup[j] = value;
        j++;
      }
    }
    if (set) {
      for (let ch = start; ch < end; ch++) {
        set.add(ch);
      }
    }
  }
}

function returnToken(token) {
  return p => {
    p.next();
    return token;
  };
}
function unexpectedCharacter(p) {
  p.err(`Unexpected character [${fromCharCode(p.ch)}]`);
  return null;
}

const AsciiIdParts = new Set();
decompress(null, AsciiIdParts, codes.AsciiIdPart, true);

const IdParts = new Uint8Array(0xFFFF);
decompress(IdParts, null, codes.IdStart, 1);
decompress(IdParts, null, codes.Digit, 1);

const CharScanners = new Array(0xFFFF);
let ci = 0;
while (ci < 0xFFFF) {
  CharScanners[ci] = unexpectedCharacter;
  ci++;
}

decompress(CharScanners, null, codes.Skip, p => {
  p.next();
  return null;
});
decompress(CharScanners, null, codes.IdStart, p => p.scanIdentifier());
decompress(CharScanners, null, codes.Digit, p => p.scanNumber(false));

CharScanners[0x22] = CharScanners[0x27] = p => {
  return p.scanString();
};
CharScanners[0x60] = p => {
  return p.scanTemplate();
};

CharScanners[0x21] = p => {
  if (p.next() !== 0x3D) {
    return T$Bang;
  }
  if (p.next() !== 0x3D) {
    return T$BangEq;
  }
  p.next();
  return T$BangEqEq;
};

CharScanners[0x3D] = p => {
  if (p.next() !== 0x3D) {
    return T$Eq;
  }
  if (p.next() !== 0x3D) {
    return T$EqEq;
  }
  p.next();
  return T$EqEqEq;
};

CharScanners[0x26] = p => {
  if (p.next() !== 0x26) {
    return T$Ampersand;
  }
  p.next();
  return T$AmpersandAmpersand;
};

CharScanners[0x7C] = p => {
  if (p.next() !== 0x7C) {
    return T$Bar;
  }
  p.next();
  return T$BarBar;
};

CharScanners[0x2E] = p => {
  if (p.next() <= 0x39 && p.ch >= 0x30) {
    return p.scanNumber(true);
  }
  return T$Period;
};

CharScanners[0x3C] = p => {
  if (p.next() !== 0x3D) {
    return T$Lt;
  }
  p.next();
  return T$LtEq;
};

CharScanners[0x3E] = p => {
  if (p.next() !== 0x3D) {
    return T$Gt;
  }
  p.next();
  return T$GtEq;
};

CharScanners[0x25] = returnToken(T$Percent);
CharScanners[0x28] = returnToken(T$LParen);
CharScanners[0x29] = returnToken(T$RParen);
CharScanners[0x2A] = returnToken(T$Star);
CharScanners[0x2B] = returnToken(T$Plus);
CharScanners[0x2C] = returnToken(T$Comma);
CharScanners[0x2D] = returnToken(T$Minus);
CharScanners[0x2F] = returnToken(T$Slash);
CharScanners[0x3A] = returnToken(T$Colon);
CharScanners[0x3F] = returnToken(T$Question);
CharScanners[0x5B] = returnToken(T$LBracket);
CharScanners[0x5D] = returnToken(T$RBracket);
CharScanners[0x5E] = returnToken(T$Caret);
CharScanners[0x7B] = returnToken(T$LBrace);
CharScanners[0x7D] = returnToken(T$RBrace);

let mapProto = Map.prototype;

function getMapObserver(taskQueue, map) {
  return ModifyMapObserver.for(taskQueue, map);
}

let ModifyMapObserver = class ModifyMapObserver extends ModifyCollectionObserver {
  constructor(taskQueue, map) {
    super(taskQueue, map);
  }

  static for(taskQueue, map) {
    if (!('__map_observer__' in map)) {
      Reflect.defineProperty(map, '__map_observer__', {
        value: ModifyMapObserver.create(taskQueue, map),
        enumerable: false, configurable: false
      });
    }
    return map.__map_observer__;
  }

  static create(taskQueue, map) {
    let observer = new ModifyMapObserver(taskQueue, map);

    let proto = mapProto;
    if (proto.set !== map.set || proto.delete !== map.delete || proto.clear !== map.clear) {
      proto = {
        set: map.set,
        delete: map.delete,
        clear: map.clear
      };
    }

    map.set = function () {
      let hasValue = map.has(arguments[0]);
      let type = hasValue ? 'update' : 'add';
      let oldValue = map.get(arguments[0]);
      let methodCallResult = proto.set.apply(map, arguments);
      if (!hasValue || oldValue !== map.get(arguments[0])) {
        observer.addChangeRecord({
          type: type,
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
      }
      return methodCallResult;
    };

    map.delete = function () {
      let hasValue = map.has(arguments[0]);
      let oldValue = map.get(arguments[0]);
      let methodCallResult = proto.delete.apply(map, arguments);
      if (hasValue) {
        observer.addChangeRecord({
          type: 'delete',
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
      }
      return methodCallResult;
    };

    map.clear = function () {
      let methodCallResult = proto.clear.apply(map, arguments);
      observer.addChangeRecord({
        type: 'clear',
        object: map
      });
      return methodCallResult;
    };

    return observer;
  }
};

let emLogger = aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('event-manager');

function findOriginalEventTarget(event) {
  return event.composedPath && event.composedPath()[0] || event.deepPath && event.deepPath()[0] || event.path && event.path[0] || event.target;
}

function stopPropagation() {
  this.standardStopPropagation();
  this.propagationStopped = true;
}

function handleCapturedEvent(event) {
  event.propagationStopped = false;
  let target = findOriginalEventTarget(event);

  let orderedCallbacks = [];

  while (target) {
    if (target.capturedCallbacks) {
      let callback = target.capturedCallbacks[event.type];
      if (callback) {
        if (event.stopPropagation !== stopPropagation) {
          event.standardStopPropagation = event.stopPropagation;
          event.stopPropagation = stopPropagation;
        }
        orderedCallbacks.push(callback);
      }
    }
    target = target.parentNode;
  }
  for (let i = orderedCallbacks.length - 1; i >= 0 && !event.propagationStopped; i--) {
    let orderedCallback = orderedCallbacks[i];
    if ('handleEvent' in orderedCallback) {
      orderedCallback.handleEvent(event);
    } else {
      orderedCallback(event);
    }
  }
}

let CapturedHandlerEntry = class CapturedHandlerEntry {
  constructor(eventName) {
    this.eventName = eventName;
    this.count = 0;
  }

  increment() {
    this.count++;

    if (this.count === 1) {
      aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.addEventListener(this.eventName, handleCapturedEvent, true);
    }
  }

  decrement() {
    if (this.count === 0) {
      emLogger.warn('The same EventListener was disposed multiple times.');
    } else if (--this.count === 0) {
      aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.removeEventListener(this.eventName, handleCapturedEvent, true);
    }
  }
};
let DelegateHandlerEntry = class DelegateHandlerEntry {
  constructor(eventName, eventManager) {
    this.eventName = eventName;
    this.count = 0;
    this.eventManager = eventManager;
  }

  handleEvent(event) {
    event.propagationStopped = false;
    let target = findOriginalEventTarget(event);

    while (target && !event.propagationStopped) {
      if (target.delegatedCallbacks) {
        let callback = target.delegatedCallbacks[event.type];
        if (callback) {
          if (event.stopPropagation !== stopPropagation) {
            event.standardStopPropagation = event.stopPropagation;
            event.stopPropagation = stopPropagation;
          }
          if ('handleEvent' in callback) {
            callback.handleEvent(event);
          } else {
            callback(event);
          }
        }
      }

      const parent = target.parentNode;
      const shouldEscapeShadowRoot = this.eventManager.escapeShadowRoot && parent instanceof ShadowRoot;

      target = shouldEscapeShadowRoot ? parent.host : parent;
    }
  }

  increment() {
    this.count++;

    if (this.count === 1) {
      aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.addEventListener(this.eventName, this, false);
    }
  }

  decrement() {
    if (this.count === 0) {
      emLogger.warn('The same EventListener was disposed multiple times.');
    } else if (--this.count === 0) {
      aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.removeEventListener(this.eventName, this, false);
    }
  }
};
let DelegationEntryHandler = class DelegationEntryHandler {
  constructor(entry, lookup, targetEvent) {
    this.entry = entry;
    this.lookup = lookup;
    this.targetEvent = targetEvent;
  }

  dispose() {
    if (this.lookup[this.targetEvent]) {
      this.entry.decrement();
      this.lookup[this.targetEvent] = null;
    } else {
      emLogger.warn('Calling .dispose() on already disposed eventListener');
    }
  }
};
let EventHandler = class EventHandler {
  constructor(target, targetEvent, callback) {
    this.target = target;
    this.targetEvent = targetEvent;
    this.callback = callback;
  }

  dispose() {
    this.target.removeEventListener(this.targetEvent, this.callback);
  }
};
let DefaultEventStrategy = class DefaultEventStrategy {

  constructor(eventManager) {
    this.delegatedHandlers = {};
    this.capturedHandlers = {};

    this.eventManager = eventManager;
  }

  subscribe(target, targetEvent, callback, strategy, disposable) {
    let delegatedHandlers;
    let capturedHandlers;
    let handlerEntry;

    if (strategy === delegationStrategy.bubbling) {
      delegatedHandlers = this.delegatedHandlers;
      handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new DelegateHandlerEntry(targetEvent, this.eventManager));
      let delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});
      if (!delegatedCallbacks[targetEvent]) {
        handlerEntry.increment();
      } else {
        emLogger.warn('Overriding previous callback for event listener', { event: targetEvent, callback: callback, previousCallback: delegatedCallbacks[targetEvent] });
      }
      delegatedCallbacks[targetEvent] = callback;

      if (disposable === true) {
        return new DelegationEntryHandler(handlerEntry, delegatedCallbacks, targetEvent);
      }

      return function () {
        handlerEntry.decrement();
        delegatedCallbacks[targetEvent] = null;
      };
    }
    if (strategy === delegationStrategy.capturing) {
      capturedHandlers = this.capturedHandlers;
      handlerEntry = capturedHandlers[targetEvent] || (capturedHandlers[targetEvent] = new CapturedHandlerEntry(targetEvent));
      let capturedCallbacks = target.capturedCallbacks || (target.capturedCallbacks = {});
      if (!capturedCallbacks[targetEvent]) {
        handlerEntry.increment();
      } else {
        emLogger.error('already have a callback for event', { event: targetEvent, callback: callback });
      }
      capturedCallbacks[targetEvent] = callback;

      if (disposable === true) {
        return new DelegationEntryHandler(handlerEntry, capturedCallbacks, targetEvent);
      }

      return function () {
        handlerEntry.decrement();
        capturedCallbacks[targetEvent] = null;
      };
    }

    target.addEventListener(targetEvent, callback);

    if (disposable === true) {
      return new EventHandler(target, targetEvent, callback);
    }

    return function () {
      target.removeEventListener(targetEvent, callback);
    };
  }
};


const delegationStrategy = {
  none: 0,
  capturing: 1,
  bubbling: 2
};

let EventManager = class EventManager {
  constructor(escapeShadowRoot = false) {
    this.elementHandlerLookup = {};
    this.eventStrategyLookup = {};
    this.escapeShadowRoot = escapeShadowRoot;

    this.registerElementConfig({
      tagName: 'input',
      properties: {
        value: ['change', 'input'],
        checked: ['change', 'input'],
        files: ['change', 'input']
      }
    });

    this.registerElementConfig({
      tagName: 'textarea',
      properties: {
        value: ['change', 'input']
      }
    });

    this.registerElementConfig({
      tagName: 'select',
      properties: {
        value: ['change']
      }
    });

    this.registerElementConfig({
      tagName: 'content editable',
      properties: {
        value: ['change', 'input', 'blur', 'keyup', 'paste']
      }
    });

    this.registerElementConfig({
      tagName: 'scrollable element',
      properties: {
        scrollTop: ['scroll'],
        scrollLeft: ['scroll']
      }
    });

    this.defaultEventStrategy = new DefaultEventStrategy(this);
  }

  registerElementConfig(config) {
    let tagName = config.tagName.toLowerCase();
    let properties = config.properties;
    let propertyName;

    let lookup = this.elementHandlerLookup[tagName] = {};

    for (propertyName in properties) {
      if (properties.hasOwnProperty(propertyName)) {
        lookup[propertyName] = properties[propertyName];
      }
    }
  }

  registerEventStrategy(eventName, strategy) {
    this.eventStrategyLookup[eventName] = strategy;
  }

  getElementHandler(target, propertyName) {
    let tagName;
    let lookup = this.elementHandlerLookup;

    if (target.tagName) {
      tagName = target.tagName.toLowerCase();

      if (lookup[tagName] && lookup[tagName][propertyName]) {
        return new EventSubscriber(lookup[tagName][propertyName]);
      }

      if (propertyName === 'textContent' || propertyName === 'innerHTML') {
        return new EventSubscriber(lookup['content editable'].value);
      }

      if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {
        return new EventSubscriber(lookup['scrollable element'][propertyName]);
      }
    }

    return null;
  }

  addEventListener(target, targetEvent, callbackOrListener, delegate, disposable) {
    return (this.eventStrategyLookup[targetEvent] || this.defaultEventStrategy).subscribe(target, targetEvent, callbackOrListener, delegate, disposable);
  }
};

let EventSubscriber = class EventSubscriber {
  constructor(events) {
    this.events = events;
    this.element = null;
    this.handler = null;
  }

  subscribe(element, callbackOrListener) {
    this.element = element;
    this.handler = callbackOrListener;

    let events = this.events;
    for (let i = 0, ii = events.length; ii > i; ++i) {
      element.addEventListener(events[i], callbackOrListener);
    }
  }

  dispose() {
    if (this.element === null) {
      return;
    }
    let element = this.element;
    let callbackOrListener = this.handler;
    let events = this.events;
    for (let i = 0, ii = events.length; ii > i; ++i) {
      element.removeEventListener(events[i], callbackOrListener);
    }
    this.element = this.handler = null;
  }
};

let DirtyChecker = class DirtyChecker {
  constructor() {
    this.tracked = [];
    this.checkDelay = 120;
  }

  addProperty(property) {
    let tracked = this.tracked;

    tracked.push(property);

    if (tracked.length === 1) {
      this.scheduleDirtyCheck();
    }
  }

  removeProperty(property) {
    let tracked = this.tracked;
    tracked.splice(tracked.indexOf(property), 1);
  }

  scheduleDirtyCheck() {
    setTimeout(() => this.check(), this.checkDelay);
  }

  check() {
    let tracked = this.tracked;
    let i = tracked.length;

    while (i--) {
      let current = tracked[i];

      if (current.isDirty()) {
        current.call();
      }
    }

    if (tracked.length) {
      this.scheduleDirtyCheck();
    }
  }
};

let DirtyCheckProperty = (_dec5 = subscriberCollection(), _dec5(_class5 = class DirtyCheckProperty {
  constructor(dirtyChecker, obj, propertyName) {
    this.dirtyChecker = dirtyChecker;
    this.obj = obj;
    this.propertyName = propertyName;
  }

  getValue() {
    return this.obj[this.propertyName];
  }

  setValue(newValue) {
    this.obj[this.propertyName] = newValue;
  }

  call() {
    let oldValue = this.oldValue;
    let newValue = this.getValue();

    this.callSubscribers(newValue, oldValue);

    this.oldValue = newValue;
  }

  isDirty() {
    return this.oldValue !== this.obj[this.propertyName];
  }

  subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.oldValue = this.getValue();
      this.dirtyChecker.addProperty(this);
    }
    this.addSubscriber(context, callable);
  }

  unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.dirtyChecker.removeProperty(this);
    }
  }
}) || _class5);

const logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('property-observation');

const propertyAccessor = {
  getValue: (obj, propertyName) => obj[propertyName],
  setValue: (value, obj, propertyName) => {
    obj[propertyName] = value;
  }
};

let PrimitiveObserver = class PrimitiveObserver {

  constructor(primitive, propertyName) {
    this.doNotCache = true;

    this.primitive = primitive;
    this.propertyName = propertyName;
  }

  getValue() {
    return this.primitive[this.propertyName];
  }

  setValue() {
    let type = typeof this.primitive;
    throw new Error(`The ${this.propertyName} property of a ${type} (${this.primitive}) cannot be assigned.`);
  }

  subscribe() {}

  unsubscribe() {}
};

let SetterObserver = (_dec6 = subscriberCollection(), _dec6(_class7 = class SetterObserver {
  constructor(taskQueue, obj, propertyName) {
    this.taskQueue = taskQueue;
    this.obj = obj;
    this.propertyName = propertyName;
    this.queued = false;
    this.observing = false;
  }

  getValue() {
    return this.obj[this.propertyName];
  }

  setValue(newValue) {
    this.obj[this.propertyName] = newValue;
  }

  getterValue() {
    return this.currentValue;
  }

  setterValue(newValue) {
    let oldValue = this.currentValue;

    if (oldValue !== newValue) {
      if (!this.queued) {
        this.oldValue = oldValue;
        this.queued = true;
        this.taskQueue.queueMicroTask(this);
      }

      this.currentValue = newValue;
    }
  }

  call() {
    let oldValue = this.oldValue;
    let newValue = this.oldValue = this.currentValue;

    this.queued = false;

    this.callSubscribers(newValue, oldValue);
  }

  subscribe(context, callable) {
    if (!this.observing) {
      this.convertProperty();
    }
    this.addSubscriber(context, callable);
  }

  unsubscribe(context, callable) {
    this.removeSubscriber(context, callable);
  }

  convertProperty() {
    this.observing = true;
    this.currentValue = this.obj[this.propertyName];
    this.setValue = this.setterValue;
    this.getValue = this.getterValue;

    if (!Reflect.defineProperty(this.obj, this.propertyName, {
      configurable: true,
      enumerable: this.propertyName in this.obj ? this.obj.propertyIsEnumerable(this.propertyName) : true,
      get: this.getValue.bind(this),
      set: this.setValue.bind(this)
    })) {
      logger.warn(`Cannot observe property '${this.propertyName}' of object`, this.obj);
    }
  }
}) || _class7);

let XLinkAttributeObserver = class XLinkAttributeObserver {
  constructor(element, propertyName, attributeName) {
    this.element = element;
    this.propertyName = propertyName;
    this.attributeName = attributeName;
  }

  getValue() {
    return this.element.getAttributeNS('http://www.w3.org/1999/xlink', this.attributeName);
  }

  setValue(newValue) {
    return this.element.setAttributeNS('http://www.w3.org/1999/xlink', this.attributeName, newValue);
  }

  subscribe() {
    throw new Error(`Observation of a "${this.element.nodeName}" element\'s "${this.propertyName}" property is not supported.`);
  }
};

const dataAttributeAccessor = {
  getValue: (obj, propertyName) => obj.getAttribute(propertyName),
  setValue: (value, obj, propertyName) => {
    if (value === null || value === undefined) {
      obj.removeAttribute(propertyName);
    } else {
      obj.setAttribute(propertyName, value);
    }
  }
};

let DataAttributeObserver = class DataAttributeObserver {
  constructor(element, propertyName) {
    this.element = element;
    this.propertyName = propertyName;
  }

  getValue() {
    return this.element.getAttribute(this.propertyName);
  }

  setValue(newValue) {
    if (newValue === null || newValue === undefined) {
      return this.element.removeAttribute(this.propertyName);
    }
    return this.element.setAttribute(this.propertyName, newValue);
  }

  subscribe() {
    throw new Error(`Observation of a "${this.element.nodeName}" element\'s "${this.propertyName}" property is not supported.`);
  }
};

let StyleObserver = class StyleObserver {
  constructor(element, propertyName) {
    this.element = element;
    this.propertyName = propertyName;

    this.styles = null;
    this.version = 0;
  }

  getValue() {
    return this.element.style.cssText;
  }

  _setProperty(style, value) {
    let priority = '';

    if (value !== null && value !== undefined && typeof value.indexOf === 'function' && value.indexOf('!important') !== -1) {
      priority = 'important';
      value = value.replace('!important', '');
    }
    this.element.style.setProperty(style, value, priority);
  }

  setValue(newValue) {
    let styles = this.styles || {};
    let style;
    let version = this.version;

    if (newValue !== null && newValue !== undefined) {
      if (newValue instanceof Object) {
        let value;
        for (style in newValue) {
          if (newValue.hasOwnProperty(style)) {
            value = newValue[style];
            style = style.replace(/([A-Z])/g, m => '-' + m.toLowerCase());
            styles[style] = version;
            this._setProperty(style, value);
          }
        }
      } else if (newValue.length) {
        let rx = /\s*([\w\-]+)\s*:\s*((?:(?:[\w\-]+\(\s*(?:"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[\w\-]+\(\s*(?:^"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^\)]*)\),?|[^\)]*)\),?|"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^;]*),?\s*)+);?/g;
        let pair;
        while ((pair = rx.exec(newValue)) !== null) {
          style = pair[1];
          if (!style) {
            continue;
          }

          styles[style] = version;
          this._setProperty(style, pair[2]);
        }
      }
    }

    this.styles = styles;
    this.version += 1;

    if (version === 0) {
      return;
    }

    version -= 1;
    for (style in styles) {
      if (!styles.hasOwnProperty(style) || styles[style] !== version) {
        continue;
      }

      this.element.style.removeProperty(style);
    }
  }

  subscribe() {
    throw new Error(`Observation of a "${this.element.nodeName}" element\'s "${this.propertyName}" property is not supported.`);
  }
};

let ValueAttributeObserver = (_dec7 = subscriberCollection(), _dec7(_class8 = class ValueAttributeObserver {
  constructor(element, propertyName, handler) {
    this.element = element;
    this.propertyName = propertyName;
    this.handler = handler;
    if (propertyName === 'files') {
      this.setValue = () => {};
    }
  }

  getValue() {
    return this.element[this.propertyName];
  }

  setValue(newValue) {
    newValue = newValue === undefined || newValue === null ? '' : newValue;
    if (this.element[this.propertyName] !== newValue) {
      this.element[this.propertyName] = newValue;
      this.notify();
    }
  }

  notify() {
    let oldValue = this.oldValue;
    let newValue = this.getValue();

    this.callSubscribers(newValue, oldValue);

    this.oldValue = newValue;
  }

  handleEvent() {
    this.notify();
  }

  subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.oldValue = this.getValue();
      this.handler.subscribe(this.element, this);
    }

    this.addSubscriber(context, callable);
  }

  unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  }
}) || _class8);

const checkedArrayContext = 'CheckedObserver:array';
const checkedValueContext = 'CheckedObserver:value';

let CheckedObserver = (_dec8 = subscriberCollection(), _dec8(_class9 = class CheckedObserver {
  constructor(element, handler, observerLocator) {
    this.element = element;
    this.handler = handler;
    this.observerLocator = observerLocator;
  }

  getValue() {
    return this.value;
  }

  setValue(newValue) {
    if (this.initialSync && this.value === newValue) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(checkedArrayContext, this);
      this.arrayObserver = null;
    }

    if (this.element.type === 'checkbox' && Array.isArray(newValue)) {
      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
      this.arrayObserver.subscribe(checkedArrayContext, this);
    }

    this.oldValue = this.value;
    this.value = newValue;
    this.synchronizeElement();
    this.notify();

    if (!this.initialSync) {
      this.initialSync = true;
      this.observerLocator.taskQueue.queueMicroTask(this);
    }
  }

  call(context, splices) {
    this.synchronizeElement();

    if (!this.valueObserver) {
      this.valueObserver = this.element.__observers__.model || this.element.__observers__.value;
      if (this.valueObserver) {
        this.valueObserver.subscribe(checkedValueContext, this);
      }
    }
  }

  synchronizeElement() {
    let value = this.value;
    let element = this.element;
    let elementValue = element.hasOwnProperty('model') ? element.model : element.value;
    let isRadio = element.type === 'radio';
    let matcher = element.matcher || ((a, b) => a === b);

    element.checked = isRadio && !!matcher(value, elementValue) || !isRadio && value === true || !isRadio && Array.isArray(value) && value.findIndex(item => !!matcher(item, elementValue)) !== -1;
  }

  synchronizeValue() {
    let value = this.value;
    let element = this.element;
    let elementValue = element.hasOwnProperty('model') ? element.model : element.value;
    let index;
    let matcher = element.matcher || ((a, b) => a === b);

    if (element.type === 'checkbox') {
      if (Array.isArray(value)) {
        index = value.findIndex(item => !!matcher(item, elementValue));
        if (element.checked && index === -1) {
          value.push(elementValue);
        } else if (!element.checked && index !== -1) {
          value.splice(index, 1);
        }

        return;
      }

      value = element.checked;
    } else if (element.checked) {
      value = elementValue;
    } else {
      return;
    }

    this.oldValue = this.value;
    this.value = value;
    this.notify();
  }

  notify() {
    let oldValue = this.oldValue;
    let newValue = this.value;

    if (newValue === oldValue) {
      return;
    }

    this.callSubscribers(newValue, oldValue);
  }

  handleEvent() {
    this.synchronizeValue();
  }

  subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.handler.subscribe(this.element, this);
    }
    this.addSubscriber(context, callable);
  }

  unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  }

  unbind() {
    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(checkedArrayContext, this);
      this.arrayObserver = null;
    }
    if (this.valueObserver) {
      this.valueObserver.unsubscribe(checkedValueContext, this);
    }
  }
}) || _class9);

const selectArrayContext = 'SelectValueObserver:array';

let SelectValueObserver = (_dec9 = subscriberCollection(), _dec9(_class10 = class SelectValueObserver {
  constructor(element, handler, observerLocator) {
    this.element = element;
    this.handler = handler;
    this.observerLocator = observerLocator;
  }

  getValue() {
    return this.value;
  }

  setValue(newValue) {
    if (newValue !== null && newValue !== undefined && this.element.multiple && !Array.isArray(newValue)) {
      throw new Error('Only null or Array instances can be bound to a multi-select.');
    }
    if (this.value === newValue) {
      return;
    }

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(selectArrayContext, this);
      this.arrayObserver = null;
    }

    if (Array.isArray(newValue)) {
      this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
      this.arrayObserver.subscribe(selectArrayContext, this);
    }

    this.oldValue = this.value;
    this.value = newValue;
    this.synchronizeOptions();
    this.notify();

    if (!this.initialSync) {
      this.initialSync = true;
      this.observerLocator.taskQueue.queueMicroTask(this);
    }
  }

  call(context, splices) {
    this.synchronizeOptions();
  }

  synchronizeOptions() {
    let value = this.value;
    let isArray;

    if (Array.isArray(value)) {
      isArray = true;
    }

    let options = this.element.options;
    let i = options.length;
    let matcher = this.element.matcher || ((a, b) => a === b);
    while (i--) {
      let option = options.item(i);
      let optionValue = option.hasOwnProperty('model') ? option.model : option.value;
      if (isArray) {
        option.selected = value.findIndex(item => !!matcher(optionValue, item)) !== -1;
        continue;
      }
      option.selected = !!matcher(optionValue, value);
    }
  }

  synchronizeValue() {
    let options = this.element.options;
    let count = 0;
    let value = [];

    for (let i = 0, ii = options.length; i < ii; i++) {
      let option = options.item(i);
      if (!option.selected) {
        continue;
      }
      value.push(option.hasOwnProperty('model') ? option.model : option.value);
      count++;
    }

    if (this.element.multiple) {
      if (Array.isArray(this.value)) {
        let matcher = this.element.matcher || ((a, b) => a === b);

        let i = 0;
        while (i < this.value.length) {
          let a = this.value[i];
          if (value.findIndex(b => matcher(a, b)) === -1) {
            this.value.splice(i, 1);
          } else {
            i++;
          }
        }

        i = 0;
        while (i < value.length) {
          let a = value[i];
          if (this.value.findIndex(b => matcher(a, b)) === -1) {
            this.value.push(a);
          }
          i++;
        }
        return;
      }
    } else {
      if (count === 0) {
        value = null;
      } else {
        value = value[0];
      }
    }

    if (value !== this.value) {
      this.oldValue = this.value;
      this.value = value;
      this.notify();
    }
  }

  notify() {
    let oldValue = this.oldValue;
    let newValue = this.value;

    this.callSubscribers(newValue, oldValue);
  }

  handleEvent() {
    this.synchronizeValue();
  }

  subscribe(context, callable) {
    if (!this.hasSubscribers()) {
      this.handler.subscribe(this.element, this);
    }
    this.addSubscriber(context, callable);
  }

  unsubscribe(context, callable) {
    if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
      this.handler.dispose();
    }
  }

  bind() {
    this.domObserver = aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.createMutationObserver(() => {
      this.synchronizeOptions();
      this.synchronizeValue();
    });
    this.domObserver.observe(this.element, { childList: true, subtree: true, characterData: true });
  }

  unbind() {
    this.domObserver.disconnect();
    this.domObserver = null;

    if (this.arrayObserver) {
      this.arrayObserver.unsubscribe(selectArrayContext, this);
      this.arrayObserver = null;
    }
  }
}) || _class10);

let ClassObserver = class ClassObserver {
  constructor(element) {
    this.element = element;
    this.doNotCache = true;
    this.value = '';
    this.version = 0;
  }

  getValue() {
    return this.value;
  }

  setValue(newValue) {
    let nameIndex = this.nameIndex || {};
    let version = this.version;
    let names;
    let name;

    if (newValue !== null && newValue !== undefined && newValue.length) {
      names = newValue.split(/\s+/);
      for (let i = 0, length = names.length; i < length; i++) {
        name = names[i];
        if (name === '') {
          continue;
        }
        nameIndex[name] = version;
        this.element.classList.add(name);
      }
    }

    this.value = newValue;
    this.nameIndex = nameIndex;
    this.version += 1;

    if (version === 0) {
      return;
    }

    version -= 1;
    for (name in nameIndex) {
      if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {
        continue;
      }
      this.element.classList.remove(name);
    }
  }

  subscribe() {
    throw new Error(`Observation of a "${this.element.nodeName}" element\'s "class" property is not supported.`);
  }
};

function hasDeclaredDependencies(descriptor) {
  return !!(descriptor && descriptor.get && descriptor.get.dependencies);
}

function declarePropertyDependencies(ctor, propertyName, dependencies) {
  let descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, propertyName);
  descriptor.get.dependencies = dependencies;
}

function computedFrom(...rest) {
  return function (target, key, descriptor) {
    descriptor.get.dependencies = rest;
    return descriptor;
  };
}

let ComputedExpression = class ComputedExpression extends Expression {
  constructor(name, dependencies) {
    super();

    this.name = name;
    this.dependencies = dependencies;
    this.isAssignable = true;
  }

  evaluate(scope, lookupFunctions) {
    return scope.bindingContext[this.name];
  }

  assign(scope, value) {
    scope.bindingContext[this.name] = value;
  }

  accept(visitor) {
    throw new Error('not implemented');
  }

  connect(binding, scope) {
    let dependencies = this.dependencies;
    let i = dependencies.length;
    while (i--) {
      dependencies[i].connect(binding, scope);
    }
  }
};

function createComputedObserver(obj, propertyName, descriptor, observerLocator) {
  let dependencies = descriptor.get.dependencies;
  if (!(dependencies instanceof ComputedExpression)) {
    let i = dependencies.length;
    while (i--) {
      dependencies[i] = observerLocator.parser.parse(dependencies[i]);
    }
    dependencies = descriptor.get.dependencies = new ComputedExpression(propertyName, dependencies);
  }

  let scope = { bindingContext: obj, overrideContext: createOverrideContext(obj) };
  return new ExpressionObserver(scope, dependencies, observerLocator);
}

let svgElements;
let svgPresentationElements;
let svgPresentationAttributes;
let svgAnalyzer;

if (typeof FEATURE_NO_SVG === 'undefined') {
  svgElements = {
    a: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyph: ['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    altGlyphDef: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyphItem: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    animate: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateColor: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateMotion: ['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateTransform: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    circle: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    clipPath: ['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    'color-profile': ['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    cursor: ['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    defs: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    desc: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    ellipse: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    feBlend: ['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feColorMatrix: ['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComponentTransfer: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComposite: ['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feConvolveMatrix: ['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDiffuseLighting: ['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDisplacementMap: ['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector'],
    feDistantLight: ['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space'],
    feFlood: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feFuncA: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncB: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncG: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncR: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feGaussianBlur: ['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feImage: ['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMerge: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMergeNode: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    feMorphology: ['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feOffset: ['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    fePointLight: ['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feSpecularLighting: ['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feSpotLight: ['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feTile: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feTurbulence: ['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    filter: ['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    font: ['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face': ['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-format': ['id', 'string', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-name': ['id', 'name', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-src': ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-uri': ['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    foreignObject: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    g: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    glyph: ['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    glyphRef: ['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    hkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space'],
    image: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    line: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    linearGradient: ['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    marker: ['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    mask: ['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    metadata: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'missing-glyph': ['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    mpath: ['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    path: ['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    pattern: ['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    polygon: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    polyline: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    radialGradient: ['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    rect: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    script: ['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    set: ['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    stop: ['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    style: ['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    svg: ['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan'],
    switch: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    symbol: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    text: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    textPath: ['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    title: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    tref: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    tspan: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    use: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    view: ['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan'],
    vkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']
  };


  svgPresentationElements = {
    'a': true,
    'altGlyph': true,
    'animate': true,
    'animateColor': true,
    'circle': true,
    'clipPath': true,
    'defs': true,
    'ellipse': true,
    'feBlend': true,
    'feColorMatrix': true,
    'feComponentTransfer': true,
    'feComposite': true,
    'feConvolveMatrix': true,
    'feDiffuseLighting': true,
    'feDisplacementMap': true,
    'feFlood': true,
    'feGaussianBlur': true,
    'feImage': true,
    'feMerge': true,
    'feMorphology': true,
    'feOffset': true,
    'feSpecularLighting': true,
    'feTile': true,
    'feTurbulence': true,
    'filter': true,
    'font': true,
    'foreignObject': true,
    'g': true,
    'glyph': true,
    'glyphRef': true,
    'image': true,
    'line': true,
    'linearGradient': true,
    'marker': true,
    'mask': true,
    'missing-glyph': true,
    'path': true,
    'pattern': true,
    'polygon': true,
    'polyline': true,
    'radialGradient': true,
    'rect': true,
    'stop': true,
    'svg': true,
    'switch': true,
    'symbol': true,
    'text': true,
    'textPath': true,
    'tref': true,
    'tspan': true,
    'use': true
  };

  svgPresentationAttributes = {
    'alignment-baseline': true,
    'baseline-shift': true,
    'clip-path': true,
    'clip-rule': true,
    'clip': true,
    'color-interpolation-filters': true,
    'color-interpolation': true,
    'color-profile': true,
    'color-rendering': true,
    'color': true,
    'cursor': true,
    'direction': true,
    'display': true,
    'dominant-baseline': true,
    'enable-background': true,
    'fill-opacity': true,
    'fill-rule': true,
    'fill': true,
    'filter': true,
    'flood-color': true,
    'flood-opacity': true,
    'font-family': true,
    'font-size-adjust': true,
    'font-size': true,
    'font-stretch': true,
    'font-style': true,
    'font-variant': true,
    'font-weight': true,
    'glyph-orientation-horizontal': true,
    'glyph-orientation-vertical': true,
    'image-rendering': true,
    'kerning': true,
    'letter-spacing': true,
    'lighting-color': true,
    'marker-end': true,
    'marker-mid': true,
    'marker-start': true,
    'mask': true,
    'opacity': true,
    'overflow': true,
    'pointer-events': true,
    'shape-rendering': true,
    'stop-color': true,
    'stop-opacity': true,
    'stroke-dasharray': true,
    'stroke-dashoffset': true,
    'stroke-linecap': true,
    'stroke-linejoin': true,
    'stroke-miterlimit': true,
    'stroke-opacity': true,
    'stroke-width': true,
    'stroke': true,
    'text-anchor': true,
    'text-decoration': true,
    'text-rendering': true,
    'unicode-bidi': true,
    'visibility': true,
    'word-spacing': true,
    'writing-mode': true
  };

  let createElement = function (html) {
    let div = aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.createElement('div');
    div.innerHTML = html;
    return div.firstChild;
  };

  svgAnalyzer = class SVGAnalyzer {
    constructor() {
      if (createElement('<svg><altGlyph /></svg>').firstElementChild.nodeName === 'altglyph' && elements.altGlyph) {
        elements.altglyph = elements.altGlyph;
        delete elements.altGlyph;
        elements.altglyphdef = elements.altGlyphDef;
        delete elements.altGlyphDef;
        elements.altglyphitem = elements.altGlyphItem;
        delete elements.altGlyphItem;
        elements.glyphref = elements.glyphRef;
        delete elements.glyphRef;
      }
    }

    isStandardSvgAttribute(nodeName, attributeName) {
      return presentationElements[nodeName] && presentationAttributes[attributeName] || elements[nodeName] && elements[nodeName].indexOf(attributeName) !== -1;
    }
  };
}

const elements = svgElements;
const presentationElements = svgPresentationElements;
const presentationAttributes = svgPresentationAttributes;
const SVGAnalyzer = svgAnalyzer || class {
  isStandardSvgAttribute() {
    return false;
  }
};

let ObserverLocator = (_temp = _class11 = class ObserverLocator {
  constructor(taskQueue, eventManager, dirtyChecker, svgAnalyzer, parser) {
    this.taskQueue = taskQueue;
    this.eventManager = eventManager;
    this.dirtyChecker = dirtyChecker;
    this.svgAnalyzer = svgAnalyzer;
    this.parser = parser;

    this.adapters = [];
    this.logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('observer-locator');
  }

  getObserver(obj, propertyName) {
    let observersLookup = obj.__observers__;
    let observer;

    if (observersLookup && propertyName in observersLookup) {
      return observersLookup[propertyName];
    }

    observer = this.createPropertyObserver(obj, propertyName);

    if (!observer.doNotCache) {
      if (observersLookup === undefined) {
        observersLookup = this.getOrCreateObserversLookup(obj);
      }

      observersLookup[propertyName] = observer;
    }

    return observer;
  }

  getOrCreateObserversLookup(obj) {
    return obj.__observers__ || this.createObserversLookup(obj);
  }

  createObserversLookup(obj) {
    let value = {};

    if (!Reflect.defineProperty(obj, '__observers__', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: value
    })) {
      this.logger.warn('Cannot add observers to object', obj);
    }

    return value;
  }

  addAdapter(adapter) {
    this.adapters.push(adapter);
  }

  getAdapterObserver(obj, propertyName, descriptor) {
    for (let i = 0, ii = this.adapters.length; i < ii; i++) {
      let adapter = this.adapters[i];
      let observer = adapter.getObserver(obj, propertyName, descriptor);
      if (observer) {
        return observer;
      }
    }
    return null;
  }

  createPropertyObserver(obj, propertyName) {
    let descriptor;
    let handler;
    let xlinkResult;

    if (!(obj instanceof Object)) {
      return new PrimitiveObserver(obj, propertyName);
    }

    if (obj instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.Element) {
      if (propertyName === 'class') {
        return new ClassObserver(obj);
      }
      if (propertyName === 'style' || propertyName === 'css') {
        return new StyleObserver(obj, propertyName);
      }
      handler = this.eventManager.getElementHandler(obj, propertyName);
      if (propertyName === 'value' && obj.tagName.toLowerCase() === 'select') {
        return new SelectValueObserver(obj, handler, this);
      }
      if (propertyName === 'checked' && obj.tagName.toLowerCase() === 'input') {
        return new CheckedObserver(obj, handler, this);
      }
      if (handler) {
        return new ValueAttributeObserver(obj, propertyName, handler);
      }
      xlinkResult = /^xlink:(.+)$/.exec(propertyName);
      if (xlinkResult) {
        return new XLinkAttributeObserver(obj, propertyName, xlinkResult[1]);
      }
      if (propertyName === 'role' && (obj instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.Element || obj instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.SVGElement) || /^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
        return new DataAttributeObserver(obj, propertyName);
      }
    }

    descriptor = Object.getPropertyDescriptor(obj, propertyName);

    if (hasDeclaredDependencies(descriptor)) {
      return createComputedObserver(obj, propertyName, descriptor, this);
    }

    if (descriptor) {
      const existingGetterOrSetter = descriptor.get || descriptor.set;
      if (existingGetterOrSetter) {
        if (existingGetterOrSetter.getObserver) {
          return existingGetterOrSetter.getObserver(obj);
        }

        let adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);
        if (adapterObserver) {
          return adapterObserver;
        }
        return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
      }
    }

    if (obj instanceof Array) {
      if (propertyName === 'length') {
        return this.getArrayObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    } else if (obj instanceof Map) {
      if (propertyName === 'size') {
        return this.getMapObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    } else if (obj instanceof Set) {
      if (propertyName === 'size') {
        return this.getSetObserver(obj).getLengthObserver();
      }

      return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
    }

    return new SetterObserver(this.taskQueue, obj, propertyName);
  }

  getAccessor(obj, propertyName) {
    if (obj instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.Element) {
      if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css' || propertyName === 'value' && (obj.tagName.toLowerCase() === 'input' || obj.tagName.toLowerCase() === 'select') || propertyName === 'checked' && obj.tagName.toLowerCase() === 'input' || propertyName === 'model' && obj.tagName.toLowerCase() === 'input' || /^xlink:.+$/.exec(propertyName)) {
        return this.getObserver(obj, propertyName);
      }
      if (/^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName) || obj.tagName.toLowerCase() === 'img' && propertyName === 'src' || obj.tagName.toLowerCase() === 'a' && propertyName === 'href') {
        return dataAttributeAccessor;
      }
    }
    return propertyAccessor;
  }

  getArrayObserver(array) {
    return getArrayObserver(this.taskQueue, array);
  }

  getMapObserver(map) {
    return getMapObserver(this.taskQueue, map);
  }

  getSetObserver(set) {
    return getSetObserver(this.taskQueue, set);
  }
}, _class11.inject = [aurelia_task_queue__WEBPACK_IMPORTED_MODULE_2__.TaskQueue, EventManager, DirtyChecker, SVGAnalyzer, Parser], _temp);

let ObjectObservationAdapter = class ObjectObservationAdapter {
  getObserver(object, propertyName, descriptor) {
    throw new Error('BindingAdapters must implement getObserver(object, propertyName).');
  }
};

let BindingExpression = class BindingExpression {
  constructor(observerLocator, targetProperty, sourceExpression, mode, lookupFunctions, attribute) {
    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.sourceExpression = sourceExpression;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
    this.attribute = attribute;
    this.discrete = false;
  }

  createBinding(target) {
    return new Binding(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.mode, this.lookupFunctions);
  }
};

let Binding = (_dec10 = connectable(), _dec10(_class12 = class Binding {
  constructor(observerLocator, sourceExpression, target, targetProperty, mode, lookupFunctions) {
    this.observerLocator = observerLocator;
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.lookupFunctions = lookupFunctions;
  }

  updateTarget(value) {
    this.targetObserver.setValue(value, this.target, this.targetProperty);
  }

  updateSource(value) {
    this.sourceExpression.assign(this.source, value, this.lookupFunctions);
  }

  call(context, newValue, oldValue) {
    if (!this.isBound) {
      return;
    }
    if (context === sourceContext) {
      oldValue = this.targetObserver.getValue(this.target, this.targetProperty);
      newValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      if (newValue !== oldValue) {
        this.updateTarget(newValue);
      }
      if (this.mode !== bindingMode.oneTime) {
        this._version++;
        this.sourceExpression.connect(this, this.source);
        this.unobserve(false);
      }
      return;
    }
    if (context === targetContext) {
      if (newValue !== this.sourceExpression.evaluate(this.source, this.lookupFunctions)) {
        this.updateSource(newValue);
      }
      return;
    }
    throw new Error(`Unexpected call context ${context}`);
  }

  bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }

    let mode = this.mode;
    if (!this.targetObserver) {
      let method = mode === bindingMode.twoWay || mode === bindingMode.fromView ? 'getObserver' : 'getAccessor';
      this.targetObserver = this.observerLocator[method](this.target, this.targetProperty);
    }

    if ('bind' in this.targetObserver) {
      this.targetObserver.bind();
    }
    if (this.mode !== bindingMode.fromView) {
      let value = this.sourceExpression.evaluate(source, this.lookupFunctions);
      this.updateTarget(value);
    }

    if (mode === bindingMode.oneTime) {
      return;
    } else if (mode === bindingMode.toView) {
      enqueueBindingConnect(this);
    } else if (mode === bindingMode.twoWay) {
      this.sourceExpression.connect(this, source);
      this.targetObserver.subscribe(targetContext, this);
    } else if (mode === bindingMode.fromView) {
      this.targetObserver.subscribe(targetContext, this);
    }
  }

  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    if ('unbind' in this.targetObserver) {
      this.targetObserver.unbind();
    }
    if (this.targetObserver.unsubscribe) {
      this.targetObserver.unsubscribe(targetContext, this);
    }
    this.unobserve(true);
  }

  connect(evaluate) {
    if (!this.isBound) {
      return;
    }
    if (evaluate) {
      let value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      this.updateTarget(value);
    }
    this.sourceExpression.connect(this, this.source);
  }
}) || _class12);

let CallExpression = class CallExpression {
  constructor(observerLocator, targetProperty, sourceExpression, lookupFunctions) {
    this.observerLocator = observerLocator;
    this.targetProperty = targetProperty;
    this.sourceExpression = sourceExpression;
    this.lookupFunctions = lookupFunctions;
  }

  createBinding(target) {
    return new Call(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.lookupFunctions);
  }
};

let Call = class Call {
  constructor(observerLocator, sourceExpression, target, targetProperty, lookupFunctions) {
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.targetProperty = observerLocator.getObserver(target, targetProperty);
    this.lookupFunctions = lookupFunctions;
  }

  callSource($event) {
    let overrideContext = this.source.overrideContext;
    Object.assign(overrideContext, $event);
    overrideContext.$event = $event;
    let mustEvaluate = true;
    let result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
    delete overrideContext.$event;
    for (let prop in $event) {
      delete overrideContext[prop];
    }
    return result;
  }

  bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this.targetProperty.setValue($event => this.callSource($event));
  }

  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this.targetProperty.setValue(null);
  }
};

let ValueConverterResource = class ValueConverterResource {
  constructor(name) {
    this.name = name;
  }

  static convention(name) {
    if (name.endsWith('ValueConverter')) {
      return new ValueConverterResource(camelCase(name.substring(0, name.length - 14)));
    }
  }

  initialize(container, target) {
    this.instance = container.get(target);
  }

  register(registry, name) {
    registry.registerValueConverter(name || this.name, this.instance);
  }

  load(container, target) {}
};

function valueConverter(nameOrTarget) {
  if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
    return function (target) {
      aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.resource, new ValueConverterResource(nameOrTarget), target);
    };
  }

  aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.resource, new ValueConverterResource(), nameOrTarget);
}

let BindingBehaviorResource = class BindingBehaviorResource {
  constructor(name) {
    this.name = name;
  }

  static convention(name) {
    if (name.endsWith('BindingBehavior')) {
      return new BindingBehaviorResource(camelCase(name.substring(0, name.length - 15)));
    }
  }

  initialize(container, target) {
    this.instance = container.get(target);
  }

  register(registry, name) {
    registry.registerBindingBehavior(name || this.name, this.instance);
  }

  load(container, target) {}
};

function bindingBehavior(nameOrTarget) {
  if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
    return function (target) {
      aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.resource, new BindingBehaviorResource(nameOrTarget), target);
    };
  }

  aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_3__.metadata.resource, new BindingBehaviorResource(), nameOrTarget);
}

let ListenerExpression = class ListenerExpression {
  constructor(eventManager, targetEvent, sourceExpression, delegationStrategy, preventDefault, lookupFunctions) {
    this.eventManager = eventManager;
    this.targetEvent = targetEvent;
    this.sourceExpression = sourceExpression;
    this.delegationStrategy = delegationStrategy;
    this.discrete = true;
    this.preventDefault = preventDefault;
    this.lookupFunctions = lookupFunctions;
  }

  createBinding(target) {
    return new Listener(this.eventManager, this.targetEvent, this.delegationStrategy, this.sourceExpression, target, this.preventDefault, this.lookupFunctions);
  }
};

let Listener = class Listener {
  constructor(eventManager, targetEvent, delegationStrategy, sourceExpression, target, preventDefault, lookupFunctions) {
    this.eventManager = eventManager;
    this.targetEvent = targetEvent;
    this.delegationStrategy = delegationStrategy;
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.preventDefault = preventDefault;
    this.lookupFunctions = lookupFunctions;
  }

  callSource(event) {
    let overrideContext = this.source.overrideContext;
    overrideContext.$event = event;
    let mustEvaluate = true;
    let result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
    delete overrideContext.$event;
    if (result !== true && this.preventDefault) {
      event.preventDefault();
    }
    return result;
  }

  handleEvent(event) {
    this.callSource(event);
  }

  bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;

    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this._handler = this.eventManager.addEventListener(this.target, this.targetEvent, this, this.delegationStrategy, true);
  }

  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
    this._handler.dispose();
    this._handler = null;
  }
};

function getAU(element) {
  let au = element.au;

  if (au === undefined) {
    throw new Error(`No Aurelia APIs are defined for the element: "${element.tagName}".`);
  }

  return au;
}

let NameExpression = class NameExpression {
  constructor(sourceExpression, apiName, lookupFunctions) {
    this.sourceExpression = sourceExpression;
    this.apiName = apiName;
    this.lookupFunctions = lookupFunctions;
    this.discrete = true;
  }

  createBinding(target) {
    return new NameBinder(this.sourceExpression, NameExpression.locateAPI(target, this.apiName), this.lookupFunctions);
  }

  static locateAPI(element, apiName) {
    switch (apiName) {
      case 'element':
        return element;
      case 'controller':
        return getAU(element).controller;
      case 'view-model':
        return getAU(element).controller.viewModel;
      case 'view':
        return getAU(element).controller.view;
      default:
        let target = getAU(element)[apiName];

        if (target === undefined) {
          throw new Error(`Attempted to reference "${apiName}", but it was not found amongst the target's API.`);
        }

        return target.viewModel;
    }
  }
};

let NameBinder = class NameBinder {
  constructor(sourceExpression, target, lookupFunctions) {
    this.sourceExpression = sourceExpression;
    this.target = target;
    this.lookupFunctions = lookupFunctions;
  }

  bind(source) {
    if (this.isBound) {
      if (this.source === source) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this.source = source;
    if (this.sourceExpression.bind) {
      this.sourceExpression.bind(this, source, this.lookupFunctions);
    }
    this.sourceExpression.assign(this.source, this.target, this.lookupFunctions);
  }

  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (this.sourceExpression.evaluate(this.source, this.lookupFunctions) === this.target) {
      this.sourceExpression.assign(this.source, null, this.lookupFunctions);
    }
    if (this.sourceExpression.unbind) {
      this.sourceExpression.unbind(this, this.source);
    }
    this.source = null;
  }
};


const LookupFunctions = {
  bindingBehaviors: name => null,
  valueConverters: name => null
};

let BindingEngine = (_temp2 = _class13 = class BindingEngine {

  constructor(observerLocator, parser) {
    this.observerLocator = observerLocator;
    this.parser = parser;
  }

  createBindingExpression(targetProperty, sourceExpression, mode = bindingMode.toView, lookupFunctions = LookupFunctions) {
    return new BindingExpression(this.observerLocator, targetProperty, this.parser.parse(sourceExpression), mode, lookupFunctions);
  }

  propertyObserver(obj, propertyName) {
    return {
      subscribe: callback => {
        let observer = this.observerLocator.getObserver(obj, propertyName);
        observer.subscribe(callback);
        return {
          dispose: () => observer.unsubscribe(callback)
        };
      }
    };
  }

  collectionObserver(collection) {
    return {
      subscribe: callback => {
        let observer;
        if (collection instanceof Array) {
          observer = this.observerLocator.getArrayObserver(collection);
        } else if (collection instanceof Map) {
          observer = this.observerLocator.getMapObserver(collection);
        } else if (collection instanceof Set) {
          observer = this.observerLocator.getSetObserver(collection);
        } else {
          throw new Error('collection must be an instance of Array, Map or Set.');
        }
        observer.subscribe(callback);
        return {
          dispose: () => observer.unsubscribe(callback)
        };
      }
    };
  }

  expressionObserver(bindingContext, expression) {
    let scope = { bindingContext, overrideContext: createOverrideContext(bindingContext) };
    return new ExpressionObserver(scope, this.parser.parse(expression), this.observerLocator, LookupFunctions);
  }

  parseExpression(expression) {
    return this.parser.parse(expression);
  }

  registerAdapter(adapter) {
    this.observerLocator.addAdapter(adapter);
  }
}, _class13.inject = [ObserverLocator, Parser], _temp2);

let setProto = Set.prototype;

function getSetObserver(taskQueue, set) {
  return ModifySetObserver.for(taskQueue, set);
}

let ModifySetObserver = class ModifySetObserver extends ModifyCollectionObserver {
  constructor(taskQueue, set) {
    super(taskQueue, set);
  }

  static for(taskQueue, set) {
    if (!('__set_observer__' in set)) {
      Reflect.defineProperty(set, '__set_observer__', {
        value: ModifySetObserver.create(taskQueue, set),
        enumerable: false, configurable: false
      });
    }
    return set.__set_observer__;
  }

  static create(taskQueue, set) {
    let observer = new ModifySetObserver(taskQueue, set);

    let proto = setProto;
    if (proto.add !== set.add || proto.delete !== set.delete || proto.clear !== set.clear) {
      proto = {
        add: set.add,
        delete: set.delete,
        clear: set.clear
      };
    }

    set.add = function () {
      let type = 'add';
      let oldSize = set.size;
      let methodCallResult = proto.add.apply(set, arguments);
      let hasValue = set.size === oldSize;
      if (!hasValue) {
        observer.addChangeRecord({
          type: type,
          object: set,
          value: Array.from(set).pop()
        });
      }
      return methodCallResult;
    };

    set.delete = function () {
      let hasValue = set.has(arguments[0]);
      let methodCallResult = proto.delete.apply(set, arguments);
      if (hasValue) {
        observer.addChangeRecord({
          type: 'delete',
          object: set,
          value: arguments[0]
        });
      }
      return methodCallResult;
    };

    set.clear = function () {
      let methodCallResult = proto.clear.apply(set, arguments);
      observer.addChangeRecord({
        type: 'clear',
        object: set
      });
      return methodCallResult;
    };

    return observer;
  }
};


function observable(targetOrConfig, key, descriptor) {
  function deco(target, key, descriptor, config) {
    const isClassDecorator = key === undefined;
    if (isClassDecorator) {
      target = target.prototype;
      key = typeof config === 'string' ? config : config.name;
    }

    let innerPropertyName = `_${key}`;
    const innerPropertyDescriptor = {
      configurable: true,
      enumerable: false,
      writable: true
    };

    const callbackName = config && config.changeHandler || `${key}Changed`;

    if (descriptor) {
      if (typeof descriptor.initializer === 'function') {
        innerPropertyDescriptor.value = descriptor.initializer();
      }
    } else {
      descriptor = {};
    }

    if (!('enumerable' in descriptor)) {
      descriptor.enumerable = true;
    }

    delete descriptor.value;
    delete descriptor.writable;
    delete descriptor.initializer;

    Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);

    descriptor.get = function () {
      return this[innerPropertyName];
    };
    descriptor.set = function (newValue) {
      let oldValue = this[innerPropertyName];
      if (newValue === oldValue) {
        return;
      }

      this[innerPropertyName] = newValue;
      Reflect.defineProperty(this, innerPropertyName, { enumerable: false });

      if (this[callbackName]) {
        this[callbackName](newValue, oldValue, key);
      }
    };

    descriptor.get.dependencies = [innerPropertyName];

    if (isClassDecorator) {
      Reflect.defineProperty(target, key, descriptor);
    } else {
      return descriptor;
    }
  }

  if (key === undefined) {
    return (t, k, d) => deco(t, k, d, targetOrConfig);
  }
  return deco(targetOrConfig, key, descriptor);
}

const signals = {};

function connectBindingToSignal(binding, name) {
  if (!signals.hasOwnProperty(name)) {
    signals[name] = 0;
  }
  binding.observeProperty(signals, name);
}

function signalBindings(name) {
  if (signals.hasOwnProperty(name)) {
    signals[name]++;
  }
}

/***/ }),

/***/ "../../node_modules/aurelia-bootstrapper/dist/es2015/aurelia-bootstrapper.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/aurelia-bootstrapper/dist/es2015/aurelia-bootstrapper.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bootstrap: () => (/* binding */ bootstrap),
/* harmony export */   starting: () => (/* binding */ starting)
/* harmony export */ });
/* harmony import */ var aurelia_polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-polyfills */ "../../node_modules/aurelia-polyfills/dist/es2015/aurelia-polyfills.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");



let bootstrapPromises = [];
let startResolve;
const startPromise = new Promise(resolve => startResolve = resolve);
const host = aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.global;
const isNodeLike = typeof process !== 'undefined' && !process.browser && process.version;
function ready() {
    if (!host.document || host.document.readyState === 'complete') {
        return Promise.resolve();
    }
    return new Promise(resolve => {
        host.document.addEventListener('DOMContentLoaded', completed);
        host.addEventListener('load', completed);
        function completed() {
            host.document.removeEventListener('DOMContentLoaded', completed);
            host.removeEventListener('load', completed);
            resolve();
        }
    });
}
function createLoader() {
    if (aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.Loader) {
        return Promise.resolve(new aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.Loader());
    }
    if (false) {}
    return Promise.reject('No PLATFORM.Loader is defined and there is neither a System API (ES6) or a Require API (AMD) globally available to load your app.');
}
function initializePal(loader) {
    if (aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.isInitialized)
        return Promise.resolve();
    let type;
    const isRenderer = isNodeLike && (process.type === 'renderer' || process.versions['node-webkit']);
    if (isNodeLike && !isRenderer) {
        type = 'nodejs';
    }
    else if (typeof window !== 'undefined') {
        type = 'browser';
    }
    else if (typeof self !== 'undefined') {
        type = 'worker';
    }
    else {
        throw new Error('Could not determine platform implementation to load.');
    }
    return loader.loadModule('aurelia-pal-' + type)
        .then(palModule => type === 'nodejs' && !aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.isInitialized && palModule.globalize() || palModule.initialize());
}
function preparePlatform(loader) {
    const map = (moduleId, relativeTo) => loader.normalize(moduleId, relativeTo)
        .then(normalized => {
        loader.map(moduleId, normalized);
        return normalized;
    });
    return initializePal(loader)
        .then(() => loader.normalize('aurelia-bootstrapper'))
        .then(bootstrapperName => {
        const frameworkPromise = map('aurelia-framework', bootstrapperName);
        return Promise.all([
            frameworkPromise,
            frameworkPromise.then(frameworkName => map('aurelia-dependency-injection', frameworkName)),
            map('aurelia-router', bootstrapperName),
            map('aurelia-logging-console', bootstrapperName)
        ]);
    })
        .then(([frameworkName]) => loader.loadModule(frameworkName))
        .then((fx) => startResolve(() => new fx.Aurelia(loader)));
}
function config(appHost, configModuleId, aurelia) {
    aurelia.host = appHost;
    aurelia.configModuleId = configModuleId || null;
    if (configModuleId) {
        return aurelia.loader
            .loadModule(configModuleId)
            .then(customConfig => {
            if (!customConfig.configure) {
                throw new Error(`Cannot initialize module '${configModuleId}' without a configure function.`);
            }
            return customConfig.configure(aurelia);
        });
    }
    aurelia.use
        .standardConfiguration()
        .developmentLogging();
    return aurelia.start().then(() => aurelia.setRoot());
}
function run() {
    return ready()
        .then(createLoader)
        .then(preparePlatform)
        .then(() => {
        const appHosts = host.document.querySelectorAll('[aurelia-app],[data-aurelia-app]');
        for (let i = 0, ii = appHosts.length; i < ii; ++i) {
            const appHost = appHosts[i];
            const mainModuleId = appHost.getAttribute('aurelia-app') || appHost.getAttribute('data-aurelia-app');
            bootstrap(config.bind(null, appHost, mainModuleId));
        }
        const toConsole = console.error.bind(console);
        const bootstraps = bootstrapPromises.map(p => p.catch(toConsole));
        bootstrapPromises = null;
        return Promise.all(bootstraps);
    });
}
function bootstrap(configure) {
    const p = startPromise.then(factory => configure(factory()));
    if (bootstrapPromises)
        bootstrapPromises.push(p);
    return p;
}
const starting = run();


//# sourceMappingURL=aurelia-bootstrapper.js.map


/***/ }),

/***/ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   All: () => (/* binding */ All),
/* harmony export */   Container: () => (/* binding */ Container),
/* harmony export */   Factory: () => (/* binding */ Factory),
/* harmony export */   FactoryInvoker: () => (/* binding */ FactoryInvoker),
/* harmony export */   InvocationHandler: () => (/* binding */ InvocationHandler),
/* harmony export */   Lazy: () => (/* binding */ Lazy),
/* harmony export */   NewInstance: () => (/* binding */ NewInstance),
/* harmony export */   Optional: () => (/* binding */ Optional),
/* harmony export */   Parent: () => (/* binding */ Parent),
/* harmony export */   SingletonRegistration: () => (/* binding */ SingletonRegistration),
/* harmony export */   Strategy: () => (/* binding */ Strategy),
/* harmony export */   StrategyResolver: () => (/* binding */ StrategyResolver),
/* harmony export */   TransientRegistration: () => (/* binding */ TransientRegistration),
/* harmony export */   _emptyParameters: () => (/* binding */ _emptyParameters),
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   autoinject: () => (/* binding */ autoinject),
/* harmony export */   factory: () => (/* binding */ factory),
/* harmony export */   getDecoratorDependencies: () => (/* binding */ getDecoratorDependencies),
/* harmony export */   inject: () => (/* binding */ inject),
/* harmony export */   invokeAsFactory: () => (/* binding */ invokeAsFactory),
/* harmony export */   invoker: () => (/* binding */ invoker),
/* harmony export */   lazy: () => (/* binding */ lazy),
/* harmony export */   newInstance: () => (/* binding */ newInstance),
/* harmony export */   optional: () => (/* binding */ optional),
/* harmony export */   parent: () => (/* binding */ parent),
/* harmony export */   registration: () => (/* binding */ registration),
/* harmony export */   resolver: () => (/* binding */ resolver),
/* harmony export */   singleton: () => (/* binding */ singleton),
/* harmony export */   transient: () => (/* binding */ transient)
/* harmony export */ });
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");



/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function isInjectable(potentialTarget) {
    return !!potentialTarget;
}
function autoinject(potentialTarget) {
    const deco = (target) => {
        if (!target.hasOwnProperty('inject')) {
            target.inject = (aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.paramTypes, target) ||
                _emptyParameters).slice();
            if (target.inject && target.inject.length > 0) {
                if (target.inject[target.inject.length - 1] === Object) {
                    target.inject.splice(-1, 1);
                }
            }
        }
    };
    if (isInjectable(potentialTarget)) {
        return deco(potentialTarget);
    }
    return deco;
}
function inject(...rest) {
    return (target, _key, descriptor) => {
        if (typeof descriptor === 'number') {
            autoinject(target);
            if (rest.length === 1) {
                target.inject[descriptor] = rest[0];
            }
            return;
        }
        if (descriptor) {
            const fn = descriptor.value;
            fn.inject = rest;
        }
        else {
            target.inject = rest;
        }
    };
}

var Lazy_1, All_1, Optional_1, Parent_1, Factory_1, NewInstance_1;
const resolver = aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.protocol.create('aurelia:resolver', (target) => {
    if (!(typeof target.get === 'function')) {
        return 'Resolvers must implement: get(container: Container, key: any): any';
    }
    return true;
});
var Strategy;
(function (Strategy) {
    Strategy[Strategy["instance"] = 0] = "instance";
    Strategy[Strategy["singleton"] = 1] = "singleton";
    Strategy[Strategy["transient"] = 2] = "transient";
    Strategy[Strategy["function"] = 3] = "function";
    Strategy[Strategy["array"] = 4] = "array";
    Strategy[Strategy["alias"] = 5] = "alias";
})(Strategy || (Strategy = {}));
function isStrategy(actual, expected, state) {
    return actual === expected;
}
let StrategyResolver = class StrategyResolver {
    constructor(strategy, state) {
        this.strategy = strategy;
        this.state = state;
    }
    get(container, key) {
        if (isStrategy(this.strategy, Strategy.instance, this.state)) {
            return this.state;
        }
        if (isStrategy(this.strategy, Strategy.singleton, this.state)) {
            const singleton = container.invoke(this.state);
            this.state = singleton;
            this.strategy = 0;
            return singleton;
        }
        if (isStrategy(this.strategy, Strategy.transient, this.state)) {
            return container.invoke(this.state);
        }
        if (isStrategy(this.strategy, Strategy.function, this.state)) {
            return this.state(container, key, this);
        }
        if (isStrategy(this.strategy, Strategy.array, this.state)) {
            return this.state[0].get(container, key);
        }
        if (isStrategy(this.strategy, Strategy.alias, this.state)) {
            return container.get(this.state);
        }
        throw new Error('Invalid strategy: ' + this.strategy);
    }
};
StrategyResolver = __decorate([
    resolver(),
    __metadata("design:paramtypes", [Number, Object])
], StrategyResolver);
let Lazy = Lazy_1 = class Lazy {
    constructor(key) {
        this._key = key;
    }
    get(container) {
        return () => container.get(this._key);
    }
    static of(key) {
        return new Lazy_1(key);
    }
};
Lazy = Lazy_1 = __decorate([
    resolver(),
    __metadata("design:paramtypes", [Object])
], Lazy);
let All = All_1 = class All {
    constructor(key) {
        this._key = key;
    }
    get(container) {
        return container.getAll(this._key);
    }
    static of(key) {
        return new All_1(key);
    }
};
All = All_1 = __decorate([
    resolver(),
    __metadata("design:paramtypes", [Object])
], All);
let Optional = Optional_1 = class Optional {
    constructor(key, checkParent = true) {
        this._key = key;
        this._checkParent = checkParent;
    }
    get(container) {
        if (container.hasResolver(this._key, this._checkParent)) {
            return container.get(this._key);
        }
        return null;
    }
    static of(key, checkParent = true) {
        return new Optional_1(key, checkParent);
    }
};
Optional = Optional_1 = __decorate([
    resolver(),
    __metadata("design:paramtypes", [Object, Boolean])
], Optional);
let Parent = Parent_1 = class Parent {
    constructor(key) {
        this._key = key;
    }
    get(container) {
        return container.parent ? container.parent.get(this._key) : null;
    }
    static of(key) {
        return new Parent_1(key);
    }
};
Parent = Parent_1 = __decorate([
    resolver(),
    __metadata("design:paramtypes", [Object])
], Parent);
let Factory = Factory_1 = class Factory {
    constructor(key) {
        this._key = key;
    }
    get(container) {
        let fn = this._key;
        const resolver = container.getResolver(fn);
        if (resolver && resolver.strategy === Strategy.function) {
            fn = resolver.state;
        }
        return (...rest) => container.invoke(fn, rest);
    }
    static of(key) {
        return new Factory_1(key);
    }
};
Factory = Factory_1 = __decorate([
    resolver(),
    __metadata("design:paramtypes", [Object])
], Factory);
let NewInstance = NewInstance_1 = class NewInstance {
    constructor(key, ...dynamicDependencies) {
        this.key = key;
        this.asKey = key;
        this.dynamicDependencies = dynamicDependencies;
    }
    get(container) {
        const dynamicDependencies = this.dynamicDependencies.length > 0
            ? this.dynamicDependencies.map(dependency => dependency['protocol:aurelia:resolver']
                ? dependency.get(container)
                : container.get(dependency))
            : undefined;
        let fn = this.key;
        const resolver = container.getResolver(fn);
        if (resolver && resolver.strategy === 3) {
            fn = resolver.state;
        }
        const instance = container.invoke(fn, dynamicDependencies);
        container.registerInstance(this.asKey, instance);
        return instance;
    }
    as(key) {
        this.asKey = key;
        return this;
    }
    static of(key, ...dynamicDependencies) {
        return new NewInstance_1(key, ...dynamicDependencies);
    }
};
NewInstance = NewInstance_1 = __decorate([
    resolver(),
    __metadata("design:paramtypes", [Object, Object])
], NewInstance);
function getDecoratorDependencies(target) {
    autoinject(target);
    return target.inject;
}
function lazy(keyValue) {
    return (target, _key, index) => {
        const inject$$1 = getDecoratorDependencies(target);
        inject$$1[index] = Lazy.of(keyValue);
    };
}
function all(keyValue) {
    return (target, _key, index) => {
        const inject$$1 = getDecoratorDependencies(target);
        inject$$1[index] = All.of(keyValue);
    };
}
function optional(checkParentOrTarget = true) {
    const deco = (checkParent) => {
        return (target, _key, index) => {
            const inject$$1 = getDecoratorDependencies(target);
            inject$$1[index] = Optional.of(inject$$1[index], checkParent);
        };
    };
    if (typeof checkParentOrTarget === 'boolean') {
        return deco(checkParentOrTarget);
    }
    return deco(true);
}
function parent(target, _key, index) {
    const inject$$1 = getDecoratorDependencies(target);
    inject$$1[index] = Parent.of(inject$$1[index]);
}
function factory(keyValue) {
    return (target, _key, index) => {
        const inject$$1 = getDecoratorDependencies(target);
        inject$$1[index] = Factory.of(keyValue);
    };
}
function newInstance(asKeyOrTarget, ...dynamicDependencies) {
    const deco = (asKey) => {
        return (target, _key, index) => {
            const inject$$1 = getDecoratorDependencies(target);
            inject$$1[index] = NewInstance.of(inject$$1[index], ...dynamicDependencies);
            if (!!asKey) {
                inject$$1[index].as(asKey);
            }
        };
    };
    if (arguments.length >= 1) {
        return deco(asKeyOrTarget);
    }
    return deco();
}

function validateKey(key) {
    if (key === null || key === undefined) {
        throw new Error('key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
    }
}
const _emptyParameters = Object.freeze([]);
aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.registration = 'aurelia:registration';
aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.invoker = 'aurelia:invoker';
const resolverDecorates = resolver.decorates;
class InvocationHandler {
    constructor(fn, invoker, dependencies) {
        this.fn = fn;
        this.invoker = invoker;
        this.dependencies = dependencies;
    }
    invoke(container, dynamicDependencies) {
        return dynamicDependencies !== undefined
            ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies)
            : this.invoker.invoke(container, this.fn, this.dependencies);
    }
}
function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
    let i = staticDependencies.length;
    let args = new Array(i);
    let lookup;
    while (i--) {
        lookup = staticDependencies[i];
        if (lookup === null || lookup === undefined) {
            throw new Error('Constructor Parameter with index ' +
                i +
                ' cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?');
        }
        else {
            args[i] = container.get(lookup);
        }
    }
    if (dynamicDependencies !== undefined) {
        args = args.concat(dynamicDependencies);
    }
    return Reflect.construct(fn, args);
}
const classInvoker = {
    invoke(container, Type, deps) {
        const instances = deps.map((dep) => container.get(dep));
        return Reflect.construct(Type, instances);
    },
    invokeWithDynamicDependencies
};
function getDependencies(f) {
    if (!f.hasOwnProperty('inject')) {
        return [];
    }
    if (typeof f.inject === 'function') {
        return f.inject();
    }
    return f.inject;
}
class Container {
    constructor(configuration) {
        if (configuration === undefined) {
            configuration = {};
        }
        this._configuration = configuration;
        this._onHandlerCreated = configuration.onHandlerCreated;
        this._handlers =
            configuration.handlers || (configuration.handlers = new Map());
        this._resolvers = new Map();
        this.root = this;
        this.parent = null;
    }
    makeGlobal() {
        Container.instance = this;
        return this;
    }
    setHandlerCreatedCallback(onHandlerCreated) {
        this._onHandlerCreated = onHandlerCreated;
        this._configuration.onHandlerCreated = onHandlerCreated;
    }
    registerInstance(key, instance) {
        return this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
    }
    registerSingleton(key, fn) {
        return this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
    }
    registerTransient(key, fn) {
        return this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
    }
    registerHandler(key, handler) {
        return this.registerResolver(key, new StrategyResolver(3, handler));
    }
    registerAlias(originalKey, aliasKey) {
        return this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
    }
    registerResolver(key, resolver$$1) {
        validateKey(key);
        const allResolvers = this._resolvers;
        const result = allResolvers.get(key);
        if (result === undefined) {
            allResolvers.set(key, resolver$$1);
        }
        else if (result.strategy === 4) {
            result.state.push(resolver$$1);
        }
        else {
            allResolvers.set(key, new StrategyResolver(4, [result, resolver$$1]));
        }
        return resolver$$1;
    }
    autoRegister(key, fn) {
        fn = fn === undefined ? key : fn;
        if (typeof fn === 'function') {
            const registration = aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.get(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.registration, fn);
            if (registration === undefined) {
                return this.registerResolver(key, new StrategyResolver(1, fn));
            }
            return registration.registerResolver(this, key, fn);
        }
        return this.registerResolver(key, new StrategyResolver(0, fn));
    }
    autoRegisterAll(fns) {
        let i = fns.length;
        while (i--) {
            this.autoRegister(fns[i]);
        }
    }
    unregister(key) {
        this._resolvers.delete(key);
    }
    hasResolver(key, checkParent = false) {
        validateKey(key);
        return (this._resolvers.has(key) ||
            (checkParent &&
                this.parent !== null &&
                this.parent.hasResolver(key, checkParent)));
    }
    getResolver(key) {
        return this._resolvers.get(key);
    }
    get(key) {
        validateKey(key);
        if (key === Container) {
            return this;
        }
        if (resolverDecorates(key)) {
            return key.get(this, key);
        }
        const resolver$$1 = this._resolvers.get(key);
        if (resolver$$1 === undefined) {
            if (this.parent === null) {
                return this.autoRegister(key).get(this, key);
            }
            const registration = aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.get(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.registration, key);
            if (registration === undefined) {
                return this.parent._get(key);
            }
            return registration.registerResolver(this, key, key).get(this, key);
        }
        return resolver$$1.get(this, key);
    }
    _get(key) {
        const resolver$$1 = this._resolvers.get(key);
        if (resolver$$1 === undefined) {
            if (this.parent === null) {
                return this.autoRegister(key).get(this, key);
            }
            return this.parent._get(key);
        }
        return resolver$$1.get(this, key);
    }
    getAll(key) {
        validateKey(key);
        const resolver$$1 = this._resolvers.get(key);
        if (resolver$$1 === undefined) {
            if (this.parent === null) {
                return _emptyParameters;
            }
            return this.parent.getAll(key);
        }
        if (resolver$$1.strategy === 4) {
            const state = resolver$$1.state;
            let i = state.length;
            const results = new Array(i);
            while (i--) {
                results[i] = state[i].get(this, key);
            }
            return results;
        }
        return [resolver$$1.get(this, key)];
    }
    createChild() {
        const child = new Container(this._configuration);
        child.root = this.root;
        child.parent = this;
        return child;
    }
    invoke(fn, dynamicDependencies) {
        try {
            let handler = this._handlers.get(fn);
            if (handler === undefined) {
                handler = this._createInvocationHandler(fn);
                this._handlers.set(fn, handler);
            }
            return handler.invoke(this, dynamicDependencies);
        }
        catch (e) {
            throw new aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.AggregateError(`Error invoking ${fn.name}. Check the inner error for details.`, e, true);
        }
    }
    _createInvocationHandler(fn) {
        let dependencies;
        if (fn.inject === undefined) {
            dependencies =
                aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.paramTypes, fn) || _emptyParameters;
        }
        else {
            dependencies = [];
            let ctor = fn;
            while (typeof ctor === 'function') {
                dependencies.push(...getDependencies(ctor));
                ctor = Object.getPrototypeOf(ctor);
            }
        }
        const invoker = aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.invoker, fn) || classInvoker;
        const handler = new InvocationHandler(fn, invoker, dependencies);
        return this._onHandlerCreated !== undefined
            ? this._onHandlerCreated(handler)
            : handler;
    }
}

function invoker(value) {
    return target => {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.invoker, value, target);
    };
}
function invokeAsFactory(potentialTarget) {
    const deco = (target) => {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.invoker, FactoryInvoker.instance, target);
    };
    return potentialTarget ? deco(potentialTarget) : deco;
}
class FactoryInvoker {
    invoke(container, fn, dependencies) {
        let i = dependencies.length;
        const args = new Array(i);
        while (i--) {
            args[i] = container.get(dependencies[i]);
        }
        return fn.apply(undefined, args);
    }
    invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
        let i = staticDependencies.length;
        let args = new Array(i);
        while (i--) {
            args[i] = container.get(staticDependencies[i]);
        }
        if (dynamicDependencies !== undefined) {
            args = args.concat(dynamicDependencies);
        }
        return fn.apply(undefined, args);
    }
}
FactoryInvoker.instance = new FactoryInvoker();

function registration(value) {
    return (target) => {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_0__.metadata.registration, value, target);
    };
}
function transient(key) {
    return registration(new TransientRegistration(key));
}
function singleton(keyOrRegisterInChild, registerInChild = false) {
    return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
}
class TransientRegistration {
    constructor(key) {
        this._key = key;
    }
    registerResolver(container, key, fn) {
        const existingResolver = container.getResolver(this._key || key);
        return existingResolver === undefined
            ? container.registerTransient((this._key || key), fn)
            : existingResolver;
    }
}
class SingletonRegistration {
    constructor(keyOrRegisterInChild, registerInChild = false) {
        if (typeof keyOrRegisterInChild === 'boolean') {
            this._registerInChild = keyOrRegisterInChild;
        }
        else {
            this._key = keyOrRegisterInChild;
            this._registerInChild = registerInChild;
        }
    }
    registerResolver(container, key, fn) {
        const targetContainer = this._registerInChild ? container : container.root;
        const existingResolver = targetContainer.getResolver(this._key || key);
        return existingResolver === undefined
            ? targetContainer.registerSingleton(this._key || key, fn)
            : existingResolver;
    }
}




/***/ }),

/***/ "../../node_modules/aurelia-history/dist/es2015/aurelia-history.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/aurelia-history/dist/es2015/aurelia-history.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   History: () => (/* binding */ History)
/* harmony export */ });


function mi(name) {
  throw new Error(`History must implement ${name}().`);
}

let History = class History {
  activate(options) {
    mi('activate');
  }

  deactivate() {
    mi('deactivate');
  }

  getAbsoluteRoot() {
    mi('getAbsoluteRoot');
  }

  navigate(fragment, options) {
    mi('navigate');
  }

  navigateBack() {
    mi('navigateBack');
  }

  setTitle(title) {
    mi('setTitle');
  }

  setState(key, value) {
    mi('setState');
  }

  getState(key) {
    mi('getState');
  }

  getHistoryIndex() {
    mi('getHistoryIndex');
  }

  go(movement) {
    mi('go');
  }
};

/***/ }),

/***/ "../../node_modules/aurelia-loader-webpack/dist/es2015/aurelia-loader-webpack.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/aurelia-loader-webpack/dist/es2015/aurelia-loader-webpack.js ***!
  \***************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextTemplateLoader: () => (/* binding */ TextTemplateLoader),
/* harmony export */   WebpackLoader: () => (/* binding */ WebpackLoader),
/* harmony export */   ensureOriginOnExports: () => (/* binding */ ensureOriginOnExports)
/* harmony export */ });
/* harmony import */ var aurelia_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-loader */ "../../node_modules/aurelia-loader/dist/es2015/aurelia-loader.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
/* module decorator */ module = __webpack_require__.hmd(module);




/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
* An implementation of the TemplateLoader interface implemented with text-based loading.
*/
class TextTemplateLoader {
    /**
    * Loads a template.
    * @param loader The loader that is requesting the template load.
    * @param entry The TemplateRegistryEntry to load and populate with a template.
    * @return A promise which resolves when the TemplateRegistryEntry is loaded with a template.
    */
    loadTemplate(loader, entry) {
        return __awaiter(this, void 0, void 0, function* () {
            const text = yield loader.loadText(entry.address);
            entry.template = aurelia_pal__WEBPACK_IMPORTED_MODULE_2__.DOM.createTemplateFromMarkup(text);
        });
    }
}
function ensureOriginOnExports(moduleExports, moduleId) {
    let target = moduleExports;
    let key;
    let exportedValue;
    if (target.__useDefault) {
        target = target.default;
    }
    aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.Origin.set(target, new aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.Origin(moduleId, 'default'));
    if (typeof target === 'object') {
        for (key in target) {
            exportedValue = target[key];
            if (typeof exportedValue === 'function') {
                aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.Origin.set(exportedValue, new aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.Origin(moduleId, key));
            }
        }
    }
    return moduleExports;
}
/**
* A default implementation of the Loader abstraction which works with webpack (extended common-js style).
*/
class WebpackLoader extends aurelia_loader__WEBPACK_IMPORTED_MODULE_0__.Loader {
    constructor() {
        super();
        this.moduleRegistry = Object.create(null);
        this.loaderPlugins = Object.create(null);
        this.modulesBeingLoaded = new Map();
        this.useTemplateLoader(new TextTemplateLoader());
        this.addPlugin('template-registry-entry', {
            fetch: (moduleId) => __awaiter(this, void 0, void 0, function* () {
                // HMR:
                if (false) {}
                const entry = this.getOrCreateTemplateRegistryEntry(moduleId);
                if (!entry.templateIsLoaded) {
                    yield this.templateLoader.loadTemplate(this, entry);
                }
                return entry;
            })
        });
        aurelia_pal__WEBPACK_IMPORTED_MODULE_2__.PLATFORM.eachModule = callback => {
            const registry = __webpack_require__.c;
            const cachedModuleIds = Object.getOwnPropertyNames(registry);
            cachedModuleIds
                // Note: we use .some here like a .forEach that can be "break"ed out of.
                // It will stop iterating only when a truthy value is returned.
                // Even though the docs say "true" explicitly, loader-default also goes by truthy
                // and this is to keep it consistent with that.
                .some(moduleId => {
                const moduleExports = registry[moduleId].exports;
                if (typeof moduleExports === 'object') {
                    return callback(moduleId, moduleExports);
                }
                return false;
            });
        };
    }
    _import(address, defaultHMR = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const addressParts = address.split('!');
            const moduleId = addressParts.splice(addressParts.length - 1, 1)[0];
            const loaderPlugin = addressParts.length === 1 ? addressParts[0] : null;
            if (loaderPlugin) {
                const plugin = this.loaderPlugins[loaderPlugin];
                if (!plugin) {
                    throw new Error(`Plugin ${loaderPlugin} is not registered in the loader.`);
                }
                if (false) {}
                return yield plugin.fetch(moduleId);
            }
            if (__webpack_require__.m[moduleId]) {
                if (defaultHMR && module.hot && 0) {}
                return __webpack_require__(moduleId);
            }
            const asyncModuleId = `async!${moduleId}`;
            if (__webpack_require__.m[asyncModuleId]) {
                if (defaultHMR && module.hot && 0) {}
                const callback = __webpack_require__(asyncModuleId);
                return yield new Promise(callback);
            }
            throw new Error(`Unable to find module with ID: ${moduleId}`);
        });
    }
    /**
    * Maps a module id to a source.
    * @param id The module id.
    * @param source The source to map the module to.
    */
    map(id, source) { }
    /**
    * Normalizes a module id.
    * @param moduleId The module id to normalize.
    * @param relativeTo What the module id should be normalized relative to.
    * @return The normalized module id.
    */
    normalizeSync(moduleId, relativeTo) {
        return moduleId;
    }
    /**
    * Normalizes a module id.
    * @param moduleId The module id to normalize.
    * @param relativeTo What the module id should be normalized relative to.
    * @return The normalized module id.
    */
    normalize(moduleId, relativeTo) {
        return Promise.resolve(moduleId);
    }
    /**
    * Instructs the loader to use a specific TemplateLoader instance for loading templates
    * @param templateLoader The instance of TemplateLoader to use for loading templates.
    */
    useTemplateLoader(templateLoader) {
        this.templateLoader = templateLoader;
    }
    /**
    * Loads a collection of modules.
    * @param ids The set of module ids to load.
    * @return A Promise for an array of loaded modules.
    */
    loadAllModules(ids) {
        return Promise.all(ids.map(id => this.loadModule(id)));
    }
    /**
    * Loads a module.
    * @param moduleId The module ID to load.
    * @return A Promise for the loaded module.
    */
    loadModule(moduleId, defaultHMR = true) {
        return __awaiter(this, void 0, void 0, function* () {
            let existing = this.moduleRegistry[moduleId];
            if (existing) {
                return existing;
            }
            let beingLoaded = this.modulesBeingLoaded.get(moduleId);
            if (beingLoaded) {
                return beingLoaded;
            }
            beingLoaded = this._import(moduleId, defaultHMR);
            this.modulesBeingLoaded.set(moduleId, beingLoaded);
            const moduleExports = yield beingLoaded;
            this.moduleRegistry[moduleId] = ensureOriginOnExports(moduleExports, moduleId);
            this.modulesBeingLoaded.delete(moduleId);
            return moduleExports;
        });
    }
    /**
    * Loads a template.
    * @param url The url of the template to load.
    * @return A Promise for a TemplateRegistryEntry containing the template.
    */
    loadTemplate(url) {
        return this.loadModule(this.applyPluginToUrl(url, 'template-registry-entry'), false);
    }
    /**
    * Loads a text-based resource.
    * @param url The url of the text file to load.
    * @return A Promise for text content.
    */
    loadText(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.loadModule(url, false);
            // css-loader could use esModule:true
            const defaultExport = result && result.__esModule ? result.default : result;
            if (defaultExport instanceof Array && defaultExport[0] instanceof Array && defaultExport.hasOwnProperty('toString')) {
                // we're dealing with a file loaded using the css-loader:
                return defaultExport.toString();
            }
            return typeof result === "string" ? result : defaultExport;
        });
    }
    /**
    * Alters a module id so that it includes a plugin loader.
    * @param url The url of the module to load.
    * @param pluginName The plugin to apply to the module id.
    * @return The plugin-based module id.
    */
    applyPluginToUrl(url, pluginName) {
        return `${pluginName}!${url}`;
    }
    /**
    * Registers a plugin with the loader.
    * @param pluginName The name of the plugin.
    * @param implementation The plugin implementation.
    */
    addPlugin(pluginName, implementation) {
        this.loaderPlugins[pluginName] = implementation;
    }
}
aurelia_pal__WEBPACK_IMPORTED_MODULE_2__.PLATFORM.Loader = WebpackLoader;




/***/ }),

/***/ "../../node_modules/aurelia-loader/dist/es2015/aurelia-loader.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/aurelia-loader/dist/es2015/aurelia-loader.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Loader: () => (/* binding */ Loader),
/* harmony export */   TemplateDependency: () => (/* binding */ TemplateDependency),
/* harmony export */   TemplateRegistryEntry: () => (/* binding */ TemplateRegistryEntry)
/* harmony export */ });
/* harmony import */ var aurelia_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-path */ "../../node_modules/aurelia-path/dist/es2015/aurelia-path.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");



let TemplateDependency = class TemplateDependency {
  constructor(src, name) {
    this.src = src;
    this.name = name;
  }
};

let TemplateRegistryEntry = class TemplateRegistryEntry {
  constructor(address) {
    this.templateIsLoaded = false;
    this.factoryIsReady = false;
    this.resources = null;
    this.dependencies = null;

    this.address = address;
    this.onReady = null;
    this._template = null;
    this._factory = null;
  }

  get template() {
    return this._template;
  }

  set template(value) {
    let address = this.address;
    let requires;
    let current;
    let src;
    let dependencies;

    this._template = value;
    this.templateIsLoaded = true;

    requires = value.content.querySelectorAll('require');
    dependencies = this.dependencies = new Array(requires.length);

    for (let i = 0, ii = requires.length; i < ii; ++i) {
      current = requires[i];
      src = current.getAttribute('from');

      if (!src) {
        throw new Error(`<require> element in ${address} has no "from" attribute.`);
      }

      dependencies[i] = new TemplateDependency((0,aurelia_path__WEBPACK_IMPORTED_MODULE_0__.relativeToFile)(src, address), current.getAttribute('as'));

      if (current.parentNode) {
        current.parentNode.removeChild(current);
      }
    }
  }

  get factory() {
    return this._factory;
  }

  set factory(value) {
    this._factory = value;
    this.factoryIsReady = true;
  }

  addDependency(src, name) {
    let finalSrc = typeof src === 'string' ? (0,aurelia_path__WEBPACK_IMPORTED_MODULE_0__.relativeToFile)(src, this.address) : aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.Origin.get(src).moduleId;

    this.dependencies.push(new TemplateDependency(finalSrc, name));
  }
};

let Loader = class Loader {
  constructor() {
    this.templateRegistry = {};
  }

  map(id, source) {
    throw new Error('Loaders must implement map(id, source).');
  }

  normalizeSync(moduleId, relativeTo) {
    throw new Error('Loaders must implement normalizeSync(moduleId, relativeTo).');
  }

  normalize(moduleId, relativeTo) {
    throw new Error('Loaders must implement normalize(moduleId: string, relativeTo: string): Promise<string>.');
  }

  loadModule(id) {
    throw new Error('Loaders must implement loadModule(id).');
  }

  loadAllModules(ids) {
    throw new Error('Loader must implement loadAllModules(ids).');
  }

  loadTemplate(url) {
    throw new Error('Loader must implement loadTemplate(url).');
  }

  loadText(url) {
    throw new Error('Loader must implement loadText(url).');
  }

  applyPluginToUrl(url, pluginName) {
    throw new Error('Loader must implement applyPluginToUrl(url, pluginName).');
  }

  addPlugin(pluginName, implementation) {
    throw new Error('Loader must implement addPlugin(pluginName, implementation).');
  }

  getOrCreateTemplateRegistryEntry(address) {
    return this.templateRegistry[address] || (this.templateRegistry[address] = new TemplateRegistryEntry(address));
  }
};

/***/ }),

/***/ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Logger: () => (/* binding */ Logger),
/* harmony export */   addAppender: () => (/* binding */ addAppender),
/* harmony export */   addCustomLevel: () => (/* binding */ addCustomLevel),
/* harmony export */   clearAppenders: () => (/* binding */ clearAppenders),
/* harmony export */   getAppenders: () => (/* binding */ getAppenders),
/* harmony export */   getLevel: () => (/* binding */ getLevel),
/* harmony export */   getLogger: () => (/* binding */ getLogger),
/* harmony export */   logLevel: () => (/* binding */ logLevel),
/* harmony export */   removeAppender: () => (/* binding */ removeAppender),
/* harmony export */   removeCustomLevel: () => (/* binding */ removeCustomLevel),
/* harmony export */   setLevel: () => (/* binding */ setLevel)
/* harmony export */ });

const logLevel = {
  none: 0,
  error: 10,
  warn: 20,
  info: 30,
  debug: 40
};

let loggers = {};
let appenders = [];
let globalDefaultLevel = logLevel.none;

const standardLevels = ['none', 'error', 'warn', 'info', 'debug'];
function isStandardLevel(level) {
  return standardLevels.filter(l => l === level).length > 0;
}

function appendArgs() {
  return [this, ...arguments];
}

function logFactory(level) {
  const threshold = logLevel[level];
  return function () {
    if (this.level < threshold) {
      return;
    }

    const args = appendArgs.apply(this, arguments);
    let i = appenders.length;
    while (i--) {
      appenders[i][level](...args);
    }
  };
}

function logFactoryCustom(level) {
  const threshold = logLevel[level];
  return function () {
    if (this.level < threshold) {
      return;
    }

    const args = appendArgs.apply(this, arguments);
    let i = appenders.length;
    while (i--) {
      const appender = appenders[i];
      if (appender[level] !== undefined) {
        appender[level](...args);
      }
    }
  };
}

function connectLoggers() {
  let proto = Logger.prototype;
  for (let level in logLevel) {
    if (isStandardLevel(level)) {
      if (level !== 'none') {
        proto[level] = logFactory(level);
      }
    } else {
      proto[level] = logFactoryCustom(level);
    }
  }
}

function disconnectLoggers() {
  let proto = Logger.prototype;
  for (let level in logLevel) {
    if (level !== 'none') {
      proto[level] = function () {};
    }
  }
}

function getLogger(id) {
  return loggers[id] || new Logger(id);
}

function addAppender(appender) {
  if (appenders.push(appender) === 1) {
    connectLoggers();
  }
}

function removeAppender(appender) {
  appenders = appenders.filter(a => a !== appender);
}

function getAppenders() {
  return [...appenders];
}

function clearAppenders() {
  appenders = [];
  disconnectLoggers();
}

function addCustomLevel(name, value) {
  if (logLevel[name] !== undefined) {
    throw Error(`Log level "${name}" already exists.`);
  }

  if (isNaN(value)) {
    throw Error('Value must be a number.');
  }

  logLevel[name] = value;

  if (appenders.length > 0) {
    connectLoggers();
  } else {
    Logger.prototype[name] = function () {};
  }
}

function removeCustomLevel(name) {
  if (logLevel[name] === undefined) {
    return;
  }

  if (isStandardLevel(name)) {
    throw Error(`Built-in log level "${name}" cannot be removed.`);
  }

  delete logLevel[name];
  delete Logger.prototype[name];
}

function setLevel(level) {
  globalDefaultLevel = level;
  for (let key in loggers) {
    loggers[key].setLevel(level);
  }
}

function getLevel() {
  return globalDefaultLevel;
}

let Logger = class Logger {
  constructor(id) {
    let cached = loggers[id];
    if (cached) {
      return cached;
    }

    loggers[id] = this;
    this.id = id;
    this.level = globalDefaultLevel;
  }

  debug(message, ...rest) {}

  info(message, ...rest) {}

  warn(message, ...rest) {}

  error(message, ...rest) {}

  setLevel(level) {
    this.level = level;
  }

  isDebugEnabled() {
    return this.level === logLevel.debug;
  }
};

/***/ }),

/***/ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Origin: () => (/* binding */ Origin),
/* harmony export */   decorators: () => (/* binding */ decorators),
/* harmony export */   deprecated: () => (/* binding */ deprecated),
/* harmony export */   metadata: () => (/* binding */ metadata),
/* harmony export */   mixin: () => (/* binding */ mixin),
/* harmony export */   protocol: () => (/* binding */ protocol)
/* harmony export */ });
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



function isObject(val) {
  return val && (typeof val === 'function' || typeof val === 'object');
}

const metadata = {
  resource: 'aurelia:resource',
  paramTypes: 'design:paramtypes',
  propertyType: 'design:type',
  properties: 'design:properties',
  get(metadataKey, target, targetKey) {
    if (!isObject(target)) {
      return undefined;
    }
    let result = metadata.getOwn(metadataKey, target, targetKey);
    return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
  },
  getOwn(metadataKey, target, targetKey) {
    if (!isObject(target)) {
      return undefined;
    }
    return Reflect.getOwnMetadata(metadataKey, target, targetKey);
  },
  define(metadataKey, metadataValue, target, targetKey) {
    Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
  },
  getOrCreateOwn(metadataKey, Type, target, targetKey) {
    let result = metadata.getOwn(metadataKey, target, targetKey);

    if (result === undefined) {
      result = new Type();
      Reflect.defineMetadata(metadataKey, result, target, targetKey);
    }

    return result;
  }
};

const originStorage = new Map();
const unknownOrigin = Object.freeze({ moduleId: undefined, moduleMember: undefined });

let Origin = class Origin {
  constructor(moduleId, moduleMember) {
    this.moduleId = moduleId;
    this.moduleMember = moduleMember;
  }

  static get(fn) {
    let origin = originStorage.get(fn);

    if (origin === undefined) {
      aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.PLATFORM.eachModule((key, value) => {
        if (typeof value === 'object') {
          for (let name in value) {
            try {
              let exp = value[name];
              if (exp === fn) {
                originStorage.set(fn, origin = new Origin(key, name));
                return true;
              }
            } catch (e) {}
          }
        }

        if (value === fn) {
          originStorage.set(fn, origin = new Origin(key, 'default'));
          return true;
        }

        return false;
      });
    }

    return origin || unknownOrigin;
  }

  static set(fn, origin) {
    originStorage.set(fn, origin);
  }
};

function decorators(...rest) {
  let applicator = function (target, key, descriptor) {
    let i = rest.length;

    if (key) {
      descriptor = descriptor || {
        value: target[key],
        writable: true,
        configurable: true,
        enumerable: true
      };

      while (i--) {
        descriptor = rest[i](target, key, descriptor) || descriptor;
      }

      Object.defineProperty(target, key, descriptor);
    } else {
      while (i--) {
        target = rest[i](target) || target;
      }
    }

    return target;
  };

  applicator.on = applicator;
  return applicator;
}

function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
  function decorator(target, key, descriptor) {
    const methodSignature = `${target.constructor.name}#${key}`;
    let options = maybeKey ? {} : optionsOrTarget || {};
    let message = `DEPRECATION - ${methodSignature}`;

    if (typeof descriptor.value !== 'function') {
      throw new SyntaxError('Only methods can be marked as deprecated.');
    }

    if (options.message) {
      message += ` - ${options.message}`;
    }

    return _extends({}, descriptor, {
      value: function deprecationWrapper() {
        if (options.error) {
          throw new Error(message);
        } else {
          console.warn(message);
        }

        return descriptor.value.apply(this, arguments);
      }
    });
  }

  return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
}

function mixin(behavior) {
  const instanceKeys = Object.keys(behavior);

  function _mixin(possible) {
    let decorator = function (target) {
      let resolvedTarget = typeof target === 'function' ? target.prototype : target;

      let i = instanceKeys.length;
      while (i--) {
        let property = instanceKeys[i];
        Object.defineProperty(resolvedTarget, property, {
          value: behavior[property],
          writable: true
        });
      }
    };

    return possible ? decorator(possible) : decorator;
  }

  return _mixin;
}

function alwaysValid() {
  return true;
}
function noCompose() {}

function ensureProtocolOptions(options) {
  if (options === undefined) {
    options = {};
  } else if (typeof options === 'function') {
    options = {
      validate: options
    };
  }

  if (!options.validate) {
    options.validate = alwaysValid;
  }

  if (!options.compose) {
    options.compose = noCompose;
  }

  return options;
}

function createProtocolValidator(validate) {
  return function (target) {
    let result = validate(target);
    return result === true;
  };
}

function createProtocolAsserter(name, validate) {
  return function (target) {
    let result = validate(target);
    if (result !== true) {
      throw new Error(result || `${name} was not correctly implemented.`);
    }
  };
}

function protocol(name, options) {
  options = ensureProtocolOptions(options);

  let result = function (target) {
    let resolvedTarget = typeof target === 'function' ? target.prototype : target;

    options.compose(resolvedTarget);
    result.assert(resolvedTarget);

    Object.defineProperty(resolvedTarget, 'protocol:' + name, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: true
    });
  };

  result.validate = createProtocolValidator(options.validate);
  result.assert = createProtocolAsserter(name, options.validate);

  return result;
}

protocol.create = function (name, options) {
  options = ensureProtocolOptions(options);
  let hidden = 'protocol:' + name;
  let result = function (target) {
    let decorator = protocol(name, options);
    return target ? decorator(target) : decorator;
  };

  result.decorates = function (obj) {
    return obj[hidden] === true;
  };
  result.validate = createProtocolValidator(options.validate);
  result.assert = createProtocolAsserter(name, options.validate);

  return result;
};

/***/ }),

/***/ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AggregateError: () => (/* binding */ AggregateError),
/* harmony export */   DOM: () => (/* binding */ DOM),
/* harmony export */   FEATURE: () => (/* binding */ FEATURE),
/* harmony export */   PLATFORM: () => (/* binding */ PLATFORM),
/* harmony export */   initializePAL: () => (/* binding */ initializePAL),
/* harmony export */   isInitialized: () => (/* binding */ isInitialized),
/* harmony export */   reset: () => (/* binding */ reset)
/* harmony export */ });

function AggregateError(message, innerError, skipIfAlreadyAggregate) {
  if (innerError) {
    if (innerError.innerError && skipIfAlreadyAggregate) {
      return innerError;
    }

    const separator = '\n------------------------------------------------\n';

    message += `${separator}Inner Error:\n`;

    if (typeof innerError === 'string') {
      message += `Message: ${innerError}`;
    } else {
      if (innerError.message) {
        message += `Message: ${innerError.message}`;
      } else {
        message += `Unknown Inner Error Type. Displaying Inner Error as JSON:\n ${JSON.stringify(innerError, null, '  ')}`;
      }

      if (innerError.stack) {
        message += `\nInner Error Stack:\n${innerError.stack}`;
        message += '\nEnd Inner Error Stack';
      }
    }

    message += separator;
  }

  let e = new Error(message);
  if (innerError) {
    e.innerError = innerError;
  }

  return e;
}

const FEATURE = {};

const PLATFORM = {
  noop() {},
  eachModule() {},
  moduleName(moduleName) {
    return moduleName;
  }
};

PLATFORM.global = function () {
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof __webpack_require__.g !== 'undefined') {
    return __webpack_require__.g;
  }

  return new Function('return this')();
}();

const DOM = {};
let isInitialized = false;

function initializePAL(callback) {
  if (isInitialized) {
    return;
  }
  isInitialized = true;
  if (typeof Object.getPropertyDescriptor !== 'function') {
    Object.getPropertyDescriptor = function (subject, name) {
      let pd = Object.getOwnPropertyDescriptor(subject, name);
      let proto = Object.getPrototypeOf(subject);
      while (typeof pd === 'undefined' && proto !== null) {
        pd = Object.getOwnPropertyDescriptor(proto, name);
        proto = Object.getPrototypeOf(proto);
      }
      return pd;
    };
  }

  callback(PLATFORM, FEATURE, DOM);
}
function reset() {
  isInitialized = false;
}

/***/ }),

/***/ "../../node_modules/aurelia-path/dist/es2015/aurelia-path.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/aurelia-path/dist/es2015/aurelia-path.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildQueryString: () => (/* binding */ buildQueryString),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   parseQueryString: () => (/* binding */ parseQueryString),
/* harmony export */   relativeToFile: () => (/* binding */ relativeToFile)
/* harmony export */ });
function trimDots(ary) {
    for (let i = 0; i < ary.length; ++i) {
        let part = ary[i];
        if (part === '.') {
            ary.splice(i, 1);
            i -= 1;
        }
        else if (part === '..') {
            if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                continue;
            }
            else if (i > 0) {
                ary.splice(i - 1, 2);
                i -= 2;
            }
        }
    }
}
function relativeToFile(name, file) {
    let fileParts = file && file.split('/');
    let nameParts = name.trim().split('/');
    if (nameParts[0].charAt(0) === '.' && fileParts) {
        let normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);
        nameParts.unshift(...normalizedBaseParts);
    }
    trimDots(nameParts);
    return nameParts.join('/');
}
function join(path1, path2) {
    if (!path1) {
        return path2;
    }
    if (!path2) {
        return path1;
    }
    let schemeMatch = path1.match(/^([^/]*?:)\//);
    let scheme = (schemeMatch && schemeMatch.length > 0) ? schemeMatch[1] : '';
    path1 = path1.substr(scheme.length);
    let urlPrefix;
    if (path1.indexOf('///') === 0 && scheme === 'file:') {
        urlPrefix = '///';
    }
    else if (path1.indexOf('//') === 0) {
        urlPrefix = '//';
    }
    else if (path1.indexOf('/') === 0) {
        urlPrefix = '/';
    }
    else {
        urlPrefix = '';
    }
    let trailingSlash = path2.slice(-1) === '/' ? '/' : '';
    let url1 = path1.split('/');
    let url2 = path2.split('/');
    let url3 = [];
    for (let i = 0, ii = url1.length; i < ii; ++i) {
        if (url1[i] === '..') {
            if (url3.length && url3[url3.length - 1] !== '..') {
                url3.pop();
            }
            else {
                url3.push(url1[i]);
            }
        }
        else if (url1[i] === '.' || url1[i] === '') {
            continue;
        }
        else {
            url3.push(url1[i]);
        }
    }
    for (let i = 0, ii = url2.length; i < ii; ++i) {
        if (url2[i] === '..') {
            if (url3.length && url3[url3.length - 1] !== '..') {
                url3.pop();
            }
            else {
                url3.push(url2[i]);
            }
        }
        else if (url2[i] === '.' || url2[i] === '') {
            continue;
        }
        else {
            url3.push(url2[i]);
        }
    }
    return scheme + urlPrefix + url3.join('/') + trailingSlash;
}
let encode = encodeURIComponent;
let encodeKey = k => encode(k).replace('%24', '$');
function buildParam(key, value, traditional) {
    let result = [];
    if (value === null || value === undefined) {
        return result;
    }
    if (Array.isArray(value)) {
        for (let i = 0, l = value.length; i < l; i++) {
            if (traditional) {
                result.push(`${encodeKey(key)}=${encode(value[i])}`);
            }
            else {
                let arrayKey = key + '[' + (typeof value[i] === 'object' && value[i] !== null ? i : '') + ']';
                result = result.concat(buildParam(arrayKey, value[i]));
            }
        }
    }
    else if (typeof (value) === 'object' && !traditional) {
        for (let propertyName in value) {
            result = result.concat(buildParam(key + '[' + propertyName + ']', value[propertyName]));
        }
    }
    else {
        result.push(`${encodeKey(key)}=${encode(value)}`);
    }
    return result;
}
function buildQueryString(params, traditional) {
    let pairs = [];
    let keys = Object.keys(params || {}).sort();
    for (let i = 0, len = keys.length; i < len; i++) {
        let key = keys[i];
        pairs = pairs.concat(buildParam(key, params[key], traditional));
    }
    if (pairs.length === 0) {
        return '';
    }
    return pairs.join('&');
}
function processScalarParam(existedParam, value) {
    if (Array.isArray(existedParam)) {
        existedParam.push(value);
        return existedParam;
    }
    if (existedParam !== undefined) {
        return [existedParam, value];
    }
    return value;
}
function parseComplexParam(queryParams, keys, value) {
    let currentParams = queryParams;
    let keysLastIndex = keys.length - 1;
    for (let j = 0; j <= keysLastIndex; j++) {
        let key = keys[j] === '' ? currentParams.length : keys[j];
        preventPollution(key);
        if (j < keysLastIndex) {
            let prevValue = !currentParams[key] || typeof currentParams[key] === 'object' ? currentParams[key] : [currentParams[key]];
            currentParams = currentParams[key] = prevValue || (isNaN(keys[j + 1]) ? {} : []);
        }
        else {
            currentParams = currentParams[key] = value;
        }
    }
}
function parseQueryString(queryString) {
    let queryParams = {};
    if (!queryString || typeof queryString !== 'string') {
        return queryParams;
    }
    let query = queryString;
    if (query.charAt(0) === '?') {
        query = query.substr(1);
    }
    let pairs = query.replace(/\+/g, ' ').split('&');
    for (let i = 0; i < pairs.length; i++) {
        let pair = pairs[i].split('=');
        let key = decodeURIComponent(pair[0]);
        if (!key) {
            continue;
        }
        let keys = key.split('][');
        let keysLastIndex = keys.length - 1;
        if (/\[/.test(keys[0]) && /\]$/.test(keys[keysLastIndex])) {
            keys[keysLastIndex] = keys[keysLastIndex].replace(/\]$/, '');
            keys = keys.shift().split('[').concat(keys);
            keysLastIndex = keys.length - 1;
        }
        else {
            keysLastIndex = 0;
        }
        if (pair.length >= 2) {
            let value = pair[1] ? decodeURIComponent(pair[1]) : '';
            if (keysLastIndex) {
                parseComplexParam(queryParams, keys, value);
            }
            else {
                preventPollution(key);
                queryParams[key] = processScalarParam(queryParams[key], value);
            }
        }
        else {
            queryParams[key] = true;
        }
    }
    return queryParams;
}
function preventPollution(key) {
    if (key === '__proto__') {
        throw new Error('Prototype pollution detected.');
    }
}


//# sourceMappingURL=aurelia-path.js.map


/***/ }),

/***/ "../../node_modules/aurelia-polyfills/dist/es2015/aurelia-polyfills.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/aurelia-polyfills/dist/es2015/aurelia-polyfills.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");


if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function (Object, GOPS) {
    'use strict';

    if (GOPS in Object) return;

    var setDescriptor,
        G = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.PLATFORM.global,
        id = 0,
        random = '' + Math.random(),
        prefix = '__\x01symbol:',
        prefixLength = prefix.length,
        internalSymbol = '__\x01symbol@@' + random,
        DP = 'defineProperty',
        DPies = 'defineProperties',
        GOPN = 'getOwnPropertyNames',
        GOPD = 'getOwnPropertyDescriptor',
        PIE = 'propertyIsEnumerable',
        gOPN = Object[GOPN],
        gOPD = Object[GOPD],
        create = Object.create,
        keys = Object.keys,
        defineProperty = Object[DP],
        $defineProperties = Object[DPies],
        descriptor = gOPD(Object, GOPN),
        ObjectProto = Object.prototype,
        hOP = ObjectProto.hasOwnProperty,
        pIE = ObjectProto[PIE],
        toString = ObjectProto.toString,
        indexOf = Array.prototype.indexOf || function (v) {
      for (var i = this.length; i-- && this[i] !== v;) {}
      return i;
    },
        addInternalIfNeeded = function (o, uid, enumerable) {
      if (!hOP.call(o, internalSymbol)) {
        defineProperty(o, internalSymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: {}
        });
      }
      o[internalSymbol]['@@' + uid] = enumerable;
    },
        createWithSymbols = function (proto, descriptors) {
      var self = create(proto);
      if (descriptors !== null && typeof descriptors === 'object') {
        gOPN(descriptors).forEach(function (key) {
          if (propertyIsEnumerable.call(descriptors, key)) {
            $defineProperty(self, key, descriptors[key]);
          }
        });
      }
      return self;
    },
        copyAsNonEnumerable = function (descriptor) {
      var newDescriptor = create(descriptor);
      newDescriptor.enumerable = false;
      return newDescriptor;
    },
        get = function get() {},
        onlyNonSymbols = function (name) {
      return name != internalSymbol && !hOP.call(source, name);
    },
        onlySymbols = function (name) {
      return name != internalSymbol && hOP.call(source, name);
    },
        propertyIsEnumerable = function propertyIsEnumerable(key) {
      var uid = '' + key;
      return onlySymbols(uid) ? hOP.call(this, uid) && this[internalSymbol] && this[internalSymbol]['@@' + uid] : pIE.call(this, key);
    },
        setAndGetSymbol = function (uid) {
      var descriptor = {
        enumerable: false,
        configurable: true,
        get: get,
        set: function (value) {
          setDescriptor(this, uid, {
            enumerable: false,
            configurable: true,
            writable: true,
            value: value
          });
          addInternalIfNeeded(this, uid, true);
        }
      };
      defineProperty(ObjectProto, uid, descriptor);
      return source[uid] = defineProperty(Object(uid), 'constructor', sourceConstructor);
    },
        Symbol = function Symbol(description) {
      if (this && this !== G) {
        throw new TypeError('Symbol is not a constructor');
      }
      return setAndGetSymbol(prefix.concat(description || '', random, ++id));
    },
        source = create(null),
        sourceConstructor = { value: Symbol },
        sourceMap = function (uid) {
      return source[uid];
    },
        $defineProperty = function defineProp(o, key, descriptor) {
      var uid = '' + key;
      if (onlySymbols(uid)) {
        setDescriptor(o, uid, descriptor.enumerable ? copyAsNonEnumerable(descriptor) : descriptor);
        addInternalIfNeeded(o, uid, !!descriptor.enumerable);
      } else {
        defineProperty(o, key, descriptor);
      }
      return o;
    },
        $getOwnPropertySymbols = function getOwnPropertySymbols(o) {
      var cof = toString.call(o);
      o = cof === '[object String]' ? o.split('') : Object(o);
      return gOPN(o).filter(onlySymbols).map(sourceMap);
    };

    descriptor.value = $defineProperty;
    defineProperty(Object, DP, descriptor);

    descriptor.value = $getOwnPropertySymbols;
    defineProperty(Object, GOPS, descriptor);

    var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
    var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
    descriptor.value = function getOwnPropertyNames(o) {
      if (toString.call(o) === '[object Window]') {
        try {
          return originalObjectGetOwnPropertyNames(o);
        } catch (e) {
          return [].concat([], cachedWindowNames);
        }
      }
      return gOPN(o).filter(onlyNonSymbols);
    };
    defineProperty(Object, GOPN, descriptor);

    descriptor.value = function defineProperties(o, descriptors) {
      var symbols = $getOwnPropertySymbols(descriptors);
      if (symbols.length) {
        keys(descriptors).concat(symbols).forEach(function (uid) {
          if (propertyIsEnumerable.call(descriptors, uid)) {
            $defineProperty(o, uid, descriptors[uid]);
          }
        });
      } else {
        $defineProperties(o, descriptors);
      }
      return o;
    };
    defineProperty(Object, DPies, descriptor);

    descriptor.value = propertyIsEnumerable;
    defineProperty(ObjectProto, PIE, descriptor);

    descriptor.value = Symbol;
    defineProperty(G, 'Symbol', descriptor);

    descriptor.value = function (key) {
      var uid = prefix.concat(prefix, key, random);
      return uid in ObjectProto ? source[uid] : setAndGetSymbol(uid);
    };
    defineProperty(Symbol, 'for', descriptor);

    descriptor.value = function (symbol) {
      return hOP.call(source, symbol) ? symbol.slice(prefixLength * 2, -random.length) : void 0;
    };
    defineProperty(Symbol, 'keyFor', descriptor);

    descriptor.value = function getOwnPropertyDescriptor(o, key) {
      var descriptor = gOPD(o, key);
      if (descriptor && onlySymbols(key)) {
        descriptor.enumerable = propertyIsEnumerable.call(o, key);
      }
      return descriptor;
    };
    defineProperty(Object, GOPD, descriptor);

    descriptor.value = function (proto, descriptors) {
      return arguments.length === 1 ? create(proto) : createWithSymbols(proto, descriptors);
    };
    defineProperty(Object, 'create', descriptor);

    descriptor.value = function () {
      var str = toString.call(this);
      return str === '[object String]' && onlySymbols(this) ? '[object Symbol]' : str;
    };
    defineProperty(ObjectProto, 'toString', descriptor);

    try {
      setDescriptor = create(defineProperty({}, prefix, {
        get: function () {
          return defineProperty(this, prefix, { value: false })[prefix];
        }
      }))[prefix] || defineProperty;
    } catch (o_O) {
      setDescriptor = function (o, key, descriptor) {
        var protoDescriptor = gOPD(ObjectProto, key);
        delete ObjectProto[key];
        defineProperty(o, key, descriptor);
        defineProperty(ObjectProto, key, protoDescriptor);
      };
    }
  })(Object, 'getOwnPropertySymbols');

  (function (O, S) {
    var dP = O.defineProperty,
        ObjectProto = O.prototype,
        toString = ObjectProto.toString,
        toStringTag = 'toStringTag',
        descriptor;
    ['iterator', 'match', 'replace', 'search', 'split', 'hasInstance', 'isConcatSpreadable', 'unscopables', 'species', 'toPrimitive', toStringTag].forEach(function (name) {
      if (!(name in Symbol)) {
        dP(Symbol, name, { value: Symbol(name) });
        switch (name) {
          case toStringTag:
            descriptor = O.getOwnPropertyDescriptor(ObjectProto, 'toString');
            descriptor.value = function () {
              var str = toString.call(this),
                  tst = typeof this === 'undefined' || this === null ? undefined : this[Symbol.toStringTag];
              return typeof tst === 'undefined' ? str : '[object ' + tst + ']';
            };
            dP(ObjectProto, 'toString', descriptor);
            break;
        }
      }
    });
  })(Object, Symbol);

  (function (Si, AP, SP) {

    function returnThis() {
      return this;
    }

    if (!AP[Si]) AP[Si] = function () {
      var i = 0,
          self = this,
          iterator = {
        next: function next() {
          var done = self.length <= i;
          return done ? { done: done } : { done: done, value: self[i++] };
        }
      };
      iterator[Si] = returnThis;
      return iterator;
    };

    if (!SP[Si]) SP[Si] = function () {
      var fromCodePoint = String.fromCodePoint,
          self = this,
          i = 0,
          length = self.length,
          iterator = {
        next: function next() {
          var done = length <= i,
              c = done ? '' : fromCodePoint(self.codePointAt(i));
          i += c.length;
          return done ? { done: done } : { done: done, value: c };
        }
      };
      iterator[Si] = returnThis;
      return iterator;
    };
  })(Symbol.iterator, Array.prototype, String.prototype);
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  Number.isNaN = Number.isNaN || function (value) {
    return value !== value;
  };

  Number.isFinite = Number.isFinite || function (value) {
    return typeof value === "number" && isFinite(value);
  };
}

if (!String.prototype.endsWith || function () {
  try {
    return !"ab".endsWith("a", 1);
  } catch (e) {
    return true;
  }
}()) {
  String.prototype.endsWith = function (searchString, position) {
    let subjectString = this.toString();
    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
      position = subjectString.length;
    }
    position -= searchString.length;
    let lastIndex = subjectString.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
}

if (!String.prototype.startsWith || function () {
  try {
    return !"ab".startsWith("b", 1);
  } catch (e) {
    return true;
  }
}()) {
  String.prototype.startsWith = function (searchString, position) {
    position = position || 0;
    return this.substr(position, searchString.length) === searchString;
  };
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  if (!Array.from) {
    Array.from = function () {
      var toInteger = function (it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? Math.floor : Math.ceil)(it);
      };
      var toLength = function (it) {
        return it > 0 ? Math.min(toInteger(it), 0x1fffffffffffff) : 0;
      };
      var iterCall = function (iter, fn, val, index) {
        try {
          return fn(val, index);
        } catch (E) {
          if (typeof iter.return == 'function') iter.return();
          throw E;
        }
      };

      return function from(arrayLike) {
        var O = Object(arrayLike),
            C = typeof this == 'function' ? this : Array,
            aLen = arguments.length,
            mapfn = aLen > 1 ? arguments[1] : undefined,
            mapping = mapfn !== undefined,
            index = 0,
            iterFn = O[Symbol.iterator],
            length,
            result,
            step,
            iterator;
        if (mapping) mapfn = mapfn.bind(aLen > 2 ? arguments[2] : undefined);
        if (iterFn != undefined && !Array.isArray(arrayLike)) {
          for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
            result[index] = mapping ? iterCall(iterator, mapfn, step.value, index) : step.value;
          }
        } else {
          length = toLength(O.length);
          for (result = new C(length); length > index; index++) {
            result[index] = mapping ? mapfn(O[index], index) : O[index];
          }
        }
        result.length = index;
        return result;
      };
    }();
  }

  if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: function (predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return value;
          }
        }
        return undefined;
      }
    });
  }

  if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
      configurable: true,
      writable: true,
      enumerable: false,
      value: function (predicate) {
        if (this === null) {
          throw new TypeError('Array.prototype.findIndex called on null or undefined');
        }
        if (typeof predicate !== 'function') {
          throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return i;
          }
        }
        return -1;
      }
    });
  }
}

if (typeof FEATURE_NO_ES2016 === 'undefined' && !Array.prototype.includes) {
  Object.defineProperty(Array.prototype, 'includes', {
    configurable: true,
    writable: true,
    enumerable: false,
    value: function (searchElement) {
      var O = Object(this);
      var len = parseInt(O.length) || 0;
      if (len === 0) {
        return false;
      }
      var n = parseInt(arguments[1]) || 0;
      var k;
      if (n >= 0) {
        k = n;
      } else {
        k = len + n;
        if (k < 0) {
          k = 0;
        }
      }
      var currentElement;
      while (k < len) {
        currentElement = O[k];
        if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
          return true;
        }
        k++;
      }
      return false;
    }
  });
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function () {
    let needsFix = false;

    try {
      let s = Object.keys('a');
      needsFix = s.length !== 1 || s[0] !== '0';
    } catch (e) {
      needsFix = true;
    }

    if (needsFix) {
      Object.keys = function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{ toString: null }.propertyIsEnumerable('toString'),
            dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'],
            dontEnumsLength = dontEnums.length;

        return function (obj) {
          if (obj === undefined || obj === null) {
            throw TypeError(`Cannot convert undefined or null to object`);
          }

          obj = Object(obj);

          var result = [],
              prop,
              i;

          for (prop in obj) {
            if (hasOwnProperty.call(obj, prop)) {
              result.push(prop);
            }
          }

          if (hasDontEnumBug) {
            for (i = 0; i < dontEnumsLength; i++) {
              if (hasOwnProperty.call(obj, dontEnums[i])) {
                result.push(dontEnums[i]);
              }
            }
          }

          return result;
        };
      }();
    }
  })();

  (function (O) {
    if ('assign' in O) {
      return;
    }

    O.defineProperty(O, 'assign', {
      configurable: true,
      writable: true,
      value: function () {
        var gOPS = O.getOwnPropertySymbols,
            pIE = O.propertyIsEnumerable,
            filterOS = gOPS ? function (self) {
          return gOPS(self).filter(pIE, self);
        } : function () {
          return Array.prototype;
        };

        return function assign(where) {
          if (gOPS && !(where instanceof O)) {
            console.warn('problematic Symbols', where);
          }

          function set(keyOrSymbol) {
            where[keyOrSymbol] = arg[keyOrSymbol];
          }

          for (var i = 1, ii = arguments.length; i < ii; ++i) {
            var arg = arguments[i];

            if (arg === null || arg === undefined) {
              continue;
            }

            O.keys(arg).concat(filterOS(arg)).forEach(set);
          }

          return where;
        };
      }()
    });
  })(Object);

  if (!Object.is) {
    Object.is = function (x, y) {
      if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    };
  }
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  (function (global) {
    var i;

    var defineProperty = Object.defineProperty,
        is = function (a, b) {
      return a === b || a !== a && b !== b;
    };

    if (typeof WeakMap == 'undefined') {
      global.WeakMap = createCollection({
        'delete': sharedDelete,

        clear: sharedClear,

        get: sharedGet,

        has: mapHas,

        set: sharedSet
      }, true);
    }

    if (typeof Map == 'undefined' || typeof new Map().values !== 'function' || !new Map().values().next) {
      global.Map = createCollection({
        'delete': sharedDelete,

        has: mapHas,

        get: sharedGet,

        set: sharedSet,

        keys: sharedKeys,

        values: sharedValues,

        entries: mapEntries,

        forEach: sharedForEach,

        clear: sharedClear,

        [Symbol.iterator]: mapEntries
      });
    }

    if (typeof Set == 'undefined' || typeof new Set().values !== 'function' || !new Set().values().next) {
      global.Set = createCollection({
        has: setHas,

        add: sharedAdd,

        'delete': sharedDelete,

        clear: sharedClear,

        keys: sharedValues,
        values: sharedValues,

        entries: setEntries,

        forEach: sharedForEach,

        [Symbol.iterator]: sharedValues
      });
    }

    if (typeof WeakSet == 'undefined') {
      global.WeakSet = createCollection({
        'delete': sharedDelete,

        add: sharedAdd,

        clear: sharedClear,

        has: setHas
      }, true);
    }

    function createCollection(proto, objectOnly) {
      function Collection(a) {
        if (!this || this.constructor !== Collection) return new Collection(a);
        this._keys = [];
        this._values = [];
        this._itp = [];
        this.objectOnly = objectOnly;

        if (a) init.call(this, a);
      }

      if (!objectOnly) {
        defineProperty(proto, 'size', {
          get: sharedSize
        });
      }

      proto.constructor = Collection;
      Collection.prototype = proto;

      return Collection;
    }

    function init(a) {
      var i;

      if (this.add) a.forEach(this.add, this);else a.forEach(function (a) {
          this.set(a[0], a[1]);
        }, this);
    }

    function sharedDelete(key) {
      if (this.has(key)) {
        this._keys.splice(i, 1);
        this._values.splice(i, 1);

        this._itp.forEach(function (p) {
          if (i < p[0]) p[0]--;
        });
      }

      return -1 < i;
    };

    function sharedGet(key) {
      return this.has(key) ? this._values[i] : undefined;
    }

    function has(list, key) {
      if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");

      if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
      return -1 < i;
    }

    function setHas(value) {
      return has.call(this, this._values, value);
    }

    function mapHas(value) {
      return has.call(this, this._keys, value);
    }

    function sharedSet(key, value) {
      this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
      return this;
    }

    function sharedAdd(value) {
      if (!this.has(value)) this._values.push(value);
      return this;
    }

    function sharedClear() {
      (this._keys || 0).length = this._values.length = 0;
    }

    function sharedKeys() {
      return sharedIterator(this._itp, this._keys);
    }

    function sharedValues() {
      return sharedIterator(this._itp, this._values);
    }

    function mapEntries() {
      return sharedIterator(this._itp, this._keys, this._values);
    }

    function setEntries() {
      return sharedIterator(this._itp, this._values, this._values);
    }

    function sharedIterator(itp, array, array2) {
      var p = [0],
          done = false;
      itp.push(p);
      return {
        [Symbol.iterator]: function () {
          return this;
        },
        next: function () {
          var v,
              k = p[0];
          if (!done && k < array.length) {
            v = array2 ? [array[k], array2[k]] : array[k];
            p[0]++;
          } else {
            done = true;
            itp.splice(itp.indexOf(p), 1);
          }
          return { done: done, value: v };
        }
      };
    }

    function sharedSize() {
      return this._values.length;
    }

    function sharedForEach(callback, context) {
      var it = this.entries();
      for (;;) {
        var r = it.next();
        if (r.done) break;
        callback.call(context, r.value[1], r.value[0], this);
      }
    }
  })(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.PLATFORM.global);
}

if (typeof FEATURE_NO_ES2015 === 'undefined') {

  const bind = Function.prototype.bind;

  if (typeof aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.PLATFORM.global.Reflect === 'undefined') {
    aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.PLATFORM.global.Reflect = {};
  }

  if (typeof Reflect.defineProperty !== 'function') {
    Reflect.defineProperty = function (target, propertyKey, descriptor) {
      if (typeof target === 'object' ? target === null : typeof target !== 'function') {
        throw new TypeError('Reflect.defineProperty called on non-object');
      }
      try {
        Object.defineProperty(target, propertyKey, descriptor);
        return true;
      } catch (e) {
        return false;
      }
    };
  }

  if (typeof Reflect.construct !== 'function') {
    Reflect.construct = function (Target, args) {
      if (args) {
        switch (args.length) {
          case 0:
            return new Target();
          case 1:
            return new Target(args[0]);
          case 2:
            return new Target(args[0], args[1]);
          case 3:
            return new Target(args[0], args[1], args[2]);
          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        }
      }

      var a = [null];
      a.push.apply(a, args);
      return new (bind.apply(Target, a))();
    };
  }

  if (typeof Reflect.ownKeys !== 'function') {
    Reflect.ownKeys = function (o) {
      return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
    };
  }
}

if (typeof FEATURE_NO_ESNEXT === 'undefined') {

  const emptyMetadata = Object.freeze({});
  const metadataContainerKey = '__metadata__';

  if (typeof Reflect.getOwnMetadata !== 'function') {
    Reflect.getOwnMetadata = function (metadataKey, target, targetKey) {
      if (target.hasOwnProperty(metadataContainerKey)) {
        return (target[metadataContainerKey][targetKey] || emptyMetadata)[metadataKey];
      }
    };
  }

  if (typeof Reflect.defineMetadata !== 'function') {
    Reflect.defineMetadata = function (metadataKey, metadataValue, target, targetKey) {
      let metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
      let targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
      targetContainer[metadataKey] = metadataValue;
    };
  }

  if (typeof Reflect.metadata !== 'function') {
    Reflect.metadata = function (metadataKey, metadataValue) {
      return function (target, targetKey) {
        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
      };
    };
  }
}

/***/ }),

/***/ "../../node_modules/aurelia-route-recognizer/dist/es2015/aurelia-route-recognizer.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/aurelia-route-recognizer/dist/es2015/aurelia-route-recognizer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DynamicSegment: () => (/* binding */ DynamicSegment),
/* harmony export */   EpsilonSegment: () => (/* binding */ EpsilonSegment),
/* harmony export */   RouteRecognizer: () => (/* binding */ RouteRecognizer),
/* harmony export */   StarSegment: () => (/* binding */ StarSegment),
/* harmony export */   State: () => (/* binding */ State),
/* harmony export */   StaticSegment: () => (/* binding */ StaticSegment)
/* harmony export */ });
/* harmony import */ var aurelia_path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-path */ "../../node_modules/aurelia-path/dist/es2015/aurelia-path.js");


let State = class State {
  constructor(charSpec) {
    this.charSpec = charSpec;
    this.nextStates = [];
  }

  get(charSpec) {
    for (let child of this.nextStates) {
      let isEqual = child.charSpec.validChars === charSpec.validChars && child.charSpec.invalidChars === charSpec.invalidChars;

      if (isEqual) {
        return child;
      }
    }

    return undefined;
  }

  put(charSpec) {
    let state = this.get(charSpec);

    if (state) {
      return state;
    }

    state = new State(charSpec);

    this.nextStates.push(state);

    if (charSpec.repeat) {
      state.nextStates.push(state);
    }

    return state;
  }

  match(ch) {
    let nextStates = this.nextStates;
    let results = [];

    for (let i = 0, l = nextStates.length; i < l; i++) {
      let child = nextStates[i];
      let charSpec = child.charSpec;

      if (charSpec.validChars !== undefined) {
        if (charSpec.validChars.indexOf(ch) !== -1) {
          results.push(child);
        }
      } else if (charSpec.invalidChars !== undefined) {
        if (charSpec.invalidChars.indexOf(ch) === -1) {
          results.push(child);
        }
      }
    }

    return results;
  }
};

const specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];

const escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');

let StaticSegment = class StaticSegment {
  constructor(string, caseSensitive) {
    this.string = string;
    this.caseSensitive = caseSensitive;
  }

  eachChar(callback) {
    let s = this.string;
    for (let i = 0, ii = s.length; i < ii; ++i) {
      let ch = s[i];
      callback({ validChars: this.caseSensitive ? ch : ch.toUpperCase() + ch.toLowerCase() });
    }
  }

  regex() {
    return this.string.replace(escapeRegex, '\\$1');
  }

  generate() {
    return this.string;
  }
};

let DynamicSegment = class DynamicSegment {
  constructor(name, optional) {
    this.name = name;
    this.optional = optional;
  }

  eachChar(callback) {
    callback({ invalidChars: '/', repeat: true });
  }

  regex() {
    return '([^/]+)';
  }

  generate(params, consumed) {
    consumed[this.name] = true;
    return params[this.name];
  }
};

let StarSegment = class StarSegment {
  constructor(name) {
    this.name = name;
  }

  eachChar(callback) {
    callback({ invalidChars: '', repeat: true });
  }

  regex() {
    return '(.+)';
  }

  generate(params, consumed) {
    consumed[this.name] = true;
    return params[this.name];
  }
};

let EpsilonSegment = class EpsilonSegment {
  eachChar() {}

  regex() {
    return '';
  }

  generate() {
    return '';
  }
};

let RouteRecognizer = class RouteRecognizer {
  constructor() {
    this.rootState = new State();
    this.names = {};
    this.routes = new Map();
  }

  add(route) {
    if (Array.isArray(route)) {
      route.forEach(r => this.add(r));
      return undefined;
    }

    let currentState = this.rootState;
    let skippableStates = [];
    let regex = '^';
    let types = { statics: 0, dynamics: 0, stars: 0 };
    let names = [];
    let routeName = route.handler.name;
    let isEmpty = true;
    let segments = parse(route.path, names, types, route.caseSensitive);

    for (let i = 0, ii = segments.length; i < ii; i++) {
      let segment = segments[i];
      if (segment instanceof EpsilonSegment) {
        continue;
      }

      let [firstState, nextState] = addSegment(currentState, segment);

      for (let j = 0, jj = skippableStates.length; j < jj; j++) {
        skippableStates[j].nextStates.push(firstState);
      }

      if (segment.optional) {
        skippableStates.push(nextState);
        regex += `(?:/${segment.regex()})?`;
      } else {
        currentState = nextState;
        regex += `/${segment.regex()}`;
        skippableStates.length = 0;
        isEmpty = false;
      }
    }

    if (isEmpty) {
      currentState = currentState.put({ validChars: '/' });
      regex += '/?';
    }

    let handlers = [{ handler: route.handler, names: names }];

    this.routes.set(route.handler, { segments, handlers });
    if (routeName) {
      let routeNames = Array.isArray(routeName) ? routeName : [routeName];
      for (let i = 0; i < routeNames.length; i++) {
        if (!(routeNames[i] in this.names)) {
          this.names[routeNames[i]] = { segments, handlers };
        }
      }
    }

    for (let i = 0; i < skippableStates.length; i++) {
      let state = skippableStates[i];
      state.handlers = handlers;
      state.regex = new RegExp(regex + '$', route.caseSensitive ? '' : 'i');
      state.types = types;
    }

    currentState.handlers = handlers;
    currentState.regex = new RegExp(regex + '$', route.caseSensitive ? '' : 'i');
    currentState.types = types;

    return currentState;
  }

  getRoute(nameOrRoute) {
    return typeof nameOrRoute === 'string' ? this.names[nameOrRoute] : this.routes.get(nameOrRoute);
  }

  handlersFor(nameOrRoute) {
    let route = this.getRoute(nameOrRoute);
    if (!route) {
      throw new Error(`There is no route named ${nameOrRoute}`);
    }

    return [...route.handlers];
  }

  hasRoute(nameOrRoute) {
    return !!this.getRoute(nameOrRoute);
  }

  generate(nameOrRoute, params) {
    let route = this.getRoute(nameOrRoute);
    if (!route) {
      throw new Error(`There is no route named ${nameOrRoute}`);
    }

    let handler = route.handlers[0].handler;
    if (handler.generationUsesHref) {
      return handler.href;
    }

    let routeParams = Object.assign({}, params);
    let segments = route.segments;
    let consumed = {};
    let output = '';

    for (let i = 0, l = segments.length; i < l; i++) {
      let segment = segments[i];

      if (segment instanceof EpsilonSegment) {
        continue;
      }

      let segmentValue = segment.generate(routeParams, consumed);
      if (segmentValue === null || segmentValue === undefined) {
        if (!segment.optional) {
          throw new Error(`A value is required for route parameter '${segment.name}' in route '${nameOrRoute}'.`);
        }
      } else {
        output += '/';
        output += segmentValue;
      }
    }

    if (output.charAt(0) !== '/') {
      output = '/' + output;
    }

    for (let param in consumed) {
      delete routeParams[param];
    }

    let queryString = (0,aurelia_path__WEBPACK_IMPORTED_MODULE_0__.buildQueryString)(routeParams);
    output += queryString ? `?${queryString}` : '';

    return output;
  }

  recognize(path) {
    let states = [this.rootState];
    let queryParams = {};
    let isSlashDropped = false;
    let normalizedPath = path;

    let queryStart = normalizedPath.indexOf('?');
    if (queryStart !== -1) {
      let queryString = normalizedPath.substr(queryStart + 1, normalizedPath.length);
      normalizedPath = normalizedPath.substr(0, queryStart);
      queryParams = (0,aurelia_path__WEBPACK_IMPORTED_MODULE_0__.parseQueryString)(queryString);
    }

    normalizedPath = decodeURI(normalizedPath);

    if (normalizedPath.charAt(0) !== '/') {
      normalizedPath = '/' + normalizedPath;
    }

    let pathLen = normalizedPath.length;
    if (pathLen > 1 && normalizedPath.charAt(pathLen - 1) === '/') {
      normalizedPath = normalizedPath.substr(0, pathLen - 1);
      isSlashDropped = true;
    }

    for (let i = 0, l = normalizedPath.length; i < l; i++) {
      states = recognizeChar(states, normalizedPath.charAt(i));
      if (!states.length) {
        break;
      }
    }

    let solutions = [];
    for (let i = 0, l = states.length; i < l; i++) {
      if (states[i].handlers) {
        solutions.push(states[i]);
      }
    }

    states = sortSolutions(solutions);

    let state = solutions[0];
    if (state && state.handlers) {
      if (isSlashDropped && state.regex.source.slice(-5) === '(.+)$') {
        normalizedPath = normalizedPath + '/';
      }

      return findHandler(state, normalizedPath, queryParams);
    }
  }
};

let RecognizeResults = class RecognizeResults {
  constructor(queryParams) {
    this.splice = Array.prototype.splice;
    this.slice = Array.prototype.slice;
    this.push = Array.prototype.push;
    this.length = 0;
    this.queryParams = queryParams || {};
  }
};


function parse(route, names, types, caseSensitive) {
  let normalizedRoute = route;
  if (route.charAt(0) === '/') {
    normalizedRoute = route.substr(1);
  }

  let results = [];

  let splitRoute = normalizedRoute.split('/');
  for (let i = 0, ii = splitRoute.length; i < ii; ++i) {
    let segment = splitRoute[i];

    let match = segment.match(/^:([^?]+)(\?)?$/);
    if (match) {
      let [, name, optional] = match;
      if (name.indexOf('=') !== -1) {
        throw new Error(`Parameter ${name} in route ${route} has a default value, which is not supported.`);
      }
      results.push(new DynamicSegment(name, !!optional));
      names.push(name);
      types.dynamics++;
      continue;
    }

    match = segment.match(/^\*(.+)$/);
    if (match) {
      results.push(new StarSegment(match[1]));
      names.push(match[1]);
      types.stars++;
    } else if (segment === '') {
      results.push(new EpsilonSegment());
    } else {
      results.push(new StaticSegment(segment, caseSensitive));
      types.statics++;
    }
  }

  return results;
}

function sortSolutions(states) {
  return states.sort((a, b) => {
    if (a.types.stars !== b.types.stars) {
      return a.types.stars - b.types.stars;
    }

    if (a.types.stars) {
      if (a.types.statics !== b.types.statics) {
        return b.types.statics - a.types.statics;
      }
      if (a.types.dynamics !== b.types.dynamics) {
        return b.types.dynamics - a.types.dynamics;
      }
    }

    if (a.types.dynamics !== b.types.dynamics) {
      return a.types.dynamics - b.types.dynamics;
    }

    if (a.types.statics !== b.types.statics) {
      return b.types.statics - a.types.statics;
    }

    return 0;
  });
}

function recognizeChar(states, ch) {
  let nextStates = [];

  for (let i = 0, l = states.length; i < l; i++) {
    let state = states[i];
    nextStates.push(...state.match(ch));
  }

  return nextStates;
}

function findHandler(state, path, queryParams) {
  let handlers = state.handlers;
  let regex = state.regex;
  let captures = path.match(regex);
  let currentCapture = 1;
  let result = new RecognizeResults(queryParams);

  for (let i = 0, l = handlers.length; i < l; i++) {
    let handler = handlers[i];
    let names = handler.names;
    let params = {};

    for (let j = 0, m = names.length; j < m; j++) {
      params[names[j]] = captures[currentCapture++];
    }

    result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });
  }

  return result;
}

function addSegment(currentState, segment) {
  let firstState = currentState.put({ validChars: '/' });
  let nextState = firstState;
  segment.eachChar(ch => {
    nextState = nextState.put(ch);
  });

  return [firstState, nextState];
}

/***/ }),

/***/ "../../node_modules/aurelia-router/dist/es2015/aurelia-router.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/aurelia-router/dist/es2015/aurelia-router.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ActivateNextStep: () => (/* binding */ ActivateNextStep),
/* harmony export */   AppRouter: () => (/* binding */ AppRouter),
/* harmony export */   BuildNavigationPlanStep: () => (/* binding */ BuildNavigationPlanStep),
/* harmony export */   CanActivateNextStep: () => (/* binding */ CanActivateNextStep),
/* harmony export */   CanDeactivatePreviousStep: () => (/* binding */ CanDeactivatePreviousStep),
/* harmony export */   CommitChangesStep: () => (/* binding */ CommitChangesStep),
/* harmony export */   DeactivatePreviousStep: () => (/* binding */ DeactivatePreviousStep),
/* harmony export */   LoadRouteStep: () => (/* binding */ LoadRouteStep),
/* harmony export */   NavModel: () => (/* binding */ NavModel),
/* harmony export */   NavigationInstruction: () => (/* binding */ NavigationInstruction),
/* harmony export */   Pipeline: () => (/* binding */ Pipeline),
/* harmony export */   PipelineProvider: () => (/* binding */ PipelineProvider),
/* harmony export */   PipelineSlotName: () => (/* binding */ PipelineSlotName),
/* harmony export */   PipelineStatus: () => (/* binding */ PipelineStatus),
/* harmony export */   Redirect: () => (/* binding */ Redirect),
/* harmony export */   RedirectToRoute: () => (/* binding */ RedirectToRoute),
/* harmony export */   RouteLoader: () => (/* binding */ RouteLoader),
/* harmony export */   Router: () => (/* binding */ Router),
/* harmony export */   RouterConfiguration: () => (/* binding */ RouterConfiguration),
/* harmony export */   RouterEvent: () => (/* binding */ RouterEvent),
/* harmony export */   activationStrategy: () => (/* binding */ activationStrategy),
/* harmony export */   isNavigationCommand: () => (/* binding */ isNavigationCommand)
/* harmony export */ });
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");
/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-dependency-injection */ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js");
/* harmony import */ var aurelia_history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-history */ "../../node_modules/aurelia-history/dist/es2015/aurelia-history.js");
/* harmony import */ var aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-route-recognizer */ "../../node_modules/aurelia-route-recognizer/dist/es2015/aurelia-route-recognizer.js");
/* harmony import */ var aurelia_event_aggregator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-event-aggregator */ "aurelia-event-aggregator");






/**
 * Class used to represent an instruction during a navigation.
 */
class NavigationInstruction {
    constructor(init) {
        /**
         * Current built viewport plan of this nav instruction
         */
        this.plan = null;
        this.options = {};
        Object.assign(this, init);
        this.params = this.params || {};
        this.viewPortInstructions = {};
        let ancestorParams = [];
        let current = this;
        do {
            let currentParams = Object.assign({}, current.params);
            if (current.config && current.config.hasChildRouter) {
                // remove the param for the injected child route segment
                delete currentParams[current.getWildCardName()];
            }
            ancestorParams.unshift(currentParams);
            current = current.parentInstruction;
        } while (current);
        let allParams = Object.assign({}, this.queryParams, ...ancestorParams);
        this.lifecycleArgs = [allParams, this.config, this];
    }
    /**
     * Gets an array containing this instruction and all child instructions for the current navigation.
     */
    getAllInstructions() {
        let instructions = [this];
        let viewPortInstructions = this.viewPortInstructions;
        for (let key in viewPortInstructions) {
            let childInstruction = viewPortInstructions[key].childNavigationInstruction;
            if (childInstruction) {
                instructions.push(...childInstruction.getAllInstructions());
            }
        }
        return instructions;
    }
    /**
     * Gets an array containing the instruction and all child instructions for the previous navigation.
     * Previous instructions are no longer available after navigation completes.
     */
    getAllPreviousInstructions() {
        return this.getAllInstructions().map(c => c.previousInstruction).filter(c => c);
    }
    addViewPortInstruction(nameOrInitOptions, strategy, moduleId, component) {
        let viewPortInstruction;
        let viewPortName = typeof nameOrInitOptions === 'string' ? nameOrInitOptions : nameOrInitOptions.name;
        const lifecycleArgs = this.lifecycleArgs;
        const config = Object.assign({}, lifecycleArgs[1], { currentViewPort: viewPortName });
        if (typeof nameOrInitOptions === 'string') {
            viewPortInstruction = {
                name: nameOrInitOptions,
                strategy: strategy,
                moduleId: moduleId,
                component: component,
                childRouter: component.childRouter,
                lifecycleArgs: [lifecycleArgs[0], config, lifecycleArgs[2]]
            };
        }
        else {
            viewPortInstruction = {
                name: viewPortName,
                strategy: nameOrInitOptions.strategy,
                component: nameOrInitOptions.component,
                moduleId: nameOrInitOptions.moduleId,
                childRouter: nameOrInitOptions.component.childRouter,
                lifecycleArgs: [lifecycleArgs[0], config, lifecycleArgs[2]]
            };
        }
        return this.viewPortInstructions[viewPortName] = viewPortInstruction;
    }
    /**
     * Gets the name of the route pattern's wildcard parameter, if applicable.
     */
    getWildCardName() {
        // todo: potential issue, or at least unsafe typings
        let configRoute = this.config.route;
        let wildcardIndex = configRoute.lastIndexOf('*');
        return configRoute.substr(wildcardIndex + 1);
    }
    /**
     * Gets the path and query string created by filling the route
     * pattern's wildcard parameter with the matching param.
     */
    getWildcardPath() {
        let wildcardName = this.getWildCardName();
        let path = this.params[wildcardName] || '';
        let queryString = this.queryString;
        if (queryString) {
            path += '?' + queryString;
        }
        return path;
    }
    /**
     * Gets the instruction's base URL, accounting for wildcard route parameters.
     */
    getBaseUrl() {
        let $encodeURI = encodeURI;
        let fragment = decodeURI(this.fragment);
        if (fragment === '') {
            let nonEmptyRoute = this.router.routes.find(route => {
                return route.name === this.config.name &&
                    route.route !== '';
            });
            if (nonEmptyRoute) {
                fragment = nonEmptyRoute.route;
            }
        }
        if (!this.params) {
            return $encodeURI(fragment);
        }
        let wildcardName = this.getWildCardName();
        let path = this.params[wildcardName] || '';
        if (!path) {
            return $encodeURI(fragment);
        }
        return $encodeURI(fragment.substr(0, fragment.lastIndexOf(path)));
    }
    /**
     * Finalize a viewport instruction
     * @internal
     */
    _commitChanges(waitToSwap) {
        let router = this.router;
        router.currentInstruction = this;
        const previousInstruction = this.previousInstruction;
        if (previousInstruction) {
            previousInstruction.config.navModel.isActive = false;
        }
        this.config.navModel.isActive = true;
        router.refreshNavigation();
        let loads = [];
        let delaySwaps = [];
        let viewPortInstructions = this.viewPortInstructions;
        for (let viewPortName in viewPortInstructions) {
            let viewPortInstruction = viewPortInstructions[viewPortName];
            let viewPort = router.viewPorts[viewPortName];
            if (!viewPort) {
                throw new Error(`There was no router-view found in the view for ${viewPortInstruction.moduleId}.`);
            }
            let childNavInstruction = viewPortInstruction.childNavigationInstruction;
            if (viewPortInstruction.strategy === "replace" /* Replace */) {
                if (childNavInstruction && childNavInstruction.parentCatchHandler) {
                    loads.push(childNavInstruction._commitChanges(waitToSwap));
                }
                else {
                    if (waitToSwap) {
                        delaySwaps.push({ viewPort, viewPortInstruction });
                    }
                    loads.push(viewPort
                        .process(viewPortInstruction, waitToSwap)
                        .then(() => childNavInstruction
                        ? childNavInstruction._commitChanges(waitToSwap)
                        : Promise.resolve()));
                }
            }
            else {
                if (childNavInstruction) {
                    loads.push(childNavInstruction._commitChanges(waitToSwap));
                }
            }
        }
        return Promise
            .all(loads)
            .then(() => {
            delaySwaps.forEach(x => x.viewPort.swap(x.viewPortInstruction));
            return null;
        })
            .then(() => prune(this));
    }
    /**@internal */
    _updateTitle() {
        let router = this.router;
        let title = this._buildTitle(router.titleSeparator);
        if (title) {
            router.history.setTitle(title);
        }
    }
    /**@internal */
    _buildTitle(separator = ' | ') {
        let title = '';
        let childTitles = [];
        let navModelTitle = this.config.navModel.title;
        let instructionRouter = this.router;
        let viewPortInstructions = this.viewPortInstructions;
        if (navModelTitle) {
            title = instructionRouter.transformTitle(navModelTitle);
        }
        for (let viewPortName in viewPortInstructions) {
            let viewPortInstruction = viewPortInstructions[viewPortName];
            let child_nav_instruction = viewPortInstruction.childNavigationInstruction;
            if (child_nav_instruction) {
                let childTitle = child_nav_instruction._buildTitle(separator);
                if (childTitle) {
                    childTitles.push(childTitle);
                }
            }
        }
        if (childTitles.length) {
            title = childTitles.join(separator) + (title ? separator : '') + title;
        }
        if (instructionRouter.title) {
            title += (title ? separator : '') + instructionRouter.transformTitle(instructionRouter.title);
        }
        return title;
    }
}
const prune = (instruction) => {
    instruction.previousInstruction = null;
    instruction.plan = null;
};

/**
* Class for storing and interacting with a route's navigation settings.
*/
class NavModel {
    constructor(router, relativeHref) {
        /**
        * True if this nav item is currently active.
        */
        this.isActive = false;
        /**
        * The title.
        */
        this.title = null;
        /**
        * This nav item's absolute href.
        */
        this.href = null;
        /**
        * This nav item's relative href.
        */
        this.relativeHref = null;
        /**
        * Data attached to the route at configuration time.
        */
        this.settings = {};
        /**
        * The route config.
        */
        this.config = null;
        this.router = router;
        this.relativeHref = relativeHref;
    }
    /**
    * Sets the route's title and updates document.title.
    *  If the a navigation is in progress, the change will be applied
    *  to document.title when the navigation completes.
    *
    * @param title The new title.
    */
    setTitle(title) {
        this.title = title;
        if (this.isActive) {
            this.router.updateTitle();
        }
    }
}

function _normalizeAbsolutePath(path, hasPushState, absolute = false) {
    if (!hasPushState && path[0] !== '#') {
        path = '#' + path;
    }
    if (hasPushState && absolute) {
        path = path.substring(1, path.length);
    }
    return path;
}
function _createRootedPath(fragment, baseUrl, hasPushState, absolute) {
    if (isAbsoluteUrl.test(fragment)) {
        return fragment;
    }
    let path = '';
    if (baseUrl.length && baseUrl[0] !== '/') {
        path += '/';
    }
    path += baseUrl;
    if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {
        path += '/';
    }
    if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {
        path = path.substring(0, path.length - 1);
    }
    return _normalizeAbsolutePath(path + fragment, hasPushState, absolute);
}
function _resolveUrl(fragment, baseUrl, hasPushState) {
    if (isRootedPath.test(fragment)) {
        return _normalizeAbsolutePath(fragment, hasPushState);
    }
    return _createRootedPath(fragment, baseUrl, hasPushState);
}
function _ensureArrayWithSingleRoutePerConfig(config) {
    let routeConfigs = [];
    if (Array.isArray(config.route)) {
        for (let i = 0, ii = config.route.length; i < ii; ++i) {
            let current = Object.assign({}, config);
            current.route = config.route[i];
            routeConfigs.push(current);
        }
    }
    else {
        routeConfigs.push(Object.assign({}, config));
    }
    return routeConfigs;
}
const isRootedPath = /^#?\//;
const isAbsoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;

/**
 * Class used to configure a [[Router]] instance.
 *
 * @constructor
 */
class RouterConfiguration {
    constructor() {
        this.instructions = [];
        this.options = {};
        this.pipelineSteps = [];
    }
    /**
     * Adds a step to be run during the [[Router]]'s navigation pipeline.
     *
     * @param name The name of the pipeline slot to insert the step into.
     * @param step The pipeline step.
     * @chainable
     */
    addPipelineStep(name, step) {
        if (step === null || step === undefined) {
            throw new Error('Pipeline step cannot be null or undefined.');
        }
        this.pipelineSteps.push({ name, step });
        return this;
    }
    /**
     * Adds a step to be run during the [[Router]]'s authorize pipeline slot.
     *
     * @param step The pipeline step.
     * @chainable
     */
    addAuthorizeStep(step) {
        return this.addPipelineStep("authorize" /* Authorize */, step);
    }
    /**
     * Adds a step to be run during the [[Router]]'s preActivate pipeline slot.
     *
     * @param step The pipeline step.
     * @chainable
     */
    addPreActivateStep(step) {
        return this.addPipelineStep("preActivate" /* PreActivate */, step);
    }
    /**
     * Adds a step to be run during the [[Router]]'s preRender pipeline slot.
     *
     * @param step The pipeline step.
     * @chainable
     */
    addPreRenderStep(step) {
        return this.addPipelineStep("preRender" /* PreRender */, step);
    }
    /**
     * Adds a step to be run during the [[Router]]'s postRender pipeline slot.
     *
     * @param step The pipeline step.
     * @chainable
     */
    addPostRenderStep(step) {
        return this.addPipelineStep("postRender" /* PostRender */, step);
    }
    /**
     * Configures a route that will be used if there is no previous location available on navigation cancellation.
     *
     * @param fragment The URL fragment to use as the navigation destination.
     * @chainable
     */
    fallbackRoute(fragment) {
        this._fallbackRoute = fragment;
        return this;
    }
    /**
     * Maps one or more routes to be registered with the router.
     *
     * @param route The [[RouteConfig]] to map, or an array of [[RouteConfig]] to map.
     * @chainable
     */
    map(route) {
        if (Array.isArray(route)) {
            route.forEach(r => this.map(r));
            return this;
        }
        return this.mapRoute(route);
    }
    /**
     * Configures defaults to use for any view ports.
     *
     * @param viewPortConfig a view port configuration object to use as a
     *  default, of the form { viewPortName: { moduleId } }.
     * @chainable
     */
    useViewPortDefaults(viewPortConfig) {
        this.viewPortDefaults = viewPortConfig;
        return this;
    }
    /**
     * Maps a single route to be registered with the router.
     *
     * @param route The [[RouteConfig]] to map.
     * @chainable
     */
    mapRoute(config) {
        this.instructions.push(router => {
            let routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);
            let navModel;
            for (let i = 0, ii = routeConfigs.length; i < ii; ++i) {
                let routeConfig = routeConfigs[i];
                routeConfig.settings = routeConfig.settings || {};
                if (!navModel) {
                    navModel = router.createNavModel(routeConfig);
                }
                router.addRoute(routeConfig, navModel);
            }
        });
        return this;
    }
    /**
     * Registers an unknown route handler to be run when the URL fragment doesn't match any registered routes.
     *
     * @param config A string containing a moduleId to load, or a [[RouteConfig]], or a function that takes the
     *  [[NavigationInstruction]] and selects a moduleId to load.
     * @chainable
     */
    mapUnknownRoutes(config) {
        this.unknownRouteConfig = config;
        return this;
    }
    /**
     * Applies the current configuration to the specified [[Router]].
     *
     * @param router The [[Router]] to apply the configuration to.
     */
    exportToRouter(router) {
        let instructions = this.instructions;
        for (let i = 0, ii = instructions.length; i < ii; ++i) {
            instructions[i](router);
        }
        let { title, titleSeparator, unknownRouteConfig, _fallbackRoute, viewPortDefaults } = this;
        if (title) {
            router.title = title;
        }
        if (titleSeparator) {
            router.titleSeparator = titleSeparator;
        }
        if (unknownRouteConfig) {
            router.handleUnknownRoutes(unknownRouteConfig);
        }
        if (_fallbackRoute) {
            router.fallbackRoute = _fallbackRoute;
        }
        if (viewPortDefaults) {
            router.useViewPortDefaults(viewPortDefaults);
        }
        Object.assign(router.options, this.options);
        let pipelineSteps = this.pipelineSteps;
        let pipelineStepCount = pipelineSteps.length;
        if (pipelineStepCount) {
            if (!router.isRoot) {
                throw new Error('Pipeline steps can only be added to the root router');
            }
            let pipelineProvider = router.pipelineProvider;
            for (let i = 0, ii = pipelineStepCount; i < ii; ++i) {
                let { name, step } = pipelineSteps[i];
                pipelineProvider.addStep(name, step);
            }
        }
    }
}

/**
 * The primary class responsible for handling routing and navigation.
 */
class Router {
    /**
     * @param container The [[Container]] to use when child routers.
     * @param history The [[History]] implementation to delegate navigation requests to.
     */
    constructor(container, history) {
        /**
         * The parent router, or null if this instance is not a child router.
         */
        this.parent = null;
        this.options = {};
        /**
         * The defaults used when a viewport lacks specified content
         */
        this.viewPortDefaults = {};
        /**
         * Extension point to transform the document title before it is built and displayed.
         * By default, child routers delegate to the parent router, and the app router
         * returns the title unchanged.
         */
        this.transformTitle = (title) => {
            if (this.parent) {
                return this.parent.transformTitle(title);
            }
            return title;
        };
        this.container = container;
        this.history = history;
        this.reset();
    }
    /**
     * Fully resets the router's internal state. Primarily used internally by the framework when multiple calls to setRoot are made.
     * Use with caution (actually, avoid using this). Do not use this to simply change your navigation model.
     */
    reset() {
        this.viewPorts = {};
        this.routes = [];
        this.baseUrl = '';
        this.isConfigured = false;
        this.isNavigating = false;
        this.isExplicitNavigation = false;
        this.isExplicitNavigationBack = false;
        this.isNavigatingFirst = false;
        this.isNavigatingNew = false;
        this.isNavigatingRefresh = false;
        this.isNavigatingForward = false;
        this.isNavigatingBack = false;
        this.couldDeactivate = false;
        this.navigation = [];
        this.currentInstruction = null;
        this.viewPortDefaults = {};
        this._fallbackOrder = 100;
        this._recognizer = new aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_3__.RouteRecognizer();
        this._childRecognizer = new aurelia_route_recognizer__WEBPACK_IMPORTED_MODULE_3__.RouteRecognizer();
        this._configuredPromise = new Promise(resolve => {
            this._resolveConfiguredPromise = resolve;
        });
    }
    /**
     * Gets a value indicating whether or not this [[Router]] is the root in the router tree. I.e., it has no parent.
     */
    get isRoot() {
        return !this.parent;
    }
    /**
     * Registers a viewPort to be used as a rendering target for activated routes.
     *
     * @param viewPort The viewPort.
     * @param name The name of the viewPort. 'default' if unspecified.
     */
    registerViewPort(viewPort, name) {
        name = name || 'default';
        this.viewPorts[name] = viewPort;
    }
    /**
     * Returns a Promise that resolves when the router is configured.
     */
    ensureConfigured() {
        return this._configuredPromise;
    }
    /**
     * Configures the router.
     *
     * @param callbackOrConfig The [[RouterConfiguration]] or a callback that takes a [[RouterConfiguration]].
     */
    configure(callbackOrConfig) {
        this.isConfigured = true;
        let result = callbackOrConfig;
        let config;
        if (typeof callbackOrConfig === 'function') {
            config = new RouterConfiguration();
            result = callbackOrConfig(config);
        }
        return Promise
            .resolve(result)
            .then((c) => {
            if (c && c.exportToRouter) {
                config = c;
            }
            config.exportToRouter(this);
            this.isConfigured = true;
            this._resolveConfiguredPromise();
        });
    }
    /**
     * Navigates to a new location.
     *
     * @param fragment The URL fragment to use as the navigation destination.
     * @param options The navigation options.
     */
    navigate(fragment, options) {
        if (!this.isConfigured && this.parent) {
            return this.parent.navigate(fragment, options);
        }
        this.isExplicitNavigation = true;
        return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);
    }
    /**
     * Navigates to a new location corresponding to the route and params specified. Equivallent to [[Router.generate]] followed
     * by [[Router.navigate]].
     *
     * @param route The name of the route to use when generating the navigation location.
     * @param params The route parameters to be used when populating the route pattern.
     * @param options The navigation options.
     */
    navigateToRoute(route, params, options) {
        let path = this.generate(route, params);
        return this.navigate(path, options);
    }
    /**
     * Navigates back to the most recent location in history.
     */
    navigateBack() {
        this.isExplicitNavigationBack = true;
        this.history.navigateBack();
    }
    /**
     * Creates a child router of the current router.
     *
     * @param container The [[Container]] to provide to the child router. Uses the current [[Router]]'s [[Container]] if unspecified.
     * @returns {Router} The new child Router.
     */
    createChild(container) {
        let childRouter = new Router(container || this.container.createChild(), this.history);
        childRouter.parent = this;
        return childRouter;
    }
    /**
     * Generates a URL fragment matching the specified route pattern.
     *
     * @param name The name of the route whose pattern should be used to generate the fragment.
     * @param params The route params to be used to populate the route pattern.
     * @param options If options.absolute = true, then absolute url will be generated; otherwise, it will be relative url.
     * @returns {string} A string containing the generated URL fragment.
     */
    generate(nameOrRoute, params = {}, options = {}) {
        // A child recognizer generates routes for potential child routes. Any potential child route is added
        // to the childRoute property of params for the childRouter to recognize. When generating routes, we
        // use the childRecognizer when childRoute params are available to generate a child router enabled route.
        let recognizer = 'childRoute' in params ? this._childRecognizer : this._recognizer;
        let hasRoute = recognizer.hasRoute(nameOrRoute);
        if (!hasRoute) {
            if (this.parent) {
                return this.parent.generate(nameOrRoute, params, options);
            }
            throw new Error(`A route with name '${nameOrRoute}' could not be found. Check that \`name: '${nameOrRoute}'\` was specified in the route's config.`);
        }
        let path = recognizer.generate(nameOrRoute, params);
        let rootedPath = _createRootedPath(path, this.baseUrl, this.history._hasPushState, options.absolute);
        return options.absolute ? `${this.history.getAbsoluteRoot()}${rootedPath}` : rootedPath;
    }
    /**
     * Creates a [[NavModel]] for the specified route config.
     *
     * @param config The route config.
     */
    createNavModel(config) {
        let navModel = new NavModel(this, 'href' in config
            ? config.href
            // potential error when config.route is a string[] ?
            : config.route);
        navModel.title = config.title;
        navModel.order = config.nav;
        navModel.href = config.href;
        navModel.settings = config.settings;
        navModel.config = config;
        return navModel;
    }
    /**
     * Registers a new route with the router.
     *
     * @param config The [[RouteConfig]].
     * @param navModel The [[NavModel]] to use for the route. May be omitted for single-pattern routes.
     */
    addRoute(config, navModel) {
        if (Array.isArray(config.route)) {
            let routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);
            // the following is wrong. todo: fix this after TS refactoring release
            routeConfigs.forEach(this.addRoute.bind(this));
            return;
        }
        validateRouteConfig(config);
        if (!('viewPorts' in config) && !config.navigationStrategy) {
            config.viewPorts = {
                'default': {
                    moduleId: config.moduleId,
                    view: config.view
                }
            };
        }
        if (!navModel) {
            navModel = this.createNavModel(config);
        }
        this.routes.push(config);
        let path = config.route;
        if (path.charAt(0) === '/') {
            path = path.substr(1);
        }
        let caseSensitive = config.caseSensitive === true;
        let state = this._recognizer.add({
            path: path,
            handler: config,
            caseSensitive: caseSensitive
        });
        if (path) {
            let settings = config.settings;
            delete config.settings;
            let withChild = JSON.parse(JSON.stringify(config));
            config.settings = settings;
            withChild.route = `${path}/*childRoute`;
            withChild.hasChildRouter = true;
            this._childRecognizer.add({
                path: withChild.route,
                handler: withChild,
                caseSensitive: caseSensitive
            });
            withChild.navModel = navModel;
            withChild.settings = config.settings;
            withChild.navigationStrategy = config.navigationStrategy;
        }
        config.navModel = navModel;
        let navigation = this.navigation;
        if ((navModel.order || navModel.order === 0) && navigation.indexOf(navModel) === -1) {
            if ((!navModel.href && navModel.href !== '') && (state.types.dynamics || state.types.stars)) {
                throw new Error('Invalid route config for "' + config.route + '" : dynamic routes must specify an "href:" to be included in the navigation model.');
            }
            if (typeof navModel.order !== 'number') {
                navModel.order = ++this._fallbackOrder;
            }
            navigation.push(navModel);
            // this is a potential error / inconsistency between browsers
            //
            // MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
            // If compareFunction(a, b) returns 0, leave a and b unchanged with respect to each other,
            // but sorted with respect to all different elements.
            // Note: the ECMAscript standard does not guarantee this behaviour,
            // and thus not all browsers (e.g. Mozilla versions dating back to at least 2003) respect this.
            navigation.sort((a, b) => a.order - b.order);
        }
    }
    /**
     * Gets a value indicating whether or not this [[Router]] or one of its ancestors has a route registered with the specified name.
     *
     * @param name The name of the route to check.
     */
    hasRoute(name) {
        return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));
    }
    /**
     * Gets a value indicating whether or not this [[Router]] has a route registered with the specified name.
     *
     * @param name The name of the route to check.
     */
    hasOwnRoute(name) {
        return this._recognizer.hasRoute(name);
    }
    /**
     * Register a handler to use when the incoming URL fragment doesn't match any registered routes.
     *
     * @param config The moduleId, or a function that selects the moduleId, or a [[RouteConfig]].
     */
    handleUnknownRoutes(config) {
        if (!config) {
            throw new Error('Invalid unknown route handler');
        }
        this.catchAllHandler = instruction => {
            return this
                ._createRouteConfig(config, instruction)
                .then(c => {
                instruction.config = c;
                return instruction;
            });
        };
    }
    /**
     * Updates the document title using the current navigation instruction.
     */
    updateTitle() {
        let parentRouter = this.parent;
        if (parentRouter) {
            return parentRouter.updateTitle();
        }
        let currentInstruction = this.currentInstruction;
        if (currentInstruction) {
            currentInstruction._updateTitle();
        }
        return undefined;
    }
    /**
     * Updates the navigation routes with hrefs relative to the current location.
     * Note: This method will likely move to a plugin in a future release.
     */
    refreshNavigation() {
        let nav = this.navigation;
        for (let i = 0, length = nav.length; i < length; i++) {
            let current = nav[i];
            if (!current.config.href) {
                current.href = _createRootedPath(current.relativeHref, this.baseUrl, this.history._hasPushState);
            }
            else {
                current.href = _normalizeAbsolutePath(current.config.href, this.history._hasPushState);
            }
        }
    }
    /**
     * Sets the default configuration for the view ports. This specifies how to
     *  populate a view port for which no module is specified. The default is
     *  an empty view/view-model pair.
     */
    useViewPortDefaults($viewPortDefaults) {
        // a workaround to have strong typings while not requiring to expose interface ViewPortInstruction
        let viewPortDefaults = $viewPortDefaults;
        for (let viewPortName in viewPortDefaults) {
            let viewPortConfig = viewPortDefaults[viewPortName];
            this.viewPortDefaults[viewPortName] = {
                moduleId: viewPortConfig.moduleId
            };
        }
    }
    /**@internal */
    _refreshBaseUrl() {
        let parentRouter = this.parent;
        if (parentRouter) {
            this.baseUrl = generateBaseUrl(parentRouter, parentRouter.currentInstruction);
        }
    }
    /**@internal */
    _createNavigationInstruction(url = '', parentInstruction = null) {
        let fragment = url;
        let queryString = '';
        let queryIndex = url.indexOf('?');
        if (queryIndex !== -1) {
            fragment = url.substr(0, queryIndex);
            queryString = url.substr(queryIndex + 1);
        }
        let urlRecognizationResults = this._recognizer.recognize(url);
        if (!urlRecognizationResults || !urlRecognizationResults.length) {
            urlRecognizationResults = this._childRecognizer.recognize(url);
        }
        let instructionInit = {
            fragment,
            queryString,
            config: null,
            parentInstruction,
            previousInstruction: this.currentInstruction,
            router: this,
            options: {
                compareQueryParams: this.options.compareQueryParams
            }
        };
        let result;
        if (urlRecognizationResults && urlRecognizationResults.length) {
            let first = urlRecognizationResults[0];
            let instruction = new NavigationInstruction(Object.assign({}, instructionInit, {
                params: first.params,
                queryParams: first.queryParams || urlRecognizationResults.queryParams,
                config: first.config || first.handler
            }));
            if (typeof first.handler === 'function') {
                result = evaluateNavigationStrategy(instruction, first.handler, first);
            }
            else if (first.handler && typeof first.handler.navigationStrategy === 'function') {
                result = evaluateNavigationStrategy(instruction, first.handler.navigationStrategy, first.handler);
            }
            else {
                result = Promise.resolve(instruction);
            }
        }
        else if (this.catchAllHandler) {
            let instruction = new NavigationInstruction(Object.assign({}, instructionInit, {
                params: { path: fragment },
                queryParams: urlRecognizationResults ? urlRecognizationResults.queryParams : {},
                config: null // config will be created by the catchAllHandler
            }));
            result = evaluateNavigationStrategy(instruction, this.catchAllHandler);
        }
        else if (this.parent) {
            let router = this._parentCatchAllHandler(this.parent);
            if (router) {
                let newParentInstruction = this._findParentInstructionFromRouter(router, parentInstruction);
                let instruction = new NavigationInstruction(Object.assign({}, instructionInit, {
                    params: { path: fragment },
                    queryParams: urlRecognizationResults ? urlRecognizationResults.queryParams : {},
                    router: router,
                    parentInstruction: newParentInstruction,
                    parentCatchHandler: true,
                    config: null // config will be created by the chained parent catchAllHandler
                }));
                result = evaluateNavigationStrategy(instruction, router.catchAllHandler);
            }
        }
        if (result && parentInstruction) {
            this.baseUrl = generateBaseUrl(this.parent, parentInstruction);
        }
        return result || Promise.reject(new Error(`Route not found: ${url}`));
    }
    /**@internal */
    _findParentInstructionFromRouter(router, instruction) {
        if (instruction.router === router) {
            instruction.fragment = router.baseUrl; // need to change the fragment in case of a redirect instead of moduleId
            return instruction;
        }
        else if (instruction.parentInstruction) {
            return this._findParentInstructionFromRouter(router, instruction.parentInstruction);
        }
        return undefined;
    }
    /**@internal */
    _parentCatchAllHandler(router) {
        if (router.catchAllHandler) {
            return router;
        }
        else if (router.parent) {
            return this._parentCatchAllHandler(router.parent);
        }
        return false;
    }
    /**
     * @internal
     */
    _createRouteConfig(config, instruction) {
        return Promise
            .resolve(config)
            .then((c) => {
            if (typeof c === 'string') {
                return { moduleId: c };
            }
            else if (typeof c === 'function') {
                return c(instruction);
            }
            return c;
        })
            // typing here could be either RouteConfig or RedirectConfig
            // but temporarily treat both as RouteConfig
            // todo: improve typings precision
            .then((c) => typeof c === 'string' ? { moduleId: c } : c)
            .then((c) => {
            c.route = instruction.params.path;
            validateRouteConfig(c);
            if (!c.navModel) {
                c.navModel = this.createNavModel(c);
            }
            return c;
        });
    }
}
/* @internal exported for unit testing */
const generateBaseUrl = (router, instruction) => {
    return `${router.baseUrl || ''}${instruction.getBaseUrl() || ''}`;
};
/* @internal exported for unit testing */
const validateRouteConfig = (config) => {
    if (typeof config !== 'object') {
        throw new Error('Invalid Route Config');
    }
    if (typeof config.route !== 'string') {
        let name = config.name || '(no name)';
        throw new Error('Invalid Route Config for "' + name + '": You must specify a "route:" pattern.');
    }
    if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {
        throw new Error('Invalid Route Config for "' + config.route + '": You must specify a "moduleId:", "redirect:", "navigationStrategy:", or "viewPorts:".');
    }
};
/* @internal exported for unit testing */
const evaluateNavigationStrategy = (instruction, evaluator, context) => {
    return Promise
        .resolve(evaluator.call(context, instruction))
        .then(() => {
        if (!('viewPorts' in instruction.config)) {
            instruction.config.viewPorts = {
                'default': {
                    moduleId: instruction.config.moduleId
                }
            };
        }
        return instruction;
    });
};

/**@internal exported for unit testing */
const createNextFn = (instruction, steps) => {
    let index = -1;
    const next = function () {
        index++;
        if (index < steps.length) {
            let currentStep = steps[index];
            try {
                return currentStep(instruction, next);
            }
            catch (e) {
                return next.reject(e);
            }
        }
        else {
            return next.complete();
        }
    };
    next.complete = createCompletionHandler(next, "completed" /* Completed */);
    next.cancel = createCompletionHandler(next, "canceled" /* Canceled */);
    next.reject = createCompletionHandler(next, "rejected" /* Rejected */);
    return next;
};
/**@internal exported for unit testing */
const createCompletionHandler = (next, status) => {
    return (output) => Promise
        .resolve({
        status,
        output,
        completed: status === "completed" /* Completed */
    });
};

/**
 * The class responsible for managing and processing the navigation pipeline.
 */
class Pipeline {
    constructor() {
        /**
         * The pipeline steps. And steps added via addStep will be converted to a function
         * The actualy running functions with correct step contexts of this pipeline
         */
        this.steps = [];
    }
    /**
     * Adds a step to the pipeline.
     *
     * @param step The pipeline step.
     */
    addStep(step) {
        let run;
        if (typeof step === 'function') {
            run = step;
        }
        else if (typeof step.getSteps === 'function') {
            // getSteps is to enable support open slots
            // where devs can add multiple steps into the same slot name
            let steps = step.getSteps();
            for (let i = 0, l = steps.length; i < l; i++) {
                this.addStep(steps[i]);
            }
            return this;
        }
        else {
            run = step.run.bind(step);
        }
        this.steps.push(run);
        return this;
    }
    /**
     * Runs the pipeline.
     *
     * @param instruction The navigation instruction to process.
     */
    run(instruction) {
        const nextFn = createNextFn(instruction, this.steps);
        return nextFn();
    }
}

/**
* Determines if the provided object is a navigation command.
* A navigation command is anything with a navigate method.
*
* @param obj The object to check.
*/
function isNavigationCommand(obj) {
    return obj && typeof obj.navigate === 'function';
}
/**
* Used during the activation lifecycle to cause a redirect.
*/
class Redirect {
    /**
     * @param url The URL fragment to use as the navigation destination.
     * @param options The navigation options.
     */
    constructor(url, options = {}) {
        this.url = url;
        this.options = Object.assign({ trigger: true, replace: true }, options);
        this.shouldContinueProcessing = false;
    }
    /**
     * Called by the activation system to set the child router.
     *
     * @param router The router.
     */
    setRouter(router) {
        this.router = router;
    }
    /**
     * Called by the navigation pipeline to navigate.
     *
     * @param appRouter The router to be redirected.
     */
    navigate(appRouter) {
        let navigatingRouter = this.options.useAppRouter ? appRouter : (this.router || appRouter);
        navigatingRouter.navigate(this.url, this.options);
    }
}
/**
 * Used during the activation lifecycle to cause a redirect to a named route.
 */
class RedirectToRoute {
    /**
     * @param route The name of the route.
     * @param params The parameters to be sent to the activation method.
     * @param options The options to use for navigation.
     */
    constructor(route, params = {}, options = {}) {
        this.route = route;
        this.params = params;
        this.options = Object.assign({ trigger: true, replace: true }, options);
        this.shouldContinueProcessing = false;
    }
    /**
     * Called by the activation system to set the child router.
     *
     * @param router The router.
     */
    setRouter(router) {
        this.router = router;
    }
    /**
     * Called by the navigation pipeline to navigate.
     *
     * @param appRouter The router to be redirected.
     */
    navigate(appRouter) {
        let navigatingRouter = this.options.useAppRouter ? appRouter : (this.router || appRouter);
        navigatingRouter.navigateToRoute(this.route, this.params, this.options);
    }
}

/**
 * @internal exported for unit testing
 */
function _buildNavigationPlan(instruction, forceLifecycleMinimum) {
    let config = instruction.config;
    if ('redirect' in config) {
        return buildRedirectPlan(instruction);
    }
    const prevInstruction = instruction.previousInstruction;
    const defaultViewPortConfigs = instruction.router.viewPortDefaults;
    if (prevInstruction) {
        return buildTransitionPlans(instruction, prevInstruction, defaultViewPortConfigs, forceLifecycleMinimum);
    }
    // first navigation, only need to prepare a few information for each viewport plan
    const viewPortPlans = {};
    let viewPortConfigs = config.viewPorts;
    for (let viewPortName in viewPortConfigs) {
        let viewPortConfig = viewPortConfigs[viewPortName];
        if (viewPortConfig.moduleId === null && viewPortName in defaultViewPortConfigs) {
            viewPortConfig = defaultViewPortConfigs[viewPortName];
        }
        viewPortPlans[viewPortName] = {
            name: viewPortName,
            strategy: "replace" /* Replace */,
            config: viewPortConfig
        };
    }
    return Promise.resolve(viewPortPlans);
}
/**
 * Build redirect plan based on config of a navigation instruction
 * @internal exported for unit testing
 */
const buildRedirectPlan = (instruction) => {
    const config = instruction.config;
    const router = instruction.router;
    return router
        ._createNavigationInstruction(config.redirect)
        .then(redirectInstruction => {
        const params = {};
        const originalInstructionParams = instruction.params;
        const redirectInstructionParams = redirectInstruction.params;
        for (let key in redirectInstructionParams) {
            // If the param on the redirect points to another param, e.g. { route: first/:this, redirect: second/:this }
            let val = redirectInstructionParams[key];
            if (typeof val === 'string' && val[0] === ':') {
                val = val.slice(1);
                // And if that param is found on the original instruction then use it
                if (val in originalInstructionParams) {
                    params[key] = originalInstructionParams[val];
                }
            }
            else {
                params[key] = redirectInstructionParams[key];
            }
        }
        let redirectLocation = router.generate(redirectInstruction.config, params, instruction.options);
        // Special handling for child routes
        for (let key in originalInstructionParams) {
            redirectLocation = redirectLocation.replace(`:${key}`, originalInstructionParams[key]);
        }
        let queryString = instruction.queryString;
        if (queryString) {
            redirectLocation += '?' + queryString;
        }
        return Promise.resolve(new Redirect(redirectLocation));
    });
};
/**
 * @param viewPortPlans the Plan record that holds information about built plans
 * @internal exported for unit testing
 */
const buildTransitionPlans = (currentInstruction, previousInstruction, defaultViewPortConfigs, forceLifecycleMinimum) => {
    let viewPortPlans = {};
    let newInstructionConfig = currentInstruction.config;
    let hasNewParams = hasDifferentParameterValues(previousInstruction, currentInstruction);
    let pending = [];
    let previousViewPortInstructions = previousInstruction.viewPortInstructions;
    for (let viewPortName in previousViewPortInstructions) {
        const prevViewPortInstruction = previousViewPortInstructions[viewPortName];
        const prevViewPortComponent = prevViewPortInstruction.component;
        const newInstructionViewPortConfigs = newInstructionConfig.viewPorts;
        // if this is invoked on a viewport without any changes, based on new url,
        // newViewPortConfig will be the existing viewport instruction
        let nextViewPortConfig = viewPortName in newInstructionViewPortConfigs
            ? newInstructionViewPortConfigs[viewPortName]
            : prevViewPortInstruction;
        if (nextViewPortConfig.moduleId === null && viewPortName in defaultViewPortConfigs) {
            nextViewPortConfig = defaultViewPortConfigs[viewPortName];
        }
        const viewPortActivationStrategy = determineActivationStrategy(currentInstruction, prevViewPortInstruction, nextViewPortConfig, hasNewParams, forceLifecycleMinimum);
        const viewPortPlan = viewPortPlans[viewPortName] = {
            name: viewPortName,
            // ViewPortInstruction can quack like a RouteConfig
            config: nextViewPortConfig,
            prevComponent: prevViewPortComponent,
            prevModuleId: prevViewPortInstruction.moduleId,
            strategy: viewPortActivationStrategy
        };
        // recursively build nav plans for all existing child routers/viewports of this viewport
        // this is possible because existing child viewports and routers already have necessary information
        // to process the wildcard path from parent instruction
        if (viewPortActivationStrategy !== "replace" /* Replace */ && prevViewPortInstruction.childRouter) {
            const path = currentInstruction.getWildcardPath();
            const task = prevViewPortInstruction
                .childRouter
                ._createNavigationInstruction(path, currentInstruction)
                .then((childInstruction) => {
                viewPortPlan.childNavigationInstruction = childInstruction;
                return _buildNavigationPlan(childInstruction, 
                // is it safe to assume viewPortPlan has not been changed from previous assignment?
                // if so, can just use local variable viewPortPlanStrategy
                // there could be user code modifying viewport plan during _createNavigationInstruction?
                viewPortPlan.strategy === "invoke-lifecycle" /* InvokeLifecycle */)
                    .then(childPlan => {
                    if (childPlan instanceof Redirect) {
                        return Promise.reject(childPlan);
                    }
                    childInstruction.plan = childPlan;
                    // for bluebird ?
                    return null;
                });
            });
            pending.push(task);
        }
    }
    return Promise.all(pending).then(() => viewPortPlans);
};
/**
 * @param newViewPortConfig if this is invoked on a viewport without any changes, based on new url, newViewPortConfig will be the existing viewport instruction
 * @internal exported for unit testing
 */
const determineActivationStrategy = (currentNavInstruction, prevViewPortInstruction, newViewPortConfig, 
// indicates whether there is difference between old and new url params
hasNewParams, forceLifecycleMinimum) => {
    let newInstructionConfig = currentNavInstruction.config;
    let prevViewPortViewModel = prevViewPortInstruction.component.viewModel;
    let viewPortPlanStrategy;
    if (prevViewPortInstruction.moduleId !== newViewPortConfig.moduleId) {
        viewPortPlanStrategy = "replace" /* Replace */;
    }
    else if ('determineActivationStrategy' in prevViewPortViewModel) {
        viewPortPlanStrategy = prevViewPortViewModel.determineActivationStrategy(...currentNavInstruction.lifecycleArgs);
    }
    else if (newInstructionConfig.activationStrategy) {
        viewPortPlanStrategy = newInstructionConfig.activationStrategy;
    }
    else if (hasNewParams || forceLifecycleMinimum) {
        viewPortPlanStrategy = "invoke-lifecycle" /* InvokeLifecycle */;
    }
    else {
        viewPortPlanStrategy = "no-change" /* NoChange */;
    }
    return viewPortPlanStrategy;
};
/**@internal exported for unit testing */
const hasDifferentParameterValues = (prev, next) => {
    let prevParams = prev.params;
    let nextParams = next.params;
    let nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;
    for (let key in nextParams) {
        if (key === nextWildCardName) {
            continue;
        }
        if (prevParams[key] !== nextParams[key]) {
            return true;
        }
    }
    for (let key in prevParams) {
        if (key === nextWildCardName) {
            continue;
        }
        if (prevParams[key] !== nextParams[key]) {
            return true;
        }
    }
    if (!next.options.compareQueryParams) {
        return false;
    }
    let prevQueryParams = prev.queryParams;
    let nextQueryParams = next.queryParams;
    for (let key in nextQueryParams) {
        if (prevQueryParams[key] !== nextQueryParams[key]) {
            return true;
        }
    }
    for (let key in prevQueryParams) {
        if (prevQueryParams[key] !== nextQueryParams[key]) {
            return true;
        }
    }
    return false;
};

/**
 * Transform a navigation instruction into viewport plan record object,
 * or a redirect request if user viewmodel demands
 */
class BuildNavigationPlanStep {
    run(navigationInstruction, next) {
        return _buildNavigationPlan(navigationInstruction)
            .then(plan => {
            if (plan instanceof Redirect) {
                return next.cancel(plan);
            }
            navigationInstruction.plan = plan;
            return next();
        })
            .catch(next.cancel);
    }
}

/**
 * @internal Exported for unit testing
 */
const loadNewRoute = (routeLoader, navigationInstruction) => {
    let loadingPlans = determineLoadingPlans(navigationInstruction);
    let loadPromises = loadingPlans.map((loadingPlan) => loadRoute(routeLoader, loadingPlan.navigationInstruction, loadingPlan.viewPortPlan));
    return Promise.all(loadPromises);
};
/**
 * @internal Exported for unit testing
 */
const determineLoadingPlans = (navigationInstruction, loadingPlans = []) => {
    let viewPortPlans = navigationInstruction.plan;
    for (let viewPortName in viewPortPlans) {
        let viewPortPlan = viewPortPlans[viewPortName];
        let childNavInstruction = viewPortPlan.childNavigationInstruction;
        if (viewPortPlan.strategy === "replace" /* Replace */) {
            loadingPlans.push({ viewPortPlan, navigationInstruction });
            if (childNavInstruction) {
                determineLoadingPlans(childNavInstruction, loadingPlans);
            }
        }
        else {
            let viewPortInstruction = navigationInstruction.addViewPortInstruction({
                name: viewPortName,
                strategy: viewPortPlan.strategy,
                moduleId: viewPortPlan.prevModuleId,
                component: viewPortPlan.prevComponent
            });
            if (childNavInstruction) {
                viewPortInstruction.childNavigationInstruction = childNavInstruction;
                determineLoadingPlans(childNavInstruction, loadingPlans);
            }
        }
    }
    return loadingPlans;
};
/**
 * @internal Exported for unit testing
 */
const loadRoute = (routeLoader, navigationInstruction, viewPortPlan) => {
    let planConfig = viewPortPlan.config;
    let moduleId = planConfig ? planConfig.moduleId : null;
    return loadComponent(routeLoader, navigationInstruction, planConfig)
        .then((component) => {
        let viewPortInstruction = navigationInstruction.addViewPortInstruction({
            name: viewPortPlan.name,
            strategy: viewPortPlan.strategy,
            moduleId: moduleId,
            component: component
        });
        let childRouter = component.childRouter;
        if (childRouter) {
            let path = navigationInstruction.getWildcardPath();
            return childRouter
                ._createNavigationInstruction(path, navigationInstruction)
                .then((childInstruction) => {
                viewPortPlan.childNavigationInstruction = childInstruction;
                return _buildNavigationPlan(childInstruction)
                    .then((childPlan) => {
                    if (childPlan instanceof Redirect) {
                        return Promise.reject(childPlan);
                    }
                    childInstruction.plan = childPlan;
                    viewPortInstruction.childNavigationInstruction = childInstruction;
                    return loadNewRoute(routeLoader, childInstruction);
                });
            });
        }
        // ts complains without this, though they are same
        return void 0;
    });
};
/**
 * Load a routed-component based on navigation instruction and route config
 * @internal exported for unit testing only
 */
const loadComponent = (routeLoader, navigationInstruction, config) => {
    let router = navigationInstruction.router;
    let lifecycleArgs = navigationInstruction.lifecycleArgs;
    return Promise.resolve()
        .then(() => routeLoader.loadRoute(router, config, navigationInstruction))
        .then(
    /**
     * @param component an object carrying information about loaded route
     * typically contains information about view model, childContainer, view and router
     */
    (component) => {
        let { viewModel, childContainer } = component;
        component.router = router;
        component.config = config;
        if ('configureRouter' in viewModel) {
            let childRouter = childContainer.getChildRouter();
            component.childRouter = childRouter;
            return childRouter
                .configure(c => viewModel.configureRouter(c, childRouter, lifecycleArgs[0], lifecycleArgs[1], lifecycleArgs[2]))
                .then(() => component);
        }
        return component;
    });
};

/**
 * Abstract class that is responsible for loading view / view model from a route config
 * The default implementation can be found in `aurelia-templating-router`
 */
class RouteLoader {
    /**
     * Load a route config based on its viewmodel / view configuration
     */
    // return typing: return typings used to be never
    // as it was a throw. Changing it to Promise<any> should not cause any issues
    loadRoute(router, config, navigationInstruction) {
        throw new Error('Route loaders must implement "loadRoute(router, config, navigationInstruction)".');
    }
}

/**
 * A pipeline step responsible for loading a route config of a navigation instruction
 */
class LoadRouteStep {
    /**@internal */
    static inject() { return [RouteLoader]; }
    constructor(routeLoader) {
        this.routeLoader = routeLoader;
    }
    /**
     * Run the internal to load route config of a navigation instruction to prepare for next steps in the pipeline
     */
    run(navigationInstruction, next) {
        return loadNewRoute(this.routeLoader, navigationInstruction)
            .then(next, next.cancel);
    }
}

/**
 * A pipeline step for instructing a piepline to commit changes on a navigation instruction
 */
class CommitChangesStep {
    run(navigationInstruction, next) {
        return navigationInstruction
            ._commitChanges(/*wait to swap?*/ true)
            .then(() => {
            navigationInstruction._updateTitle();
            return next();
        });
    }
}

/**
 * An optional interface describing the available activation strategies.
 * @internal Used internally.
 */
var InternalActivationStrategy;
(function (InternalActivationStrategy) {
    /**
     * Reuse the existing view model, without invoking Router lifecycle hooks.
     */
    InternalActivationStrategy["NoChange"] = "no-change";
    /**
     * Reuse the existing view model, invoking Router lifecycle hooks.
     */
    InternalActivationStrategy["InvokeLifecycle"] = "invoke-lifecycle";
    /**
     * Replace the existing view model, invoking Router lifecycle hooks.
     */
    InternalActivationStrategy["Replace"] = "replace";
})(InternalActivationStrategy || (InternalActivationStrategy = {}));
/**
 * The strategy to use when activating modules during navigation.
 */
// kept for compat reason
const activationStrategy = {
    noChange: "no-change" /* NoChange */,
    invokeLifecycle: "invoke-lifecycle" /* InvokeLifecycle */,
    replace: "replace" /* Replace */
};

/**
 * Recursively find list of deactivate-able view models
 * and invoke the either 'canDeactivate' or 'deactivate' on each
 * @internal exported for unit testing
 */
const processDeactivatable = (navigationInstruction, callbackName, next, ignoreResult) => {
    let plan = navigationInstruction.plan;
    let infos = findDeactivatable(plan, callbackName);
    let i = infos.length; // query from inside out
    function inspect(val) {
        if (ignoreResult || shouldContinue(val)) {
            return iterate();
        }
        return next.cancel(val);
    }
    function iterate() {
        if (i--) {
            try {
                let viewModel = infos[i];
                let result = viewModel[callbackName](navigationInstruction);
                return processPotential(result, inspect, next.cancel);
            }
            catch (error) {
                return next.cancel(error);
            }
        }
        navigationInstruction.router.couldDeactivate = true;
        return next();
    }
    return iterate();
};
/**
 * Recursively find and returns a list of deactivate-able view models
 * @internal exported for unit testing
 */
const findDeactivatable = (plan, callbackName, list = []) => {
    for (let viewPortName in plan) {
        let viewPortPlan = plan[viewPortName];
        let prevComponent = viewPortPlan.prevComponent;
        if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace)
            && prevComponent) {
            let viewModel = prevComponent.viewModel;
            if (callbackName in viewModel) {
                list.push(viewModel);
            }
        }
        if (viewPortPlan.strategy === activationStrategy.replace && prevComponent) {
            addPreviousDeactivatable(prevComponent, callbackName, list);
        }
        else if (viewPortPlan.childNavigationInstruction) {
            findDeactivatable(viewPortPlan.childNavigationInstruction.plan, callbackName, list);
        }
    }
    return list;
};
/**
 * @internal exported for unit testing
 */
const addPreviousDeactivatable = (component, callbackName, list) => {
    let childRouter = component.childRouter;
    if (childRouter && childRouter.currentInstruction) {
        let viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;
        for (let viewPortName in viewPortInstructions) {
            let viewPortInstruction = viewPortInstructions[viewPortName];
            let prevComponent = viewPortInstruction.component;
            let prevViewModel = prevComponent.viewModel;
            if (callbackName in prevViewModel) {
                list.push(prevViewModel);
            }
            addPreviousDeactivatable(prevComponent, callbackName, list);
        }
    }
};
/**
 * @internal exported for unit testing
 */
const processActivatable = (navigationInstruction, callbackName, next, ignoreResult) => {
    let infos = findActivatable(navigationInstruction, callbackName);
    let length = infos.length;
    let i = -1; // query from top down
    function inspect(val, router) {
        if (ignoreResult || shouldContinue(val, router)) {
            return iterate();
        }
        return next.cancel(val);
    }
    function iterate() {
        i++;
        if (i < length) {
            try {
                let current = infos[i];
                let result = current.viewModel[callbackName](...current.lifecycleArgs);
                return processPotential(result, (val) => inspect(val, current.router), next.cancel);
            }
            catch (error) {
                return next.cancel(error);
            }
        }
        return next();
    }
    return iterate();
};
/**
 * Find list of activatable view model and add to list (3rd parameter)
 * @internal exported for unit testing
 */
const findActivatable = (navigationInstruction, callbackName, list = [], router) => {
    let plan = navigationInstruction.plan;
    Object
        .keys(plan)
        .forEach((viewPortName) => {
        let viewPortPlan = plan[viewPortName];
        let viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];
        let viewPortComponent = viewPortInstruction.component;
        let viewModel = viewPortComponent.viewModel;
        if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle
            || viewPortPlan.strategy === activationStrategy.replace)
            && callbackName in viewModel) {
            list.push({
                viewModel,
                lifecycleArgs: viewPortInstruction.lifecycleArgs,
                router
            });
        }
        let childNavInstruction = viewPortPlan.childNavigationInstruction;
        if (childNavInstruction) {
            findActivatable(childNavInstruction, callbackName, list, viewPortComponent.childRouter || router);
        }
    });
    return list;
};
const shouldContinue = (output, router) => {
    if (output instanceof Error) {
        return false;
    }
    if (isNavigationCommand(output)) {
        if (typeof output.setRouter === 'function') {
            output.setRouter(router);
        }
        return !!output.shouldContinueProcessing;
    }
    if (output === undefined) {
        return true;
    }
    return output;
};
/**
 * wraps a subscription, allowing unsubscribe calls even if
 * the first value comes synchronously
 */
class SafeSubscription {
    constructor(subscriptionFunc) {
        this._subscribed = true;
        this._subscription = subscriptionFunc(this);
        if (!this._subscribed) {
            this.unsubscribe();
        }
    }
    get subscribed() {
        return this._subscribed;
    }
    unsubscribe() {
        if (this._subscribed && this._subscription) {
            this._subscription.unsubscribe();
        }
        this._subscribed = false;
    }
}
/**
 * A function to process return value from `activate`/`canActivate` steps
 * Supports observable/promise
 *
 * For observable, resolve at first next() or on complete()
 */
const processPotential = (obj, resolve, reject) => {
    // if promise like
    if (obj && typeof obj.then === 'function') {
        return Promise.resolve(obj).then(resolve).catch(reject);
    }
    // if observable
    if (obj && typeof obj.subscribe === 'function') {
        let obs = obj;
        return new SafeSubscription(sub => obs.subscribe({
            next() {
                if (sub.subscribed) {
                    sub.unsubscribe();
                    resolve(obj);
                }
            },
            error(error) {
                if (sub.subscribed) {
                    sub.unsubscribe();
                    reject(error);
                }
            },
            complete() {
                if (sub.subscribed) {
                    sub.unsubscribe();
                    resolve(obj);
                }
            }
        }));
    }
    // else just resolve
    try {
        return resolve(obj);
    }
    catch (error) {
        return reject(error);
    }
};

/**
 * A pipeline step responsible for finding and activating method `canDeactivate` on a view model of a route
 */
class CanDeactivatePreviousStep {
    run(navigationInstruction, next) {
        return processDeactivatable(navigationInstruction, 'canDeactivate', next);
    }
}
/**
 * A pipeline step responsible for finding and activating method `canActivate` on a view model of a route
 */
class CanActivateNextStep {
    run(navigationInstruction, next) {
        return processActivatable(navigationInstruction, 'canActivate', next);
    }
}
/**
 * A pipeline step responsible for finding and activating method `deactivate` on a view model of a route
 */
class DeactivatePreviousStep {
    run(navigationInstruction, next) {
        return processDeactivatable(navigationInstruction, 'deactivate', next, true);
    }
}
/**
 * A pipeline step responsible for finding and activating method `activate` on a view model of a route
 */
class ActivateNextStep {
    run(navigationInstruction, next) {
        return processActivatable(navigationInstruction, 'activate', next, true);
    }
}

/**
 * A multi-slots Pipeline Placeholder Step for hooking into a pipeline execution
 */
class PipelineSlot {
    constructor(container, name, alias) {
        this.steps = [];
        this.container = container;
        this.slotName = name;
        this.slotAlias = alias;
    }
    getSteps() {
        return this.steps.map(x => this.container.get(x));
    }
}
/**
 * Class responsible for creating the navigation pipeline.
 */
class PipelineProvider {
    /**@internal */
    static inject() { return [aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__.Container]; }
    constructor(container) {
        this.container = container;
        this.steps = [
            BuildNavigationPlanStep,
            CanDeactivatePreviousStep,
            LoadRouteStep,
            createPipelineSlot(container, "authorize" /* Authorize */),
            CanActivateNextStep,
            createPipelineSlot(container, "preActivate" /* PreActivate */, 'modelbind'),
            // NOTE: app state changes start below - point of no return
            DeactivatePreviousStep,
            ActivateNextStep,
            createPipelineSlot(container, "preRender" /* PreRender */, 'precommit'),
            CommitChangesStep,
            createPipelineSlot(container, "postRender" /* PostRender */, 'postcomplete')
        ];
    }
    /**
     * Create the navigation pipeline.
     */
    createPipeline(useCanDeactivateStep = true) {
        let pipeline = new Pipeline();
        this.steps.forEach(step => {
            if (useCanDeactivateStep || step !== CanDeactivatePreviousStep) {
                pipeline.addStep(this.container.get(step));
            }
        });
        return pipeline;
    }
    /**@internal */
    _findStep(name) {
        // Steps that are not PipelineSlots are constructor functions, and they will automatically fail. Probably.
        return this.steps.find(x => x.slotName === name || x.slotAlias === name);
    }
    /**
     * Adds a step into the pipeline at a known slot location.
     */
    addStep(name, step) {
        let found = this._findStep(name);
        if (found) {
            let slotSteps = found.steps;
            // prevent duplicates
            if (!slotSteps.includes(step)) {
                slotSteps.push(step);
            }
        }
        else {
            throw new Error(`Invalid pipeline slot name: ${name}.`);
        }
    }
    /**
     * Removes a step from a slot in the pipeline
     */
    removeStep(name, step) {
        let slot = this._findStep(name);
        if (slot) {
            let slotSteps = slot.steps;
            slotSteps.splice(slotSteps.indexOf(step), 1);
        }
    }
    /**
     * Clears all steps from a slot in the pipeline
     * @internal
     */
    _clearSteps(name = '') {
        let slot = this._findStep(name);
        if (slot) {
            slot.steps = [];
        }
    }
    /**
     * Resets all pipeline slots
     */
    reset() {
        this._clearSteps("authorize" /* Authorize */);
        this._clearSteps("preActivate" /* PreActivate */);
        this._clearSteps("preRender" /* PreRender */);
        this._clearSteps("postRender" /* PostRender */);
    }
}
/**@internal */
const createPipelineSlot = (container, name, alias) => {
    return new PipelineSlot(container, name, alias);
};

const logger = (0,aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger)('app-router');
/**
 * The main application router.
 */
class AppRouter extends Router {
    /**@internal */
    static inject() { return [aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_1__.Container, aurelia_history__WEBPACK_IMPORTED_MODULE_2__.History, PipelineProvider, aurelia_event_aggregator__WEBPACK_IMPORTED_MODULE_4__.EventAggregator]; }
    constructor(container, history, pipelineProvider, events) {
        super(container, history); // Note the super will call reset internally.
        this.pipelineProvider = pipelineProvider;
        this.events = events;
    }
    /**
     * Fully resets the router's internal state. Primarily used internally by the framework when multiple calls to setRoot are made.
     * Use with caution (actually, avoid using this). Do not use this to simply change your navigation model.
     */
    reset() {
        super.reset();
        this.maxInstructionCount = 10;
        if (!this._queue) {
            this._queue = [];
        }
        else {
            this._queue.length = 0;
        }
    }
    /**
     * Loads the specified URL.
     *
     * @param url The URL fragment to load.
     */
    loadUrl(url) {
        return this
            ._createNavigationInstruction(url)
            .then(instruction => this._queueInstruction(instruction))
            .catch(error => {
            logger.error(error);
            restorePreviousLocation(this);
        });
    }
    /**
     * Registers a viewPort to be used as a rendering target for activated routes.
     *
     * @param viewPort The viewPort. This is typically a <router-view/> element in Aurelia default impl
     * @param name The name of the viewPort. 'default' if unspecified.
     */
    registerViewPort(viewPort, name) {
        // having strong typing without changing public API
        const $viewPort = viewPort;
        super.registerViewPort($viewPort, name);
        // beside adding viewport to the registry of this instance
        // AppRouter also configure routing/history to start routing functionality
        // There are situation where there are more than 1 <router-view/> element at root view
        // in that case, still only activate once via the following guard
        if (!this.isActive) {
            const viewModel = this._findViewModel($viewPort);
            if ('configureRouter' in viewModel) {
                // If there are more than one <router-view/> element at root view
                // use this flag to guard against configure method being invoked multiple times
                // this flag is set inside method configure
                if (!this.isConfigured) {
                    // replace the real resolve with a noop to guarantee that any action in base class Router
                    // won't resolve the configurePromise prematurely
                    const resolveConfiguredPromise = this._resolveConfiguredPromise;
                    this._resolveConfiguredPromise = () => { };
                    return this
                        .configure(config => Promise
                        .resolve(viewModel.configureRouter(config, this))
                        // an issue with configure interface. Should be fixed there
                        // todo: fix this via configure interface in router
                        .then(() => config))
                        .then(() => {
                        this.activate();
                        resolveConfiguredPromise();
                    });
                }
            }
            else {
                this.activate();
            }
        }
        // when a viewport is added dynamically to a root view that is already activated
        // just process the navigation instruction
        else {
            this._dequeueInstruction();
        }
        return Promise.resolve();
    }
    /**
     * Activates the router. This instructs the router to begin listening for history changes and processing instructions.
     *
     * @params options The set of options to activate the router with.
     */
    activate(options) {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        // route handler property is responsible for handling url change
        // the interface of aurelia-history isn't clear on this perspective
        this.options = Object.assign({ routeHandler: this.loadUrl.bind(this) }, this.options, options);
        this.history.activate(this.options);
        this._dequeueInstruction();
    }
    /**
     * Deactivates the router.
     */
    deactivate() {
        this.isActive = false;
        this.history.deactivate();
    }
    /**@internal */
    _queueInstruction(instruction) {
        return new Promise((resolve) => {
            instruction.resolve = resolve;
            this._queue.unshift(instruction);
            this._dequeueInstruction();
        });
    }
    /**@internal */
    _dequeueInstruction(instructionCount = 0) {
        return Promise.resolve().then(() => {
            if (this.isNavigating && !instructionCount) {
                // ts complains about inconsistent returns without void 0
                return void 0;
            }
            let instruction = this._queue.shift();
            this._queue.length = 0;
            if (!instruction) {
                // ts complains about inconsistent returns without void 0
                return void 0;
            }
            this.isNavigating = true;
            let navtracker = this.history.getState('NavigationTracker');
            let currentNavTracker = this.currentNavigationTracker;
            if (!navtracker && !currentNavTracker) {
                this.isNavigatingFirst = true;
                this.isNavigatingNew = true;
            }
            else if (!navtracker) {
                this.isNavigatingNew = true;
            }
            else if (!currentNavTracker) {
                this.isNavigatingRefresh = true;
            }
            else if (currentNavTracker < navtracker) {
                this.isNavigatingForward = true;
            }
            else if (currentNavTracker > navtracker) {
                this.isNavigatingBack = true;
            }
            if (!navtracker) {
                navtracker = Date.now();
                this.history.setState('NavigationTracker', navtracker);
            }
            this.currentNavigationTracker = navtracker;
            instruction.previousInstruction = this.currentInstruction;
            let maxInstructionCount = this.maxInstructionCount;
            if (!instructionCount) {
                this.events.publish("router:navigation:processing" /* Processing */, { instruction });
            }
            else if (instructionCount === maxInstructionCount - 1) {
                logger.error(`${instructionCount + 1} navigation instructions have been attempted without success. Restoring last known good location.`);
                restorePreviousLocation(this);
                return this._dequeueInstruction(instructionCount + 1);
            }
            else if (instructionCount > maxInstructionCount) {
                throw new Error('Maximum navigation attempts exceeded. Giving up.');
            }
            let pipeline = this.pipelineProvider.createPipeline(!this.couldDeactivate);
            return pipeline
                .run(instruction)
                .then(result => processResult(instruction, result, instructionCount, this))
                .catch(error => {
                return { output: error instanceof Error ? error : new Error(error) };
            })
                .then(result => resolveInstruction(instruction, result, !!instructionCount, this));
        });
    }
    /**@internal */
    _findViewModel(viewPort) {
        if (this.container.viewModel) {
            return this.container.viewModel;
        }
        if (viewPort.container) {
            let container = viewPort.container;
            while (container) {
                if (container.viewModel) {
                    this.container.viewModel = container.viewModel;
                    return container.viewModel;
                }
                container = container.parent;
            }
        }
        return undefined;
    }
}
const processResult = (instruction, result, instructionCount, router) => {
    if (!(result && 'completed' in result && 'output' in result)) {
        result = result || {};
        result.output = new Error(`Expected router pipeline to return a navigation result, but got [${JSON.stringify(result)}] instead.`);
    }
    let finalResult = null;
    let navigationCommandResult = null;
    if (isNavigationCommand(result.output)) {
        navigationCommandResult = result.output.navigate(router);
    }
    else {
        finalResult = result;
        if (!result.completed) {
            if (result.output instanceof Error) {
                logger.error(result.output.toString());
            }
            restorePreviousLocation(router);
        }
    }
    return Promise.resolve(navigationCommandResult)
        .then(_ => router._dequeueInstruction(instructionCount + 1))
        .then(innerResult => finalResult || innerResult || result);
};
const resolveInstruction = (instruction, result, isInnerInstruction, router) => {
    instruction.resolve(result);
    let eventAggregator = router.events;
    let eventArgs = { instruction, result };
    if (!isInnerInstruction) {
        router.isNavigating = false;
        router.isExplicitNavigation = false;
        router.isExplicitNavigationBack = false;
        router.isNavigatingFirst = false;
        router.isNavigatingNew = false;
        router.isNavigatingRefresh = false;
        router.isNavigatingForward = false;
        router.isNavigatingBack = false;
        router.couldDeactivate = false;
        let eventName;
        if (result.output instanceof Error) {
            eventName = "router:navigation:error" /* Error */;
        }
        else if (!result.completed) {
            eventName = "router:navigation:canceled" /* Canceled */;
        }
        else {
            let queryString = instruction.queryString ? ('?' + instruction.queryString) : '';
            router.history.previousLocation = instruction.fragment + queryString;
            eventName = "router:navigation:success" /* Success */;
        }
        eventAggregator.publish(eventName, eventArgs);
        eventAggregator.publish("router:navigation:complete" /* Complete */, eventArgs);
    }
    else {
        eventAggregator.publish("router:navigation:child:complete" /* ChildComplete */, eventArgs);
    }
    return result;
};
const restorePreviousLocation = (router) => {
    let previousLocation = router.history.previousLocation;
    if (previousLocation) {
        router.navigate(previousLocation, { trigger: false, replace: true });
    }
    else if (router.fallbackRoute) {
        router.navigate(router.fallbackRoute, { trigger: true, replace: true });
    }
    else {
        logger.error('Router navigation failed, and no previous location or fallbackRoute could be restored.');
    }
};

/**
* The status of a Pipeline.
*/
var PipelineStatus;
(function (PipelineStatus) {
    PipelineStatus["Completed"] = "completed";
    PipelineStatus["Canceled"] = "canceled";
    PipelineStatus["Rejected"] = "rejected";
    PipelineStatus["Running"] = "running";
})(PipelineStatus || (PipelineStatus = {}));

/**
 * A list of known router events used by the Aurelia router
 * to signal the pipeline has come to a certain state
 */
// const enum is preserved in tsconfig
var RouterEvent;
(function (RouterEvent) {
    RouterEvent["Processing"] = "router:navigation:processing";
    RouterEvent["Error"] = "router:navigation:error";
    RouterEvent["Canceled"] = "router:navigation:canceled";
    RouterEvent["Complete"] = "router:navigation:complete";
    RouterEvent["Success"] = "router:navigation:success";
    RouterEvent["ChildComplete"] = "router:navigation:child:complete";
})(RouterEvent || (RouterEvent = {}));

/**
 * Available pipeline slot names to insert interceptor into router pipeline
 */
// const enum is preserved in tsconfig
var PipelineSlotName;
(function (PipelineSlotName) {
    /**
     * Authorization slot. Invoked early in the pipeline,
     * before `canActivate` hook of incoming route
     */
    PipelineSlotName["Authorize"] = "authorize";
    /**
     * Pre-activation slot. Invoked early in the pipeline,
     * Invoked timing:
     *   - after Authorization slot
     *   - after canActivate hook on new view model
     *   - before deactivate hook on old view model
     *   - before activate hook on new view model
     */
    PipelineSlotName["PreActivate"] = "preActivate";
    /**
     * Pre-render slot. Invoked later in the pipeline
     * Invokcation timing:
     *   - after activate hook on new view model
     *   - before commit step on new navigation instruction
     */
    PipelineSlotName["PreRender"] = "preRender";
    /**
     * Post-render slot. Invoked last in the pipeline
     */
    PipelineSlotName["PostRender"] = "postRender";
})(PipelineSlotName || (PipelineSlotName = {}));


//# sourceMappingURL=aurelia-router.js.map


/***/ }),

/***/ "../../node_modules/aurelia-task-queue/dist/es2015/aurelia-task-queue.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/aurelia-task-queue/dist/es2015/aurelia-task-queue.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TaskQueue: () => (/* binding */ TaskQueue)
/* harmony export */ });
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");


const stackSeparator = '\nEnqueued in TaskQueue by:\n';
const microStackSeparator = '\nEnqueued in MicroTaskQueue by:\n';

function makeRequestFlushFromMutationObserver(flush) {
  let observer = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createMutationObserver(flush);
  let val = 'a';
  let node = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createTextNode('a');
  let values = Object.create(null);
  values.a = 'b';
  values.b = 'a';
  observer.observe(node, { characterData: true });
  return function requestFlush() {
    node.data = val = values[val];
  };
}

function makeRequestFlushFromTimer(flush) {
  return function requestFlush() {
    let timeoutHandle = setTimeout(handleFlushTimer, 0);

    let intervalHandle = setInterval(handleFlushTimer, 50);
    function handleFlushTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      flush();
    }
  };
}

function onError(error, task, longStacks) {
  if (longStacks && task.stack && typeof error === 'object' && error !== null) {
    error.stack = filterFlushStack(error.stack) + task.stack;
  }

  if ('onError' in task) {
    task.onError(error);
  } else {
    setTimeout(() => {
      throw error;
    }, 0);
  }
}

let TaskQueue = class TaskQueue {
  constructor() {
    this.flushing = false;
    this.longStacks = false;

    this.microTaskQueue = [];
    this.microTaskQueueCapacity = 1024;
    this.taskQueue = [];

    if (aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.FEATURE.mutationObserver) {
      this.requestFlushMicroTaskQueue = makeRequestFlushFromMutationObserver(() => this.flushMicroTaskQueue());
    } else {
      this.requestFlushMicroTaskQueue = makeRequestFlushFromTimer(() => this.flushMicroTaskQueue());
    }

    this.requestFlushTaskQueue = makeRequestFlushFromTimer(() => this.flushTaskQueue());
  }

  _flushQueue(queue, capacity) {
    let index = 0;
    let task;

    try {
      this.flushing = true;
      while (index < queue.length) {
        task = queue[index];
        if (this.longStacks) {
          this.stack = typeof task.stack === 'string' ? task.stack : undefined;
        }
        task.call();
        index++;

        if (index > capacity) {
          for (let scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
            queue[scan] = queue[scan + index];
          }

          queue.length -= index;
          index = 0;
        }
      }
    } catch (error) {
      onError(error, task, this.longStacks);
    } finally {
      this.flushing = false;
    }
  }

  queueMicroTask(task) {
    if (this.microTaskQueue.length < 1) {
      this.requestFlushMicroTaskQueue();
    }

    if (this.longStacks) {
      task.stack = this.prepareQueueStack(microStackSeparator);
    }

    this.microTaskQueue.push(task);
  }

  queueTask(task) {
    if (this.taskQueue.length < 1) {
      this.requestFlushTaskQueue();
    }

    if (this.longStacks) {
      task.stack = this.prepareQueueStack(stackSeparator);
    }

    this.taskQueue.push(task);
  }

  flushTaskQueue() {
    let queue = this.taskQueue;
    this.taskQueue = [];
    this._flushQueue(queue, Number.MAX_VALUE);
  }

  flushMicroTaskQueue() {
    let queue = this.microTaskQueue;
    this._flushQueue(queue, this.microTaskQueueCapacity);
    queue.length = 0;
  }

  prepareQueueStack(separator) {
    let stack = separator + filterQueueStack(captureStack());

    if (typeof this.stack === 'string') {
      stack = filterFlushStack(stack) + this.stack;
    }

    return stack;
  }
};

function captureStack() {
  let error = new Error();

  if (error.stack) {
    return error.stack;
  }

  try {
    throw error;
  } catch (e) {
    return e.stack;
  }
}

function filterQueueStack(stack) {
  return stack.replace(/^[\s\S]*?\bqueue(Micro)?Task\b[^\n]*\n/, '');
}

function filterFlushStack(stack) {
  let index = stack.lastIndexOf('flushMicroTaskQueue');

  if (index < 0) {
    index = stack.lastIndexOf('flushTaskQueue');
    if (index < 0) {
      return stack;
    }
  }

  index = stack.lastIndexOf('\n', index);

  return index < 0 ? stack : stack.substr(0, index);
}

/***/ }),

/***/ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Animator: () => (/* binding */ Animator),
/* harmony export */   BehaviorInstruction: () => (/* binding */ BehaviorInstruction),
/* harmony export */   BehaviorPropertyObserver: () => (/* binding */ BehaviorPropertyObserver),
/* harmony export */   BindableProperty: () => (/* binding */ BindableProperty),
/* harmony export */   BindingLanguage: () => (/* binding */ BindingLanguage),
/* harmony export */   BoundViewFactory: () => (/* binding */ BoundViewFactory),
/* harmony export */   CompositionEngine: () => (/* binding */ CompositionEngine),
/* harmony export */   CompositionTransaction: () => (/* binding */ CompositionTransaction),
/* harmony export */   CompositionTransactionNotifier: () => (/* binding */ CompositionTransactionNotifier),
/* harmony export */   CompositionTransactionOwnershipToken: () => (/* binding */ CompositionTransactionOwnershipToken),
/* harmony export */   Controller: () => (/* binding */ Controller),
/* harmony export */   ConventionalViewStrategy: () => (/* binding */ ConventionalViewStrategy),
/* harmony export */   ElementConfigResource: () => (/* binding */ ElementConfigResource),
/* harmony export */   ElementEvents: () => (/* binding */ ElementEvents),
/* harmony export */   HtmlBehaviorResource: () => (/* binding */ HtmlBehaviorResource),
/* harmony export */   InlineViewStrategy: () => (/* binding */ InlineViewStrategy),
/* harmony export */   ModuleAnalyzer: () => (/* binding */ ModuleAnalyzer),
/* harmony export */   NoViewStrategy: () => (/* binding */ NoViewStrategy),
/* harmony export */   PassThroughSlot: () => (/* binding */ PassThroughSlot),
/* harmony export */   RelativeViewStrategy: () => (/* binding */ RelativeViewStrategy),
/* harmony export */   ResourceDescription: () => (/* binding */ ResourceDescription),
/* harmony export */   ResourceLoadContext: () => (/* binding */ ResourceLoadContext),
/* harmony export */   ResourceModule: () => (/* binding */ ResourceModule),
/* harmony export */   ShadowDOM: () => (/* binding */ ShadowDOM),
/* harmony export */   ShadowSlot: () => (/* binding */ ShadowSlot),
/* harmony export */   SlotCustomAttribute: () => (/* binding */ SlotCustomAttribute),
/* harmony export */   StaticViewStrategy: () => (/* binding */ StaticViewStrategy),
/* harmony export */   SwapStrategies: () => (/* binding */ SwapStrategies),
/* harmony export */   TargetInstruction: () => (/* binding */ TargetInstruction),
/* harmony export */   TemplateRegistryViewStrategy: () => (/* binding */ TemplateRegistryViewStrategy),
/* harmony export */   TemplatingEngine: () => (/* binding */ TemplatingEngine),
/* harmony export */   View: () => (/* binding */ View),
/* harmony export */   ViewCompileInstruction: () => (/* binding */ ViewCompileInstruction),
/* harmony export */   ViewCompiler: () => (/* binding */ ViewCompiler),
/* harmony export */   ViewEngine: () => (/* binding */ ViewEngine),
/* harmony export */   ViewEngineHooksResource: () => (/* binding */ ViewEngineHooksResource),
/* harmony export */   ViewFactory: () => (/* binding */ ViewFactory),
/* harmony export */   ViewLocator: () => (/* binding */ ViewLocator),
/* harmony export */   ViewResources: () => (/* binding */ ViewResources),
/* harmony export */   ViewSlot: () => (/* binding */ ViewSlot),
/* harmony export */   _hyphenate: () => (/* binding */ _hyphenate),
/* harmony export */   _isAllWhitespace: () => (/* binding */ _isAllWhitespace),
/* harmony export */   animationEvent: () => (/* binding */ animationEvent),
/* harmony export */   behavior: () => (/* binding */ behavior),
/* harmony export */   bindable: () => (/* binding */ bindable),
/* harmony export */   child: () => (/* binding */ child),
/* harmony export */   children: () => (/* binding */ children),
/* harmony export */   containerless: () => (/* binding */ containerless),
/* harmony export */   customAttribute: () => (/* binding */ customAttribute),
/* harmony export */   customElement: () => (/* binding */ customElement),
/* harmony export */   dynamicOptions: () => (/* binding */ dynamicOptions),
/* harmony export */   elementConfig: () => (/* binding */ elementConfig),
/* harmony export */   inlineView: () => (/* binding */ inlineView),
/* harmony export */   noView: () => (/* binding */ noView),
/* harmony export */   processAttributes: () => (/* binding */ processAttributes),
/* harmony export */   processContent: () => (/* binding */ processContent),
/* harmony export */   resource: () => (/* binding */ resource),
/* harmony export */   templateController: () => (/* binding */ templateController),
/* harmony export */   useShadowDOM: () => (/* binding */ useShadowDOM),
/* harmony export */   useView: () => (/* binding */ useView),
/* harmony export */   useViewStrategy: () => (/* binding */ useViewStrategy),
/* harmony export */   validateBehaviorName: () => (/* binding */ validateBehaviorName),
/* harmony export */   view: () => (/* binding */ view),
/* harmony export */   viewEngineHooks: () => (/* binding */ viewEngineHooks),
/* harmony export */   viewResources: () => (/* binding */ viewResources),
/* harmony export */   viewStrategy: () => (/* binding */ viewStrategy)
/* harmony export */ });
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
/* harmony import */ var aurelia_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-loader */ "../../node_modules/aurelia-loader/dist/es2015/aurelia-loader.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
/* harmony import */ var aurelia_path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-path */ "../../node_modules/aurelia-path/dist/es2015/aurelia-path.js");
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");
/* harmony import */ var aurelia_binding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! aurelia-binding */ "../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js");
/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! aurelia-dependency-injection */ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js");
/* harmony import */ var aurelia_task_queue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! aurelia-task-queue */ "../../node_modules/aurelia-task-queue/dist/es2015/aurelia-task-queue.js");









class ElementEvents {
    constructor(element) {
        this.element = element;
        this.subscriptions = {};
    }
    _enqueueHandler(handler) {
        this.subscriptions[handler.eventName] = this.subscriptions[handler.eventName] || [];
        this.subscriptions[handler.eventName].push(handler);
    }
    _dequeueHandler(handler) {
        let index;
        let subscriptions = this.subscriptions[handler.eventName];
        if (subscriptions) {
            index = subscriptions.indexOf(handler);
            if (index > -1) {
                subscriptions.splice(index, 1);
            }
        }
        return handler;
    }
    publish(eventName, detail = {}, bubbles = true, cancelable = true) {
        let event = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createCustomEvent(eventName, { cancelable, bubbles, detail });
        this.element.dispatchEvent(event);
    }
    subscribe(eventName, handler, captureOrOptions) {
        if (typeof handler === 'function') {
            if (captureOrOptions === undefined) {
                captureOrOptions = ElementEvents.defaultListenerOptions;
            }
            const eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, false);
            return eventHandler;
        }
        return undefined;
    }
    subscribeOnce(eventName, handler, captureOrOptions) {
        if (typeof handler === 'function') {
            if (captureOrOptions === undefined) {
                captureOrOptions = ElementEvents.defaultListenerOptions;
            }
            const eventHandler = new EventHandlerImpl(this, eventName, handler, captureOrOptions, true);
            return eventHandler;
        }
        return undefined;
    }
    dispose(eventName) {
        if (eventName && typeof eventName === 'string') {
            let subscriptions = this.subscriptions[eventName];
            if (subscriptions) {
                while (subscriptions.length) {
                    let subscription = subscriptions.pop();
                    if (subscription) {
                        subscription.dispose();
                    }
                }
            }
        }
        else {
            this.disposeAll();
        }
    }
    disposeAll() {
        for (let key in this.subscriptions) {
            this.dispose(key);
        }
    }
}
ElementEvents.defaultListenerOptions = true;
class EventHandlerImpl {
    constructor(owner, eventName, handler, captureOrOptions, once) {
        this.owner = owner;
        this.eventName = eventName;
        this.handler = handler;
        this.capture = typeof captureOrOptions === 'boolean' ? captureOrOptions : captureOrOptions.capture;
        this.bubbles = !this.capture;
        this.captureOrOptions = captureOrOptions;
        this.once = once;
        owner.element.addEventListener(eventName, this, captureOrOptions);
        owner._enqueueHandler(this);
    }
    handleEvent(e) {
        const fn = this.handler;
        fn(e);
        if (this.once) {
            this.dispose();
        }
    }
    dispose() {
        this.owner.element.removeEventListener(this.eventName, this, this.captureOrOptions);
        this.owner._dequeueHandler(this);
        this.owner = this.handler = null;
    }
}

class ResourceLoadContext {
    constructor() {
        this.dependencies = {};
    }
    addDependency(url) {
        this.dependencies[url] = true;
    }
    hasDependency(url) {
        return url in this.dependencies;
    }
}
class ViewCompileInstruction {
    constructor(targetShadowDOM = false, compileSurrogate = false) {
        this.targetShadowDOM = targetShadowDOM;
        this.compileSurrogate = compileSurrogate;
        this.associatedModuleId = null;
    }
}
ViewCompileInstruction.normal = new ViewCompileInstruction();
class BehaviorInstruction {
    static enhance() {
        let instruction = new BehaviorInstruction();
        instruction.enhance = true;
        return instruction;
    }
    static unitTest(type, attributes) {
        let instruction = new BehaviorInstruction();
        instruction.type = type;
        instruction.attributes = attributes || {};
        return instruction;
    }
    static element(node, type) {
        let instruction = new BehaviorInstruction();
        instruction.type = type;
        instruction.attributes = {};
        instruction.anchorIsContainer = !(node.hasAttribute('containerless') || type.containerless);
        instruction.initiatedByBehavior = true;
        return instruction;
    }
    static attribute(attrName, type) {
        let instruction = new BehaviorInstruction();
        instruction.attrName = attrName;
        instruction.type = type || null;
        instruction.attributes = {};
        return instruction;
    }
    static dynamic(host, viewModel, viewFactory) {
        let instruction = new BehaviorInstruction();
        instruction.host = host;
        instruction.viewModel = viewModel;
        instruction.viewFactory = viewFactory;
        instruction.inheritBindingContext = true;
        return instruction;
    }
}
BehaviorInstruction.normal = new BehaviorInstruction();
const biProto = BehaviorInstruction.prototype;
biProto.initiatedByBehavior = false;
biProto.enhance = false;
biProto.partReplacements = null;
biProto.viewFactory = null;
biProto.originalAttrName = null;
biProto.skipContentProcessing = false;
biProto.contentFactory = null;
biProto.viewModel = null;
biProto.anchorIsContainer = false;
biProto.host = null;
biProto.attributes = null;
biProto.type = null;
biProto.attrName = null;
biProto.inheritBindingContext = false;
class TargetInstruction {
    static shadowSlot(parentInjectorId) {
        let instruction = new TargetInstruction();
        instruction.parentInjectorId = parentInjectorId;
        instruction.shadowSlot = true;
        return instruction;
    }
    static contentExpression(expression) {
        let instruction = new TargetInstruction();
        instruction.contentExpression = expression;
        return instruction;
    }
    static letElement(expressions) {
        let instruction = new TargetInstruction();
        instruction.expressions = expressions;
        instruction.letElement = true;
        return instruction;
    }
    static lifting(parentInjectorId, liftingInstruction) {
        let instruction = new TargetInstruction();
        instruction.parentInjectorId = parentInjectorId;
        instruction.expressions = TargetInstruction.noExpressions;
        instruction.behaviorInstructions = [liftingInstruction];
        instruction.viewFactory = liftingInstruction.viewFactory;
        instruction.providers = [liftingInstruction.type.target];
        instruction.lifting = true;
        return instruction;
    }
    static normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction) {
        let instruction = new TargetInstruction();
        instruction.injectorId = injectorId;
        instruction.parentInjectorId = parentInjectorId;
        instruction.providers = providers;
        instruction.behaviorInstructions = behaviorInstructions;
        instruction.expressions = expressions;
        instruction.anchorIsContainer = elementInstruction ? elementInstruction.anchorIsContainer : true;
        instruction.elementInstruction = elementInstruction;
        return instruction;
    }
    static surrogate(providers, behaviorInstructions, expressions, values) {
        let instruction = new TargetInstruction();
        instruction.expressions = expressions;
        instruction.behaviorInstructions = behaviorInstructions;
        instruction.providers = providers;
        instruction.values = values;
        return instruction;
    }
}
TargetInstruction.noExpressions = Object.freeze([]);
const tiProto = TargetInstruction.prototype;
tiProto.injectorId = null;
tiProto.parentInjectorId = null;
tiProto.shadowSlot = false;
tiProto.slotName = null;
tiProto.slotFallbackFactory = null;
tiProto.contentExpression = null;
tiProto.letElement = false;
tiProto.expressions = null;
tiProto.expressions = null;
tiProto.providers = null;
tiProto.viewFactory = null;
tiProto.anchorIsContainer = false;
tiProto.elementInstruction = null;
tiProto.lifting = false;
tiProto.values = null;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

const capitalMatcher = /([A-Z])/g;
function addHyphenAndLower(char) {
    return '-' + char.toLowerCase();
}
function _hyphenate(name) {
    return (name.charAt(0).toLowerCase() + name.slice(1)).replace(capitalMatcher, addHyphenAndLower);
}
function _isAllWhitespace(node) {
    return !(node.auInterpolationTarget || (/[^\t\n\r ]/.test(node.textContent)));
}

let BehaviorPropertyObserver = class BehaviorPropertyObserver {
    constructor(taskQueue, obj, propertyName, selfSubscriber, initialValue) {
        this.taskQueue = taskQueue;
        this.obj = obj;
        this.propertyName = propertyName;
        this.notqueued = true;
        this.publishing = false;
        this.selfSubscriber = selfSubscriber;
        this.currentValue = this.oldValue = initialValue;
    }
    getValue() {
        return this.currentValue;
    }
    setValue(newValue) {
        let oldValue = this.currentValue;
        if (!Object.is(newValue, oldValue)) {
            this.oldValue = oldValue;
            this.currentValue = newValue;
            if (this.publishing && this.notqueued) {
                if (this.taskQueue.flushing) {
                    this.call();
                }
                else {
                    this.notqueued = false;
                    this.taskQueue.queueMicroTask(this);
                }
            }
        }
    }
    call() {
        let oldValue = this.oldValue;
        let newValue = this.currentValue;
        this.notqueued = true;
        if (Object.is(newValue, oldValue)) {
            return;
        }
        if (this.selfSubscriber) {
            this.selfSubscriber(newValue, oldValue);
        }
        this.callSubscribers(newValue, oldValue);
        this.oldValue = newValue;
    }
    callSubscribers(newValue, oldValue) {
        throw new Error('Method not implemented.');
    }
    subscribe(context, callable) {
        this.addSubscriber(context, callable);
    }
    addSubscriber(context, callable) {
        throw new Error('Method not implemented.');
    }
    unsubscribe(context, callable) {
        this.removeSubscriber(context, callable);
    }
    removeSubscriber(context, callable) {
        throw new Error('Method not implemented.');
    }
};
BehaviorPropertyObserver = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.subscriberCollection)()
], BehaviorPropertyObserver);

function getObserver(instance, name) {
    let lookup = instance.__observers__;
    if (lookup === undefined) {
        let ctor = Object.getPrototypeOf(instance).constructor;
        let behavior = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.get(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, ctor);
        if (!behavior.isInitialized) {
            behavior.initialize(aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_6__.Container.instance || new aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_6__.Container(), instance.constructor);
        }
        lookup = behavior.observerLocator.getOrCreateObserversLookup(instance);
        behavior._ensurePropertiesDefined(instance, lookup);
    }
    return lookup[name];
}
class BindableProperty {
    constructor(nameOrConfig) {
        if (typeof nameOrConfig === 'string') {
            this.name = nameOrConfig;
        }
        else {
            Object.assign(this, nameOrConfig);
        }
        this.attribute = this.attribute || _hyphenate(this.name);
        let defaultBindingMode = this.defaultBindingMode;
        if (defaultBindingMode === null || defaultBindingMode === undefined) {
            this.defaultBindingMode = aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.bindingMode.oneWay;
        }
        else if (typeof defaultBindingMode === 'string') {
            this.defaultBindingMode = aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.bindingMode[defaultBindingMode] || aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.bindingMode.oneWay;
        }
        this.changeHandler = this.changeHandler || null;
        this.owner = null;
        this.descriptor = null;
    }
    registerWith(target, behavior, descriptor) {
        behavior.properties.push(this);
        behavior.attributes[this.attribute] = this;
        this.owner = behavior;
        if (descriptor) {
            this.descriptor = descriptor;
            return this._configureDescriptor(descriptor);
        }
        return undefined;
    }
    _configureDescriptor(descriptor) {
        let name = this.name;
        descriptor.configurable = true;
        descriptor.enumerable = true;
        if ('initializer' in descriptor) {
            this.defaultValue = descriptor.initializer;
            delete descriptor.initializer;
            delete descriptor.writable;
        }
        if ('value' in descriptor) {
            this.defaultValue = descriptor.value;
            delete descriptor.value;
            delete descriptor.writable;
        }
        descriptor.get = function () {
            return getObserver(this, name).getValue();
        };
        descriptor.set = function (value) {
            getObserver(this, name).setValue(value);
        };
        descriptor.get.getObserver = function (obj) {
            return getObserver(obj, name);
        };
        return descriptor;
    }
    defineOn(target, behavior) {
        let name = this.name;
        let handlerName;
        if (this.changeHandler === null) {
            handlerName = name + 'Changed';
            if (handlerName in target.prototype) {
                this.changeHandler = handlerName;
            }
        }
        if (this.descriptor === null) {
            Object.defineProperty(target.prototype, name, this._configureDescriptor({}));
        }
    }
    createObserver(viewModel) {
        let selfSubscriber = null;
        let defaultValue = this.defaultValue;
        let changeHandlerName = this.changeHandler;
        let name = this.name;
        let initialValue;
        if (this.hasOptions) {
            return undefined;
        }
        if (changeHandlerName in viewModel) {
            if ('propertyChanged' in viewModel) {
                selfSubscriber = (newValue, oldValue) => {
                    viewModel[changeHandlerName](newValue, oldValue);
                    viewModel.propertyChanged(name, newValue, oldValue);
                };
            }
            else {
                selfSubscriber = (newValue, oldValue) => viewModel[changeHandlerName](newValue, oldValue);
            }
        }
        else if ('propertyChanged' in viewModel) {
            selfSubscriber = (newValue, oldValue) => viewModel.propertyChanged(name, newValue, oldValue);
        }
        else if (changeHandlerName !== null) {
            throw new Error(`Change handler ${changeHandlerName} was specified but not declared on the class.`);
        }
        if (defaultValue !== undefined) {
            initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;
        }
        return new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);
    }
    _initialize(viewModel, observerLookup, attributes, behaviorHandlesBind, boundProperties) {
        let selfSubscriber;
        let observer;
        let attribute;
        let defaultValue = this.defaultValue;
        if (this.isDynamic) {
            for (let key in attributes) {
                this._createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, key, attributes[key], boundProperties);
            }
        }
        else if (!this.hasOptions) {
            observer = observerLookup[this.name];
            if (attributes !== null) {
                selfSubscriber = observer.selfSubscriber;
                attribute = attributes[this.attribute];
                if (behaviorHandlesBind) {
                    observer.selfSubscriber = null;
                }
                if (typeof attribute === 'string') {
                    viewModel[this.name] = attribute;
                    observer.call();
                }
                else if (attribute) {
                    boundProperties.push({ observer: observer, binding: attribute.createBinding(viewModel) });
                }
                else if (defaultValue !== undefined) {
                    observer.call();
                }
                observer.selfSubscriber = selfSubscriber;
            }
            observer.publishing = true;
        }
    }
    _createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {
        let changeHandlerName = name + 'Changed';
        let selfSubscriber = null;
        let observer;
        let info;
        if (changeHandlerName in viewModel) {
            if ('propertyChanged' in viewModel) {
                selfSubscriber = (newValue, oldValue) => {
                    viewModel[changeHandlerName](newValue, oldValue);
                    viewModel.propertyChanged(name, newValue, oldValue);
                };
            }
            else {
                selfSubscriber = (newValue, oldValue) => viewModel[changeHandlerName](newValue, oldValue);
            }
        }
        else if ('propertyChanged' in viewModel) {
            selfSubscriber = (newValue, oldValue) => viewModel.propertyChanged(name, newValue, oldValue);
        }
        observer = observerLookup[name] = new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, name, selfSubscriber);
        Object.defineProperty(viewModel, name, {
            configurable: true,
            enumerable: true,
            get: observer.getValue.bind(observer),
            set: observer.setValue.bind(observer)
        });
        if (behaviorHandlesBind) {
            observer.selfSubscriber = null;
        }
        if (typeof attribute === 'string') {
            viewModel[name] = attribute;
            observer.call();
        }
        else if (attribute) {
            info = { observer: observer, binding: attribute.createBinding(viewModel) };
            boundProperties.push(info);
        }
        observer.publishing = true;
        observer.selfSubscriber = selfSubscriber;
    }
}

class ViewLocator {
    getViewStrategy(value) {
        if (!value) {
            return null;
        }
        if (typeof value === 'object' && 'getViewStrategy' in value) {
            let origin = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Origin.get(value.constructor);
            value = value.getViewStrategy();
            if (typeof value === 'string') {
                value = new RelativeViewStrategy(value);
            }
            viewStrategy.assert(value);
            if (origin.moduleId) {
                value.makeRelativeTo(origin.moduleId);
            }
            return value;
        }
        if (typeof value === 'string') {
            value = new RelativeViewStrategy(value);
        }
        if (viewStrategy.validate(value)) {
            return value;
        }
        if (typeof value !== 'function') {
            value = value.constructor;
        }
        if ('$view' in value) {
            let c = value.$view;
            let view;
            c = typeof c === 'function' ? c.call(value) : c;
            if (c === null) {
                view = new NoViewStrategy();
            }
            else {
                view = c instanceof StaticViewStrategy ? c : new StaticViewStrategy(c);
            }
            aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(ViewLocator.viewStrategyMetadataKey, view, value);
            return view;
        }
        let origin = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Origin.get(value);
        let strategy = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.get(ViewLocator.viewStrategyMetadataKey, value);
        if (!strategy) {
            if (!origin.moduleId) {
                throw new Error('Cannot determine default view strategy for object.\n' + value);
            }
            strategy = this.createFallbackViewStrategy(origin);
        }
        else if (origin.moduleId) {
            strategy.moduleId = origin.moduleId;
        }
        return strategy;
    }
    createFallbackViewStrategy(origin) {
        return new ConventionalViewStrategy(this, origin);
    }
    convertOriginToViewUrl(origin) {
        let moduleId = origin.moduleId;
        let id = (moduleId.endsWith('.js') || moduleId.endsWith('.ts')) ? moduleId.substring(0, moduleId.length - 3) : moduleId;
        return id + '.html';
    }
}
ViewLocator.viewStrategyMetadataKey = 'aurelia:view-strategy';

function mi(name) {
    throw new Error(`BindingLanguage must implement ${name}().`);
}
class BindingLanguage {
    inspectAttribute(resources, elementName, attrName, attrValue) {
        mi('inspectAttribute');
    }
    createAttributeInstruction(resources, element, info, existingInstruction, context) {
        mi('createAttributeInstruction');
    }
    createLetExpressions(resources, element) {
        mi('createLetExpressions');
    }
    inspectTextContent(resources, value) {
        mi('inspectTextContent');
    }
}

let noNodes = Object.freeze([]);
class SlotCustomAttribute {
    constructor(element) {
        this.element = element;
        this.element.auSlotAttribute = this;
    }
    static inject() {
        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.Element];
    }
    valueChanged(newValue, oldValue) { }
}
class PassThroughSlot {
    constructor(anchor, name, destinationName, fallbackFactory) {
        this.anchor = anchor;
        this.anchor.viewSlot = this;
        this.name = name;
        this.destinationName = destinationName;
        this.fallbackFactory = fallbackFactory;
        this.destinationSlot = null;
        this.projections = 0;
        this.contentView = null;
        let attr = new SlotCustomAttribute(this.anchor);
        attr.value = this.destinationName;
    }
    get needsFallbackRendering() {
        return this.fallbackFactory && this.projections === 0;
    }
    renderFallbackContent(view, nodes, projectionSource, index) {
        if (this.contentView === null) {
            this.contentView = this.fallbackFactory.create(this.ownerView.container);
            this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);
            let slots = Object.create(null);
            slots[this.destinationSlot.name] = this.destinationSlot;
            ShadowDOM.distributeView(this.contentView, slots, projectionSource, index, this.destinationSlot.name);
        }
    }
    passThroughTo(destinationSlot) {
        this.destinationSlot = destinationSlot;
    }
    addNode(view, node, projectionSource, index) {
        if (this.contentView !== null) {
            this.contentView.removeNodes();
            this.contentView.detached();
            this.contentView.unbind();
            this.contentView = null;
        }
        if (node.viewSlot instanceof PassThroughSlot) {
            node.viewSlot.passThroughTo(this);
            return;
        }
        this.projections++;
        this.destinationSlot.addNode(view, node, projectionSource, index);
    }
    removeView(view, projectionSource) {
        this.projections--;
        this.destinationSlot.removeView(view, projectionSource);
        if (this.needsFallbackRendering) {
            this.renderFallbackContent(null, noNodes, projectionSource);
        }
    }
    removeAll(projectionSource) {
        this.projections = 0;
        this.destinationSlot.removeAll(projectionSource);
        if (this.needsFallbackRendering) {
            this.renderFallbackContent(null, noNodes, projectionSource);
        }
    }
    projectFrom(view, projectionSource) {
        this.destinationSlot.projectFrom(view, projectionSource);
    }
    created(ownerView) {
        this.ownerView = ownerView;
    }
    bind(view) {
        if (this.contentView) {
            this.contentView.bind(view.bindingContext, view.overrideContext);
        }
    }
    attached() {
        if (this.contentView) {
            this.contentView.attached();
        }
    }
    detached() {
        if (this.contentView) {
            this.contentView.detached();
        }
    }
    unbind() {
        if (this.contentView) {
            this.contentView.unbind();
        }
    }
}
class ShadowSlot {
    constructor(anchor, name, fallbackFactory) {
        this.anchor = anchor;
        this.anchor.isContentProjectionSource = true;
        this.anchor.viewSlot = this;
        this.name = name;
        this.fallbackFactory = fallbackFactory;
        this.contentView = null;
        this.projections = 0;
        this.children = [];
        this.projectFromAnchors = null;
        this.destinationSlots = null;
    }
    get needsFallbackRendering() {
        return this.fallbackFactory && this.projections === 0;
    }
    addNode(view, node, projectionSource, index, destination) {
        let $node = node;
        if (this.contentView !== null) {
            this.contentView.removeNodes();
            this.contentView.detached();
            this.contentView.unbind();
            this.contentView = null;
        }
        if ($node.viewSlot instanceof PassThroughSlot) {
            $node.viewSlot.passThroughTo(this);
            return;
        }
        if (this.destinationSlots !== null) {
            ShadowDOM.distributeNodes(view, [$node], this.destinationSlots, this, index);
        }
        else {
            $node.auOwnerView = view;
            $node.auProjectionSource = projectionSource;
            $node.auAssignedSlot = this;
            let anchor = this._findAnchor(view, $node, projectionSource, index);
            let parent = anchor.parentNode;
            parent.insertBefore($node, anchor);
            this.children.push($node);
            this.projections++;
        }
    }
    removeView(view, projectionSource) {
        if (this.destinationSlots !== null) {
            ShadowDOM.undistributeView(view, this.destinationSlots, this);
        }
        else if (this.contentView && this.contentView.hasSlots) {
            ShadowDOM.undistributeView(view, this.contentView.slots, projectionSource);
        }
        else {
            let found = this.children.find(x => x.auSlotProjectFrom === projectionSource);
            if (found) {
                let children = found.auProjectionChildren;
                let ownChildren = this.children;
                for (let i = 0, ii = children.length; i < ii; ++i) {
                    let child = children[i];
                    if (child.auOwnerView === view) {
                        children.splice(i, 1);
                        view.fragment.appendChild(child);
                        i--;
                        ii--;
                        this.projections--;
                        let idx = ownChildren.indexOf(child);
                        if (idx > -1) {
                            ownChildren.splice(idx, 1);
                        }
                    }
                }
                if (this.needsFallbackRendering) {
                    this.renderFallbackContent(view, noNodes, projectionSource);
                }
            }
        }
    }
    removeAll(projectionSource) {
        if (this.destinationSlots !== null) {
            ShadowDOM.undistributeAll(this.destinationSlots, this);
        }
        else if (this.contentView && this.contentView.hasSlots) {
            ShadowDOM.undistributeAll(this.contentView.slots, projectionSource);
        }
        else {
            let found = this.children.find(x => x.auSlotProjectFrom === projectionSource);
            if (found) {
                let children = found.auProjectionChildren;
                let ownChildren = this.children;
                for (let i = 0, ii = children.length; i < ii; ++i) {
                    let child = children[i];
                    child.auOwnerView.fragment.appendChild(child);
                    this.projections--;
                    let idx = ownChildren.indexOf(child);
                    if (idx > -1) {
                        ownChildren.splice(idx, 1);
                    }
                }
                found.auProjectionChildren = [];
                if (this.needsFallbackRendering) {
                    this.renderFallbackContent(null, noNodes, projectionSource);
                }
            }
        }
    }
    _findAnchor(view, node, projectionSource, index) {
        if (projectionSource) {
            let found = this.children.find(x => x.auSlotProjectFrom === projectionSource);
            if (found) {
                if (index !== undefined) {
                    let children = found.auProjectionChildren;
                    let viewIndex = -1;
                    let lastView;
                    for (let i = 0, ii = children.length; i < ii; ++i) {
                        let current = children[i];
                        if (current.auOwnerView !== lastView) {
                            viewIndex++;
                            lastView = current.auOwnerView;
                            if (viewIndex >= index && lastView !== view) {
                                children.splice(i, 0, node);
                                return current;
                            }
                        }
                    }
                }
                found.auProjectionChildren.push(node);
                return found;
            }
        }
        return this.anchor;
    }
    projectTo(slots) {
        this.destinationSlots = slots;
    }
    projectFrom(view, projectionSource) {
        let anchor = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createComment('anchor');
        let parent = this.anchor.parentNode;
        anchor.auSlotProjectFrom = projectionSource;
        anchor.auOwnerView = view;
        anchor.auProjectionChildren = [];
        parent.insertBefore(anchor, this.anchor);
        this.children.push(anchor);
        if (this.projectFromAnchors === null) {
            this.projectFromAnchors = [];
        }
        this.projectFromAnchors.push(anchor);
    }
    renderFallbackContent(view, nodes, projectionSource, index) {
        if (this.contentView === null) {
            this.contentView = this.fallbackFactory.create(this.ownerView.container);
            this.contentView.bind(this.ownerView.bindingContext, this.ownerView.overrideContext);
            this.contentView.insertNodesBefore(this.anchor);
        }
        if (this.contentView.hasSlots) {
            let slots = this.contentView.slots;
            let projectFromAnchors = this.projectFromAnchors;
            if (projectFromAnchors !== null) {
                for (let slotName in slots) {
                    let slot = slots[slotName];
                    for (let i = 0, ii = projectFromAnchors.length; i < ii; ++i) {
                        let anchor = projectFromAnchors[i];
                        slot.projectFrom(anchor.auOwnerView, anchor.auSlotProjectFrom);
                    }
                }
            }
            this.fallbackSlots = slots;
            ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index);
        }
    }
    created(ownerView) {
        this.ownerView = ownerView;
    }
    bind(view) {
        if (this.contentView) {
            this.contentView.bind(view.bindingContext, view.overrideContext);
        }
    }
    attached() {
        if (this.contentView) {
            this.contentView.attached();
        }
    }
    detached() {
        if (this.contentView) {
            this.contentView.detached();
        }
    }
    unbind() {
        if (this.contentView) {
            this.contentView.unbind();
        }
    }
}
class ShadowDOM {
    static getSlotName(node) {
        if (node.auSlotAttribute === undefined) {
            return ShadowDOM.defaultSlotKey;
        }
        return node.auSlotAttribute.value;
    }
    static distributeView(view, slots, projectionSource, index, destinationOverride) {
        let nodes;
        if (view === null) {
            nodes = noNodes;
        }
        else {
            let childNodes = view.fragment.childNodes;
            let ii = childNodes.length;
            nodes = new Array(ii);
            for (let i = 0; i < ii; ++i) {
                nodes[i] = childNodes[i];
            }
        }
        ShadowDOM.distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride);
    }
    static undistributeView(view, slots, projectionSource) {
        for (let slotName in slots) {
            slots[slotName].removeView(view, projectionSource);
        }
    }
    static undistributeAll(slots, projectionSource) {
        for (let slotName in slots) {
            slots[slotName].removeAll(projectionSource);
        }
    }
    static distributeNodes(view, nodes, slots, projectionSource, index, destinationOverride) {
        for (let i = 0, ii = nodes.length; i < ii; ++i) {
            let currentNode = nodes[i];
            let nodeType = currentNode.nodeType;
            if (currentNode.isContentProjectionSource) {
                currentNode.viewSlot.projectTo(slots);
                for (let slotName in slots) {
                    slots[slotName].projectFrom(view, currentNode.viewSlot);
                }
                nodes.splice(i, 1);
                ii--;
                i--;
            }
            else if (nodeType === 1 || nodeType === 3 || currentNode.viewSlot instanceof PassThroughSlot) {
                if (nodeType === 3 && _isAllWhitespace(currentNode)) {
                    nodes.splice(i, 1);
                    ii--;
                    i--;
                }
                else {
                    let found = slots[destinationOverride || ShadowDOM.getSlotName(currentNode)];
                    if (found) {
                        found.addNode(view, currentNode, projectionSource, index);
                        nodes.splice(i, 1);
                        ii--;
                        i--;
                    }
                }
            }
            else {
                nodes.splice(i, 1);
                ii--;
                i--;
            }
        }
        for (let slotName in slots) {
            let slot = slots[slotName];
            if (slot.needsFallbackRendering) {
                slot.renderFallbackContent(view, nodes, projectionSource, index);
            }
        }
    }
}
ShadowDOM.defaultSlotKey = '__au-default-slot-key__';

class CompositionTransactionNotifier {
    constructor(owner) {
        this.owner = owner;
        this.owner._compositionCount++;
    }
    done() {
        this.owner._compositionCount--;
        this.owner._tryCompleteTransaction();
    }
}
class CompositionTransactionOwnershipToken {
    constructor(owner) {
        this.owner = owner;
        this.owner._ownershipToken = this;
        this.thenable = this._createThenable();
    }
    waitForCompositionComplete() {
        this.owner._tryCompleteTransaction();
        return this.thenable;
    }
    resolve() {
        this._resolveCallback();
    }
    _resolveCallback() {
        throw new Error("Method not implemented.");
    }
    _createThenable() {
        return new Promise((resolve) => {
            this._resolveCallback = resolve;
        });
    }
}
class CompositionTransaction {
    constructor() {
        this._ownershipToken = null;
        this._compositionCount = 0;
    }
    tryCapture() {
        return this._ownershipToken === null
            ? new CompositionTransactionOwnershipToken(this)
            : null;
    }
    enlist() {
        return new CompositionTransactionNotifier(this);
    }
    _tryCompleteTransaction() {
        if (this._compositionCount <= 0) {
            this._compositionCount = 0;
            if (this._ownershipToken !== null) {
                let token = this._ownershipToken;
                this._ownershipToken = null;
                token.resolve();
            }
        }
    }
}

class View {
    constructor(container, viewFactory, fragment, controllers, bindings, children, slots) {
        this.container = container;
        this.viewFactory = viewFactory;
        this.resources = viewFactory.resources;
        this.fragment = fragment;
        this.firstChild = fragment.firstChild;
        this.lastChild = fragment.lastChild;
        this.controllers = controllers;
        this.bindings = bindings;
        this.children = children;
        this.slots = slots;
        this.hasSlots = false;
        this.fromCache = false;
        this.isBound = false;
        this.isAttached = false;
        this.bindingContext = null;
        this.overrideContext = null;
        this.controller = null;
        this.viewModelScope = null;
        this.animatableElement = undefined;
        this._isUserControlled = false;
        this.contentView = null;
        for (let _ in slots) {
            this.hasSlots = true;
            break;
        }
    }
    returnToCache() {
        this.viewFactory.returnViewToCache(this);
    }
    created() {
        let i;
        let ii;
        let controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
            controllers[i].created(this);
        }
    }
    bind(bindingContext, overrideContext, _systemUpdate) {
        let controllers;
        let bindings;
        let children;
        let i;
        let ii;
        if (_systemUpdate && this._isUserControlled) {
            return;
        }
        if (this.isBound) {
            if (this.bindingContext === bindingContext) {
                return;
            }
            this.unbind();
        }
        this.isBound = true;
        this.bindingContext = bindingContext;
        this.overrideContext = overrideContext || (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.createOverrideContext)(bindingContext);
        this.resources._invokeHook('beforeBind', this);
        bindings = this.bindings;
        for (i = 0, ii = bindings.length; i < ii; ++i) {
            bindings[i].bind(this);
        }
        if (this.viewModelScope !== null) {
            bindingContext.bind(this.viewModelScope.bindingContext, this.viewModelScope.overrideContext);
            this.viewModelScope = null;
        }
        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
            controllers[i].bind(this);
        }
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
            children[i].bind(bindingContext, overrideContext, true);
        }
        if (this.hasSlots) {
            ShadowDOM.distributeView(this.contentView, this.slots);
        }
    }
    addBinding(binding) {
        this.bindings.push(binding);
        if (this.isBound) {
            binding.bind(this);
        }
    }
    unbind() {
        let controllers;
        let bindings;
        let children;
        let i;
        let ii;
        if (this.isBound) {
            this.isBound = false;
            this.resources._invokeHook('beforeUnbind', this);
            if (this.controller !== null) {
                this.controller.unbind();
            }
            bindings = this.bindings;
            for (i = 0, ii = bindings.length; i < ii; ++i) {
                bindings[i].unbind();
            }
            controllers = this.controllers;
            for (i = 0, ii = controllers.length; i < ii; ++i) {
                controllers[i].unbind();
            }
            children = this.children;
            for (i = 0, ii = children.length; i < ii; ++i) {
                children[i].unbind();
            }
            this.bindingContext = null;
            this.overrideContext = null;
        }
    }
    insertNodesBefore(refNode) {
        refNode.parentNode.insertBefore(this.fragment, refNode);
    }
    appendNodesTo(parent) {
        parent.appendChild(this.fragment);
    }
    removeNodes() {
        let fragment = this.fragment;
        let current = this.firstChild;
        let end = this.lastChild;
        let next;
        while (current) {
            next = current.nextSibling;
            fragment.appendChild(current);
            if (current === end) {
                break;
            }
            current = next;
        }
    }
    attached() {
        let controllers;
        let children;
        let i;
        let ii;
        if (this.isAttached) {
            return;
        }
        this.isAttached = true;
        if (this.controller !== null) {
            this.controller.attached();
        }
        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
            controllers[i].attached();
        }
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
            children[i].attached();
        }
    }
    detached() {
        let controllers;
        let children;
        let i;
        let ii;
        if (this.isAttached) {
            this.isAttached = false;
            if (this.controller !== null) {
                this.controller.detached();
            }
            controllers = this.controllers;
            for (i = 0, ii = controllers.length; i < ii; ++i) {
                controllers[i].detached();
            }
            children = this.children;
            for (i = 0, ii = children.length; i < ii; ++i) {
                children[i].detached();
            }
        }
    }
}

class Animator {
    enter(element) {
        return Promise.resolve(false);
    }
    leave(element) {
        return Promise.resolve(false);
    }
    removeClass(element, className) {
        element.classList.remove(className);
        return Promise.resolve(false);
    }
    addClass(element, className) {
        element.classList.add(className);
        return Promise.resolve(false);
    }
    animate(element, className) {
        return Promise.resolve(false);
    }
    runSequence(animations) {
        return Promise.resolve(false);
    }
    registerEffect(effectName, properties) { }
    unregisterEffect(effectName) { }
}

function getAnimatableElement(view) {
    if (view.animatableElement !== undefined) {
        return view.animatableElement;
    }
    let current = view.firstChild;
    while (current && current.nodeType !== 1) {
        current = current.nextSibling;
    }
    if (current && current.nodeType === 1) {
        return (view.animatableElement = current.classList.contains('au-animate') ? current : null);
    }
    return (view.animatableElement = null);
}
class ViewSlot {
    constructor(anchor, anchorIsContainer, animator = Animator.instance) {
        this.anchor = anchor;
        this.anchorIsContainer = anchorIsContainer;
        this.bindingContext = null;
        this.overrideContext = null;
        this.animator = animator;
        this.children = [];
        this.isBound = false;
        this.isAttached = false;
        this.contentSelectors = null;
        anchor.viewSlot = this;
        anchor.isContentProjectionSource = false;
    }
    animateView(view, direction = 'enter') {
        let animatableElement = getAnimatableElement(view);
        if (animatableElement !== null) {
            switch (direction) {
                case 'enter':
                    return this.animator.enter(animatableElement);
                case 'leave':
                    return this.animator.leave(animatableElement);
                default:
                    throw new Error('Invalid animation direction: ' + direction);
            }
        }
    }
    transformChildNodesIntoView() {
        let parent = this.anchor;
        this.children.push({
            fragment: parent,
            firstChild: parent.firstChild,
            lastChild: parent.lastChild,
            returnToCache() { },
            removeNodes() {
                let last;
                while (last = parent.lastChild) {
                    parent.removeChild(last);
                }
            },
            created() { },
            bind() { },
            unbind() { },
            attached() { },
            detached() { }
        });
    }
    bind(bindingContext, overrideContext) {
        let i;
        let ii;
        let children;
        if (this.isBound) {
            if (this.bindingContext === bindingContext) {
                return;
            }
            this.unbind();
        }
        this.isBound = true;
        this.bindingContext = bindingContext = bindingContext || this.bindingContext;
        this.overrideContext = overrideContext = overrideContext || this.overrideContext;
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
            children[i].bind(bindingContext, overrideContext, true);
        }
    }
    unbind() {
        if (this.isBound) {
            let i;
            let ii;
            let children = this.children;
            this.isBound = false;
            this.bindingContext = null;
            this.overrideContext = null;
            for (i = 0, ii = children.length; i < ii; ++i) {
                children[i].unbind();
            }
        }
    }
    add(view) {
        if (this.anchorIsContainer) {
            view.appendNodesTo(this.anchor);
        }
        else {
            view.insertNodesBefore(this.anchor);
        }
        this.children.push(view);
        if (this.isAttached) {
            view.attached();
            return this.animateView(view, 'enter');
        }
    }
    insert(index, view) {
        let children = this.children;
        let length = children.length;
        if ((index === 0 && length === 0) || index >= length) {
            return this.add(view);
        }
        view.insertNodesBefore(children[index].firstChild);
        children.splice(index, 0, view);
        if (this.isAttached) {
            view.attached();
            return this.animateView(view, 'enter');
        }
    }
    move(sourceIndex, targetIndex) {
        if (sourceIndex === targetIndex) {
            return;
        }
        const children = this.children;
        const view = children[sourceIndex];
        view.removeNodes();
        view.insertNodesBefore(children[targetIndex].firstChild);
        children.splice(sourceIndex, 1);
        children.splice(targetIndex, 0, view);
    }
    remove(view, returnToCache, skipAnimation) {
        return this.removeAt(this.children.indexOf(view), returnToCache, skipAnimation);
    }
    removeMany(viewsToRemove, returnToCache, skipAnimation) {
        const children = this.children;
        let ii = viewsToRemove.length;
        let i;
        let rmPromises = [];
        viewsToRemove.forEach(child => {
            if (skipAnimation) {
                child.removeNodes();
                return;
            }
            let animation = this.animateView(child, 'leave');
            if (animation) {
                rmPromises.push(animation.then(() => child.removeNodes()));
            }
            else {
                child.removeNodes();
            }
        });
        let removeAction = () => {
            if (this.isAttached) {
                for (i = 0; i < ii; ++i) {
                    viewsToRemove[i].detached();
                }
            }
            if (returnToCache) {
                for (i = 0; i < ii; ++i) {
                    viewsToRemove[i].returnToCache();
                }
            }
            for (i = 0; i < ii; ++i) {
                const index = children.indexOf(viewsToRemove[i]);
                if (index >= 0) {
                    children.splice(index, 1);
                }
            }
        };
        if (rmPromises.length > 0) {
            return Promise.all(rmPromises).then(() => removeAction());
        }
        return removeAction();
    }
    removeAt(index, returnToCache, skipAnimation) {
        let view = this.children[index];
        let removeAction = () => {
            index = this.children.indexOf(view);
            view.removeNodes();
            this.children.splice(index, 1);
            if (this.isAttached) {
                view.detached();
            }
            if (returnToCache) {
                view.returnToCache();
            }
            return view;
        };
        if (!skipAnimation) {
            let animation = this.animateView(view, 'leave');
            if (animation) {
                return animation.then(() => removeAction());
            }
        }
        return removeAction();
    }
    removeAll(returnToCache, skipAnimation) {
        let children = this.children;
        let ii = children.length;
        let i;
        let rmPromises = [];
        children.forEach(child => {
            if (skipAnimation) {
                child.removeNodes();
                return;
            }
            let animation = this.animateView(child, 'leave');
            if (animation) {
                rmPromises.push(animation.then(() => child.removeNodes()));
            }
            else {
                child.removeNodes();
            }
        });
        let removeAction = () => {
            if (this.isAttached) {
                for (i = 0; i < ii; ++i) {
                    children[i].detached();
                }
            }
            if (returnToCache) {
                for (i = 0; i < ii; ++i) {
                    const child = children[i];
                    if (child) {
                        child.returnToCache();
                    }
                }
            }
            this.children = [];
        };
        if (rmPromises.length > 0) {
            return Promise.all(rmPromises).then(() => removeAction());
        }
        return removeAction();
    }
    attached() {
        let i;
        let ii;
        let children;
        let child;
        if (this.isAttached) {
            return;
        }
        this.isAttached = true;
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
            child = children[i];
            child.attached();
            this.animateView(child, 'enter');
        }
    }
    detached() {
        let i;
        let ii;
        let children;
        if (this.isAttached) {
            this.isAttached = false;
            children = this.children;
            for (i = 0, ii = children.length; i < ii; ++i) {
                children[i].detached();
            }
        }
    }
    projectTo(slots) {
        this.projectToSlots = slots;
        this.add = this._projectionAdd;
        this.insert = this._projectionInsert;
        this.move = this._projectionMove;
        this.remove = this._projectionRemove;
        this.removeAt = this._projectionRemoveAt;
        this.removeMany = this._projectionRemoveMany;
        this.removeAll = this._projectionRemoveAll;
        this.children.forEach(view => ShadowDOM.distributeView(view, slots, this));
    }
    _projectionAdd(view) {
        ShadowDOM.distributeView(view, this.projectToSlots, this);
        this.children.push(view);
        if (this.isAttached) {
            view.attached();
        }
    }
    _projectionInsert(index, view) {
        if ((index === 0 && !this.children.length) || index >= this.children.length) {
            this.add(view);
        }
        else {
            ShadowDOM.distributeView(view, this.projectToSlots, this, index);
            this.children.splice(index, 0, view);
            if (this.isAttached) {
                view.attached();
            }
        }
    }
    _projectionMove(sourceIndex, targetIndex) {
        if (sourceIndex === targetIndex) {
            return;
        }
        const children = this.children;
        const view = children[sourceIndex];
        ShadowDOM.undistributeView(view, this.projectToSlots, this);
        ShadowDOM.distributeView(view, this.projectToSlots, this, targetIndex);
        children.splice(sourceIndex, 1);
        children.splice(targetIndex, 0, view);
    }
    _projectionRemove(view, returnToCache) {
        ShadowDOM.undistributeView(view, this.projectToSlots, this);
        this.children.splice(this.children.indexOf(view), 1);
        if (this.isAttached) {
            view.detached();
        }
        if (returnToCache) {
            view.returnToCache();
        }
    }
    _projectionRemoveAt(index, returnToCache) {
        let view = this.children[index];
        ShadowDOM.undistributeView(view, this.projectToSlots, this);
        this.children.splice(index, 1);
        if (this.isAttached) {
            view.detached();
        }
        if (returnToCache) {
            view.returnToCache();
        }
    }
    _projectionRemoveMany(viewsToRemove, returnToCache) {
        viewsToRemove.forEach(view => this.remove(view, returnToCache));
    }
    _projectionRemoveAll(returnToCache) {
        ShadowDOM.undistributeAll(this.projectToSlots, this);
        let children = this.children;
        let ii = children.length;
        for (let i = 0; i < ii; ++i) {
            if (returnToCache) {
                children[i].returnToCache();
            }
            else if (this.isAttached) {
                children[i].detached();
            }
        }
        this.children = [];
    }
}

const $resolver = aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_6__.resolver;
let ProviderResolver = class ProviderResolver {
    get(container, key) {
        let id = key.__providerId__;
        return id in container ? container[id] : (container[id] = container.invoke(key));
    }
};
ProviderResolver = __decorate([
    $resolver
], ProviderResolver);
let providerResolverInstance = new ProviderResolver();
function elementContainerGet(key) {
    if (key === aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.Element) {
        return this.element;
    }
    if (key === BoundViewFactory) {
        if (this.boundViewFactory) {
            return this.boundViewFactory;
        }
        let factory = this.instruction.viewFactory;
        let partReplacements = this.partReplacements;
        if (partReplacements) {
            factory = partReplacements[factory.part] || factory;
        }
        this.boundViewFactory = new BoundViewFactory(this, factory, partReplacements);
        return this.boundViewFactory;
    }
    if (key === ViewSlot) {
        if (this.viewSlot === undefined) {
            this.viewSlot = new ViewSlot(this.element, this.instruction.anchorIsContainer);
            this.element.isContentProjectionSource = this.instruction.lifting;
            this.children.push(this.viewSlot);
        }
        return this.viewSlot;
    }
    if (key === ElementEvents) {
        return this.elementEvents || (this.elementEvents = new ElementEvents(this.element));
    }
    if (key === CompositionTransaction) {
        return this.compositionTransaction || (this.compositionTransaction = this.parent.get(key));
    }
    if (key === ViewResources) {
        return this.viewResources;
    }
    if (key === TargetInstruction) {
        return this.instruction;
    }
    return this.superGet(key);
}
function createElementContainer(parent, element, instruction, children, partReplacements, resources) {
    let container = parent.createChild();
    let providers;
    let i;
    container.element = element;
    container.instruction = instruction;
    container.children = children;
    container.viewResources = resources;
    container.partReplacements = partReplacements;
    providers = instruction.providers;
    i = providers.length;
    while (i--) {
        container._resolvers.set(providers[i], providerResolverInstance);
    }
    container.superGet = container.get;
    container.get = elementContainerGet;
    return container;
}
function hasAttribute(name) {
    return this._element.hasAttribute(name);
}
function getAttribute(name) {
    return this._element.getAttribute(name);
}
function setAttribute(name, value) {
    this._element.setAttribute(name, value);
}
function makeElementIntoAnchor(element, elementInstruction) {
    let anchor = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createComment('anchor');
    if (elementInstruction) {
        let firstChild = element.firstChild;
        if (firstChild && firstChild.tagName === 'AU-CONTENT') {
            anchor.contentElement = firstChild;
        }
        anchor._element = element;
        anchor.hasAttribute = hasAttribute;
        anchor.getAttribute = getAttribute;
        anchor.setAttribute = setAttribute;
    }
    aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.replaceNode(anchor, element);
    return anchor;
}
function applyInstructions(containers, element, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources) {
    let behaviorInstructions = instruction.behaviorInstructions;
    let expressions = instruction.expressions;
    let elementContainer;
    let i;
    let ii;
    let current;
    let instance;
    if (instruction.contentExpression) {
        bindings.push(instruction.contentExpression.createBinding(element.nextSibling));
        element.nextSibling.auInterpolationTarget = true;
        element.parentNode.removeChild(element);
        return;
    }
    if (instruction.shadowSlot) {
        let commentAnchor = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createComment('slot');
        let slot;
        if (instruction.slotDestination) {
            slot = new PassThroughSlot(commentAnchor, instruction.slotName, instruction.slotDestination, instruction.slotFallbackFactory);
        }
        else {
            slot = new ShadowSlot(commentAnchor, instruction.slotName, instruction.slotFallbackFactory);
        }
        aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.replaceNode(commentAnchor, element);
        shadowSlots[instruction.slotName] = slot;
        controllers.push(slot);
        return;
    }
    if (instruction.letElement) {
        for (i = 0, ii = expressions.length; i < ii; ++i) {
            bindings.push(expressions[i].createBinding());
        }
        element.parentNode.removeChild(element);
        return;
    }
    if (behaviorInstructions.length) {
        if (!instruction.anchorIsContainer) {
            element = makeElementIntoAnchor(element, instruction.elementInstruction);
        }
        containers[instruction.injectorId] = elementContainer =
            createElementContainer(containers[instruction.parentInjectorId], element, instruction, children, partReplacements, resources);
        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
            current = behaviorInstructions[i];
            instance = current.type.create(elementContainer, current, element, bindings);
            controllers.push(instance);
        }
    }
    for (i = 0, ii = expressions.length; i < ii; ++i) {
        bindings.push(expressions[i].createBinding(element));
    }
}
function styleStringToObject(style, target) {
    let attributes = style.split(';');
    let firstIndexOfColon;
    let i;
    let current;
    let key;
    let value;
    target = target || {};
    for (i = 0; i < attributes.length; i++) {
        current = attributes[i];
        firstIndexOfColon = current.indexOf(':');
        key = current.substring(0, firstIndexOfColon).trim();
        value = current.substring(firstIndexOfColon + 1).trim();
        target[key] = value;
    }
    return target;
}
function styleObjectToString(obj) {
    let result = '';
    for (let key in obj) {
        result += key + ':' + obj[key] + ';';
    }
    return result;
}
function applySurrogateInstruction(container, element, instruction, controllers, bindings, children) {
    let behaviorInstructions = instruction.behaviorInstructions;
    let expressions = instruction.expressions;
    let providers = instruction.providers;
    let values = instruction.values;
    let i;
    let ii;
    let current;
    let instance;
    let currentAttributeValue;
    i = providers.length;
    while (i--) {
        container._resolvers.set(providers[i], providerResolverInstance);
    }
    for (let key in values) {
        currentAttributeValue = element.getAttribute(key);
        if (currentAttributeValue) {
            if (key === 'class') {
                element.setAttribute('class', currentAttributeValue + ' ' + values[key]);
            }
            else if (key === 'style') {
                let styleObject = styleStringToObject(values[key]);
                styleStringToObject(currentAttributeValue, styleObject);
                element.setAttribute('style', styleObjectToString(styleObject));
            }
        }
        else {
            element.setAttribute(key, values[key]);
        }
    }
    if (behaviorInstructions.length) {
        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
            current = behaviorInstructions[i];
            instance = current.type.create(container, current, element, bindings);
            if (instance.contentView) {
                children.push(instance.contentView);
            }
            controllers.push(instance);
        }
    }
    for (i = 0, ii = expressions.length; i < ii; ++i) {
        bindings.push(expressions[i].createBinding(element));
    }
}
class BoundViewFactory {
    constructor(parentContainer, viewFactory, partReplacements) {
        this.parentContainer = parentContainer;
        this.viewFactory = viewFactory;
        this.factoryCreateInstruction = { partReplacements: partReplacements };
    }
    create() {
        let view = this.viewFactory.create(this.parentContainer.createChild(), this.factoryCreateInstruction);
        view._isUserControlled = true;
        return view;
    }
    get isCaching() {
        return this.viewFactory.isCaching;
    }
    setCacheSize(size, doNotOverrideIfAlreadySet) {
        this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
    }
    getCachedView() {
        return this.viewFactory.getCachedView();
    }
    returnViewToCache(view) {
        this.viewFactory.returnViewToCache(view);
    }
}
class ViewFactory {
    constructor(template, instructions, resources) {
        this.isCaching = false;
        this.template = template;
        this.instructions = instructions;
        this.resources = resources;
        this.cacheSize = -1;
        this.cache = null;
    }
    setCacheSize(size, doNotOverrideIfAlreadySet) {
        if (size) {
            if (size === '*') {
                size = Number.MAX_VALUE;
            }
            else if (typeof size === 'string') {
                size = parseInt(size, 10);
            }
        }
        if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
            this.cacheSize = Number(size);
        }
        if (this.cacheSize > 0) {
            this.cache = [];
        }
        else {
            this.cache = null;
        }
        this.isCaching = this.cacheSize > 0;
    }
    getCachedView() {
        return this.cache !== null ? (this.cache.pop() || null) : null;
    }
    returnViewToCache(view) {
        if (view.isAttached) {
            view.detached();
        }
        if (view.isBound) {
            view.unbind();
        }
        if (this.cache !== null && this.cache.length < this.cacheSize) {
            view.fromCache = true;
            this.cache.push(view);
        }
    }
    create(container, createInstruction, element) {
        createInstruction = createInstruction || BehaviorInstruction.normal;
        let cachedView = this.getCachedView();
        if (cachedView !== null) {
            return cachedView;
        }
        let fragment = createInstruction.enhance ? this.template : this.template.cloneNode(true);
        let instructables = fragment.querySelectorAll('.au-target');
        let instructions = this.instructions;
        let resources = this.resources;
        let controllers = [];
        let bindings = [];
        let children = [];
        let shadowSlots = Object.create(null);
        let containers = { root: container };
        let partReplacements = createInstruction.partReplacements;
        let i;
        let ii;
        let view;
        let instructable;
        let instruction;
        this.resources._invokeHook('beforeCreate', this, container, fragment, createInstruction);
        if (element && this.surrogateInstruction !== null) {
            applySurrogateInstruction(container, element, this.surrogateInstruction, controllers, bindings, children);
        }
        if (createInstruction.enhance && fragment.hasAttribute('au-target-id')) {
            instructable = fragment;
            instruction = instructions[instructable.getAttribute('au-target-id')];
            applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
        }
        for (i = 0, ii = instructables.length; i < ii; ++i) {
            instructable = instructables[i];
            instruction = instructions[instructable.getAttribute('au-target-id')];
            applyInstructions(containers, instructable, instruction, controllers, bindings, children, shadowSlots, partReplacements, resources);
        }
        view = new View(container, this, fragment, controllers, bindings, children, shadowSlots);
        if (!createInstruction.initiatedByBehavior) {
            view.created();
        }
        this.resources._invokeHook('afterCreate', view);
        return view;
    }
}

let nextInjectorId = 0;
function getNextInjectorId() {
    return ++nextInjectorId;
}
let lastAUTargetID = 0;
function getNextAUTargetID() {
    return (++lastAUTargetID).toString();
}
function makeIntoInstructionTarget(element) {
    let value = element.getAttribute('class');
    let auTargetID = getNextAUTargetID();
    element.setAttribute('class', (value ? value + ' au-target' : 'au-target'));
    element.setAttribute('au-target-id', auTargetID);
    return auTargetID;
}
function makeShadowSlot(compiler, resources, node, instructions, parentInjectorId) {
    let auShadowSlot = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createElement('au-shadow-slot');
    aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.replaceNode(auShadowSlot, node);
    let auTargetID = makeIntoInstructionTarget(auShadowSlot);
    let instruction = TargetInstruction.shadowSlot(parentInjectorId);
    instruction.slotName = node.getAttribute('name') || ShadowDOM.defaultSlotKey;
    instruction.slotDestination = node.getAttribute('slot');
    if (node.innerHTML.trim()) {
        let fragment = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createDocumentFragment();
        let child;
        while (child = node.firstChild) {
            fragment.appendChild(child);
        }
        instruction.slotFallbackFactory = compiler.compile(fragment, resources);
    }
    instructions[auTargetID] = instruction;
    return auShadowSlot;
}
const defaultLetHandler = BindingLanguage.prototype.createLetExpressions;
class ViewCompiler {
    constructor(bindingLanguage, resources) {
        this.bindingLanguage = bindingLanguage;
        this.resources = resources;
    }
    static inject() {
        return [BindingLanguage, ViewResources];
    }
    compile(source, resources, compileInstruction) {
        resources = resources || this.resources;
        compileInstruction = compileInstruction || ViewCompileInstruction.normal;
        source = typeof source === 'string' ? aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createTemplateFromMarkup(source) : source;
        let content;
        let part;
        let cacheSize;
        if (source.content) {
            part = source.getAttribute('part');
            cacheSize = source.getAttribute('view-cache');
            content = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.adoptNode(source.content);
        }
        else {
            content = source;
        }
        compileInstruction.targetShadowDOM = compileInstruction.targetShadowDOM && aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.FEATURE.shadowDOM;
        resources._invokeHook('beforeCompile', content, resources, compileInstruction);
        let instructions = {};
        this._compileNode(content, resources, instructions, source, 'root', !compileInstruction.targetShadowDOM);
        let firstChild = content.firstChild;
        if (firstChild && firstChild.nodeType === 1) {
            let targetId = firstChild.getAttribute('au-target-id');
            if (targetId) {
                let ins = instructions[targetId];
                if (ins.shadowSlot || ins.lifting || (ins.elementInstruction && !ins.elementInstruction.anchorIsContainer)) {
                    content.insertBefore(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createComment('view'), firstChild);
                }
            }
        }
        let factory = new ViewFactory(content, instructions, resources);
        factory.surrogateInstruction = compileInstruction.compileSurrogate ? this._compileSurrogate(source, resources) : null;
        factory.part = part;
        if (cacheSize) {
            factory.setCacheSize(cacheSize);
        }
        resources._invokeHook('afterCompile', factory);
        return factory;
    }
    _compileNode(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
        switch (node.nodeType) {
            case 1:
                return this._compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM);
            case 3:
                let expression = resources.getBindingLanguage(this.bindingLanguage).inspectTextContent(resources, node.wholeText);
                if (expression) {
                    let marker = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createElement('au-marker');
                    let auTargetID = makeIntoInstructionTarget(marker);
                    (node.parentNode || parentNode).insertBefore(marker, node);
                    node.textContent = ' ';
                    instructions[auTargetID] = TargetInstruction.contentExpression(expression);
                    while (node.nextSibling && node.nextSibling.nodeType === 3) {
                        (node.parentNode || parentNode).removeChild(node.nextSibling);
                    }
                }
                else {
                    while (node.nextSibling && node.nextSibling.nodeType === 3) {
                        node = node.nextSibling;
                    }
                }
                return node.nextSibling;
            case 11:
                let currentChild = node.firstChild;
                while (currentChild) {
                    currentChild = this._compileNode(currentChild, resources, instructions, node, parentInjectorId, targetLightDOM);
                }
                break;
        }
        return node.nextSibling;
    }
    _compileSurrogate(node, resources) {
        let tagName = node.tagName.toLowerCase();
        let attributes = node.attributes;
        let bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
        let knownAttribute;
        let property;
        let instruction;
        let i;
        let ii;
        let attr;
        let attrName;
        let attrValue;
        let info;
        let type;
        let expressions = [];
        let expression;
        let behaviorInstructions = [];
        let values = {};
        let hasValues = false;
        let providers = [];
        for (i = 0, ii = attributes.length; i < ii; ++i) {
            attr = attributes[i];
            attrName = attr.name;
            attrValue = attr.value;
            info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);
            type = resources.getAttribute(info.attrName);
            if (type) {
                knownAttribute = resources.mapAttribute(info.attrName);
                if (knownAttribute) {
                    property = type.attributes[knownAttribute];
                    if (property) {
                        info.defaultBindingMode = property.defaultBindingMode;
                        if (!info.command && !info.expression) {
                            info.command = property.hasOptions ? 'options' : null;
                        }
                        if (info.command && (info.command !== 'options') && type.primaryProperty) {
                            const primaryProperty = type.primaryProperty;
                            attrName = info.attrName = primaryProperty.attribute;
                            info.defaultBindingMode = primaryProperty.defaultBindingMode;
                        }
                    }
                }
            }
            instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
            if (instruction) {
                if (instruction.alteredAttr) {
                    type = resources.getAttribute(instruction.attrName);
                }
                if (instruction.discrete) {
                    expressions.push(instruction);
                }
                else {
                    if (type) {
                        instruction.type = type;
                        this._configureProperties(instruction, resources);
                        if (type.liftsContent) {
                            throw new Error('You cannot place a template controller on a surrogate element.');
                        }
                        else {
                            behaviorInstructions.push(instruction);
                        }
                    }
                    else {
                        expressions.push(instruction.attributes[instruction.attrName]);
                    }
                }
            }
            else {
                if (type) {
                    instruction = BehaviorInstruction.attribute(attrName, type);
                    instruction.attributes[resources.mapAttribute(attrName)] = attrValue;
                    if (type.liftsContent) {
                        throw new Error('You cannot place a template controller on a surrogate element.');
                    }
                    else {
                        behaviorInstructions.push(instruction);
                    }
                }
                else if (attrName !== 'id' && attrName !== 'part' && attrName !== 'replace-part') {
                    hasValues = true;
                    values[attrName] = attrValue;
                }
            }
        }
        if (expressions.length || behaviorInstructions.length || hasValues) {
            for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
                instruction = behaviorInstructions[i];
                instruction.type.compile(this, resources, node, instruction);
                providers.push(instruction.type.target);
            }
            for (i = 0, ii = expressions.length; i < ii; ++i) {
                expression = expressions[i];
                if (expression.attrToRemove !== undefined) {
                    node.removeAttribute(expression.attrToRemove);
                }
            }
            return TargetInstruction.surrogate(providers, behaviorInstructions, expressions, values);
        }
        return null;
    }
    _compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
        let tagName = node.tagName.toLowerCase();
        let attributes = node.attributes;
        let expressions = [];
        let expression;
        let behaviorInstructions = [];
        let providers = [];
        let bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
        let liftingInstruction;
        let viewFactory;
        let type;
        let elementInstruction;
        let elementProperty;
        let i;
        let ii;
        let attr;
        let attrName;
        let attrValue;
        let originalAttrName;
        let instruction;
        let info;
        let property;
        let knownAttribute;
        let auTargetID;
        let injectorId;
        if (tagName === 'slot') {
            if (targetLightDOM) {
                node = makeShadowSlot(this, resources, node, instructions, parentInjectorId);
            }
            return node.nextSibling;
        }
        else if (tagName === 'template') {
            if (!('content' in node)) {
                throw new Error('You cannot place a template element within ' + node.namespaceURI + ' namespace');
            }
            viewFactory = this.compile(node, resources);
            viewFactory.part = node.getAttribute('part');
        }
        else {
            type = resources.getElement(node.getAttribute('as-element') || tagName);
            if (tagName === 'let' && !type && bindingLanguage.createLetExpressions !== defaultLetHandler) {
                expressions = bindingLanguage.createLetExpressions(resources, node);
                auTargetID = makeIntoInstructionTarget(node);
                instructions[auTargetID] = TargetInstruction.letElement(expressions);
                return node.nextSibling;
            }
            if (type) {
                elementInstruction = BehaviorInstruction.element(node, type);
                type.processAttributes(this, resources, node, attributes, elementInstruction);
                behaviorInstructions.push(elementInstruction);
            }
        }
        for (i = 0, ii = attributes.length; i < ii; ++i) {
            attr = attributes[i];
            originalAttrName = attrName = attr.name;
            attrValue = attr.value;
            info = bindingLanguage.inspectAttribute(resources, tagName, attrName, attrValue);
            if (targetLightDOM && info.attrName === 'slot') {
                info.attrName = attrName = 'au-slot';
            }
            type = resources.getAttribute(info.attrName);
            elementProperty = null;
            if (type) {
                knownAttribute = resources.mapAttribute(info.attrName);
                if (knownAttribute) {
                    property = type.attributes[knownAttribute];
                    if (property) {
                        info.defaultBindingMode = property.defaultBindingMode;
                        if (!info.command && !info.expression) {
                            info.command = property.hasOptions ? 'options' : null;
                        }
                        if (info.command && (info.command !== 'options') && type.primaryProperty) {
                            const primaryProperty = type.primaryProperty;
                            attrName = info.attrName = primaryProperty.attribute;
                            info.defaultBindingMode = primaryProperty.defaultBindingMode;
                        }
                    }
                }
            }
            else if (elementInstruction) {
                elementProperty = elementInstruction.type.attributes[info.attrName];
                if (elementProperty) {
                    info.defaultBindingMode = elementProperty.defaultBindingMode;
                }
            }
            if (elementProperty) {
                instruction = bindingLanguage.createAttributeInstruction(resources, node, info, elementInstruction);
            }
            else {
                instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
            }
            if (instruction) {
                if (instruction.alteredAttr) {
                    type = resources.getAttribute(instruction.attrName);
                }
                if (instruction.discrete) {
                    expressions.push(instruction);
                }
                else {
                    if (type) {
                        instruction.type = type;
                        this._configureProperties(instruction, resources);
                        if (type.liftsContent) {
                            instruction.originalAttrName = originalAttrName;
                            liftingInstruction = instruction;
                            break;
                        }
                        else {
                            behaviorInstructions.push(instruction);
                        }
                    }
                    else if (elementProperty) {
                        elementInstruction.attributes[info.attrName].targetProperty = elementProperty.name;
                    }
                    else {
                        expressions.push(instruction.attributes[instruction.attrName]);
                    }
                }
            }
            else {
                if (type) {
                    instruction = BehaviorInstruction.attribute(attrName, type);
                    instruction.attributes[resources.mapAttribute(attrName)] = attrValue;
                    if (type.liftsContent) {
                        instruction.originalAttrName = originalAttrName;
                        liftingInstruction = instruction;
                        break;
                    }
                    else {
                        behaviorInstructions.push(instruction);
                    }
                }
                else if (elementProperty) {
                    elementInstruction.attributes[attrName] = attrValue;
                }
            }
        }
        if (liftingInstruction) {
            liftingInstruction.viewFactory = viewFactory;
            node = liftingInstruction.type.compile(this, resources, node, liftingInstruction, parentNode);
            auTargetID = makeIntoInstructionTarget(node);
            instructions[auTargetID] = TargetInstruction.lifting(parentInjectorId, liftingInstruction);
        }
        else {
            let skipContentProcessing = false;
            if (expressions.length || behaviorInstructions.length) {
                injectorId = behaviorInstructions.length ? getNextInjectorId() : false;
                for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
                    instruction = behaviorInstructions[i];
                    instruction.type.compile(this, resources, node, instruction, parentNode);
                    providers.push(instruction.type.target);
                    skipContentProcessing = skipContentProcessing || instruction.skipContentProcessing;
                }
                for (i = 0, ii = expressions.length; i < ii; ++i) {
                    expression = expressions[i];
                    if (expression.attrToRemove !== undefined) {
                        node.removeAttribute(expression.attrToRemove);
                    }
                }
                auTargetID = makeIntoInstructionTarget(node);
                instructions[auTargetID] = TargetInstruction.normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction);
            }
            if (skipContentProcessing) {
                return node.nextSibling;
            }
            let currentChild = node.firstChild;
            while (currentChild) {
                currentChild = this._compileNode(currentChild, resources, instructions, node, injectorId || parentInjectorId, targetLightDOM);
            }
        }
        return node.nextSibling;
    }
    _configureProperties(instruction, resources) {
        let type = instruction.type;
        let attrName = instruction.attrName;
        let attributes = instruction.attributes;
        let property;
        let key;
        let value;
        let knownAttribute = resources.mapAttribute(attrName);
        if (knownAttribute && attrName in attributes && knownAttribute !== attrName) {
            attributes[knownAttribute] = attributes[attrName];
            delete attributes[attrName];
        }
        for (key in attributes) {
            value = attributes[key];
            if (value !== null && typeof value === 'object') {
                property = type.attributes[key];
                if (property !== undefined) {
                    value.targetProperty = property.name;
                }
                else {
                    value.targetProperty = key;
                }
            }
        }
    }
}

class ViewEngineHooksResource {
    initialize(container, target) {
        this.instance = container.get(target);
    }
    register(registry, name) {
        registry.registerViewEngineHooks(this.instance);
    }
    load(container, target) { }
    static convention(name) {
        if (name.endsWith('ViewEngineHooks')) {
            return new ViewEngineHooksResource();
        }
    }
}
function viewEngineHooks(target) {
    let deco = function (t) {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, new ViewEngineHooksResource(), t);
    };
    return target ? deco(target) : deco;
}

class ResourceModule {
    constructor(moduleId) {
        this.id = moduleId;
        this.moduleInstance = null;
        this.mainResource = null;
        this.resources = null;
        this.viewStrategy = null;
        this.isInitialized = false;
        this.onLoaded = null;
        this.loadContext = null;
    }
    initialize(container) {
        let current = this.mainResource;
        let resources = this.resources;
        let vs = this.viewStrategy;
        if (this.isInitialized) {
            return;
        }
        this.isInitialized = true;
        if (current !== undefined) {
            current.metadata.viewStrategy = vs;
            current.initialize(container);
        }
        for (let i = 0, ii = resources.length; i < ii; ++i) {
            current = resources[i];
            current.metadata.viewStrategy = vs;
            current.initialize(container);
        }
    }
    register(registry, name) {
        let main = this.mainResource;
        let resources = this.resources;
        if (main !== undefined) {
            main.register(registry, name);
            name = null;
        }
        for (let i = 0, ii = resources.length; i < ii; ++i) {
            resources[i].register(registry, name);
            name = null;
        }
    }
    load(container, loadContext) {
        if (this.onLoaded !== null) {
            return this.loadContext === loadContext ? Promise.resolve() : this.onLoaded;
        }
        let main = this.mainResource;
        let resources = this.resources;
        let loads;
        if (main !== undefined) {
            loads = new Array(resources.length + 1);
            loads[0] = main.load(container, loadContext);
            for (let i = 0, ii = resources.length; i < ii; ++i) {
                loads[i + 1] = resources[i].load(container, loadContext);
            }
        }
        else {
            loads = new Array(resources.length);
            for (let i = 0, ii = resources.length; i < ii; ++i) {
                loads[i] = resources[i].load(container, loadContext);
            }
        }
        this.loadContext = loadContext;
        this.onLoaded = Promise.all(loads);
        return this.onLoaded;
    }
}
class ResourceDescription {
    constructor(key, exportedValue, resourceTypeMeta) {
        if (!resourceTypeMeta) {
            resourceTypeMeta = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.get(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, exportedValue);
            if (!resourceTypeMeta) {
                resourceTypeMeta = new HtmlBehaviorResource();
                resourceTypeMeta.elementName = _hyphenate(key);
                aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, resourceTypeMeta, exportedValue);
            }
        }
        if (resourceTypeMeta instanceof HtmlBehaviorResource) {
            if (resourceTypeMeta.elementName === undefined) {
                resourceTypeMeta.elementName = _hyphenate(key);
            }
            else if (resourceTypeMeta.attributeName === undefined) {
                resourceTypeMeta.attributeName = _hyphenate(key);
            }
            else if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
                HtmlBehaviorResource.convention(key, resourceTypeMeta);
            }
        }
        else if (!resourceTypeMeta.name) {
            resourceTypeMeta.name = _hyphenate(key);
        }
        this.metadata = resourceTypeMeta;
        this.value = exportedValue;
    }
    initialize(container) {
        this.metadata.initialize(container, this.value);
    }
    register(registry, name) {
        this.metadata.register(registry, name);
    }
    load(container, loadContext) {
        return this.metadata.load(container, this.value, loadContext);
    }
}
class ModuleAnalyzer {
    constructor() {
        this.cache = Object.create(null);
    }
    getAnalysis(moduleId) {
        return this.cache[moduleId];
    }
    analyze(moduleId, moduleInstance, mainResourceKey) {
        let mainResource;
        let fallbackValue;
        let fallbackKey;
        let resourceTypeMeta;
        let key;
        let exportedValue;
        let resources = [];
        let conventional;
        let vs;
        let resourceModule;
        resourceModule = this.cache[moduleId];
        if (resourceModule) {
            return resourceModule;
        }
        resourceModule = new ResourceModule(moduleId);
        this.cache[moduleId] = resourceModule;
        if (typeof moduleInstance === 'function') {
            moduleInstance = { 'default': moduleInstance };
        }
        if (mainResourceKey) {
            mainResource = new ResourceDescription(mainResourceKey, moduleInstance[mainResourceKey]);
        }
        for (key in moduleInstance) {
            exportedValue = moduleInstance[key];
            if (key === mainResourceKey || typeof exportedValue !== 'function') {
                continue;
            }
            resourceTypeMeta = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.get(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, exportedValue);
            if (resourceTypeMeta) {
                if (resourceTypeMeta instanceof HtmlBehaviorResource) {
                    ViewResources.convention(exportedValue, resourceTypeMeta);
                    if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
                        HtmlBehaviorResource.convention(key, resourceTypeMeta);
                    }
                    if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
                        resourceTypeMeta.elementName = _hyphenate(key);
                    }
                }
                if (!mainResource && resourceTypeMeta instanceof HtmlBehaviorResource && resourceTypeMeta.elementName !== null) {
                    mainResource = new ResourceDescription(key, exportedValue, resourceTypeMeta);
                }
                else {
                    resources.push(new ResourceDescription(key, exportedValue, resourceTypeMeta));
                }
            }
            else if (viewStrategy.decorates(exportedValue)) {
                vs = exportedValue;
            }
            else if (exportedValue instanceof aurelia_loader__WEBPACK_IMPORTED_MODULE_1__.TemplateRegistryEntry) {
                vs = new TemplateRegistryViewStrategy(moduleId, exportedValue);
            }
            else {
                if (conventional = ViewResources.convention(exportedValue)) {
                    if (conventional.elementName !== null && !mainResource) {
                        mainResource = new ResourceDescription(key, exportedValue, conventional);
                    }
                    else {
                        resources.push(new ResourceDescription(key, exportedValue, conventional));
                    }
                    aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, conventional, exportedValue);
                }
                else if (conventional = HtmlBehaviorResource.convention(key)) {
                    if (conventional.elementName !== null && !mainResource) {
                        mainResource = new ResourceDescription(key, exportedValue, conventional);
                    }
                    else {
                        resources.push(new ResourceDescription(key, exportedValue, conventional));
                    }
                    aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, conventional, exportedValue);
                }
                else if (conventional = aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.ValueConverterResource.convention(key)
                    || aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.BindingBehaviorResource.convention(key)
                    || ViewEngineHooksResource.convention(key)) {
                    resources.push(new ResourceDescription(key, exportedValue, conventional));
                    aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, conventional, exportedValue);
                }
                else if (!fallbackValue) {
                    fallbackValue = exportedValue;
                    fallbackKey = key;
                }
            }
        }
        if (!mainResource && fallbackValue) {
            mainResource = new ResourceDescription(fallbackKey, fallbackValue);
        }
        resourceModule.moduleInstance = moduleInstance;
        resourceModule.mainResource = mainResource;
        resourceModule.resources = resources;
        resourceModule.viewStrategy = vs;
        return resourceModule;
    }
}

let logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_4__.getLogger('templating');
function ensureRegistryEntry(loader, urlOrRegistryEntry) {
    if (urlOrRegistryEntry instanceof aurelia_loader__WEBPACK_IMPORTED_MODULE_1__.TemplateRegistryEntry) {
        return Promise.resolve(urlOrRegistryEntry);
    }
    return loader.loadTemplate(urlOrRegistryEntry);
}
class ProxyViewFactory {
    constructor(promise) {
        promise.then(x => this.viewFactory = x);
    }
    create(container, bindingContext, createInstruction, element) {
        return this.viewFactory.create(container, bindingContext, createInstruction, element);
    }
    get isCaching() {
        return this.viewFactory.isCaching;
    }
    setCacheSize(size, doNotOverrideIfAlreadySet) {
        this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
    }
    getCachedView() {
        return this.viewFactory.getCachedView();
    }
    returnViewToCache(view) {
        this.viewFactory.returnViewToCache(view);
    }
}
let auSlotBehavior = null;
class ViewEngine {
    constructor(loader, container, viewCompiler, moduleAnalyzer, appResources) {
        this.loader = loader;
        this.container = container;
        this.viewCompiler = viewCompiler;
        this.moduleAnalyzer = moduleAnalyzer;
        this.appResources = appResources;
        this._pluginMap = {};
        if (auSlotBehavior === null) {
            auSlotBehavior = new HtmlBehaviorResource();
            auSlotBehavior.attributeName = 'au-slot';
            aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, auSlotBehavior, SlotCustomAttribute);
        }
        auSlotBehavior.initialize(container, SlotCustomAttribute);
        auSlotBehavior.register(appResources);
    }
    static inject() {
        return [aurelia_loader__WEBPACK_IMPORTED_MODULE_1__.Loader, aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_6__.Container, ViewCompiler, ModuleAnalyzer, ViewResources];
    }
    addResourcePlugin(extension, implementation) {
        let name = extension.replace('.', '') + '-resource-plugin';
        this._pluginMap[extension] = name;
        this.loader.addPlugin(name, implementation);
    }
    loadViewFactory(urlOrRegistryEntry, compileInstruction, loadContext, target) {
        loadContext = loadContext || new ResourceLoadContext();
        return ensureRegistryEntry(this.loader, urlOrRegistryEntry).then(registryEntry => {
            const url = registryEntry.address;
            if (registryEntry.onReady) {
                if (!loadContext.hasDependency(url)) {
                    loadContext.addDependency(url);
                    return registryEntry.onReady;
                }
                if (registryEntry.template === null) {
                    return registryEntry.onReady;
                }
                return Promise.resolve(new ProxyViewFactory(registryEntry.onReady));
            }
            loadContext.addDependency(url);
            registryEntry.onReady = this.loadTemplateResources(registryEntry, compileInstruction, loadContext, target).then(resources => {
                registryEntry.resources = resources;
                if (registryEntry.template === null) {
                    return registryEntry.factory = null;
                }
                let viewFactory = this.viewCompiler.compile(registryEntry.template, resources, compileInstruction);
                return registryEntry.factory = viewFactory;
            });
            return registryEntry.onReady;
        });
    }
    loadTemplateResources(registryEntry, compileInstruction, loadContext, target) {
        let resources = new ViewResources(this.appResources, registryEntry.address);
        let dependencies = registryEntry.dependencies;
        let importIds;
        let names;
        compileInstruction = compileInstruction || ViewCompileInstruction.normal;
        if (dependencies.length === 0 && !compileInstruction.associatedModuleId) {
            return Promise.resolve(resources);
        }
        importIds = dependencies.map(x => x.src);
        names = dependencies.map(x => x.name);
        logger.debug(`importing resources for ${registryEntry.address}`, importIds);
        if (target) {
            let viewModelRequires = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.get(ViewEngine.viewModelRequireMetadataKey, target);
            if (viewModelRequires) {
                let templateImportCount = importIds.length;
                for (let i = 0, ii = viewModelRequires.length; i < ii; ++i) {
                    let req = viewModelRequires[i];
                    let importId = typeof req === 'function'
                        ? aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Origin.get(req).moduleId
                        : (0,aurelia_path__WEBPACK_IMPORTED_MODULE_3__.relativeToFile)(req.src || req, registryEntry.address);
                    if (importIds.indexOf(importId) === -1) {
                        importIds.push(importId);
                        names.push(req.as);
                    }
                }
                logger.debug(`importing ViewModel resources for ${compileInstruction.associatedModuleId}`, importIds.slice(templateImportCount));
            }
        }
        return this.importViewResources(importIds, names, resources, compileInstruction, loadContext);
    }
    importViewModelResource(moduleImport, moduleMember) {
        return this.loader.loadModule(moduleImport).then(viewModelModule => {
            let normalizedId = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Origin.get(viewModelModule).moduleId;
            let resourceModule = this.moduleAnalyzer.analyze(normalizedId, viewModelModule, moduleMember);
            if (!resourceModule.mainResource) {
                throw new Error(`No view model found in module "${moduleImport}".`);
            }
            resourceModule.initialize(this.container);
            return resourceModule.mainResource;
        });
    }
    importViewResources(moduleIds, names, resources, compileInstruction, loadContext) {
        loadContext = loadContext || new ResourceLoadContext();
        compileInstruction = compileInstruction || ViewCompileInstruction.normal;
        moduleIds = moduleIds.map(x => this._applyLoaderPlugin(x));
        return this.loader.loadAllModules(moduleIds).then(imports => {
            let i;
            let ii;
            let analysis;
            let normalizedId;
            let current;
            let associatedModule;
            let container = this.container;
            let moduleAnalyzer = this.moduleAnalyzer;
            let allAnalysis = new Array(imports.length);
            for (i = 0, ii = imports.length; i < ii; ++i) {
                current = imports[i];
                normalizedId = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Origin.get(current).moduleId;
                analysis = moduleAnalyzer.analyze(normalizedId, current);
                analysis.initialize(container);
                analysis.register(resources, names[i]);
                allAnalysis[i] = analysis;
            }
            if (compileInstruction.associatedModuleId) {
                associatedModule = moduleAnalyzer.getAnalysis(compileInstruction.associatedModuleId);
                if (associatedModule) {
                    associatedModule.register(resources);
                }
            }
            for (i = 0, ii = allAnalysis.length; i < ii; ++i) {
                allAnalysis[i] = allAnalysis[i].load(container, loadContext);
            }
            return Promise.all(allAnalysis).then(() => resources);
        });
    }
    _applyLoaderPlugin(id) {
        let index = id.lastIndexOf('.');
        if (index !== -1) {
            let ext = id.substring(index);
            let pluginName = this._pluginMap[ext];
            if (pluginName === undefined) {
                return id;
            }
            return this.loader.applyPluginToUrl(id, pluginName);
        }
        return id;
    }
}
ViewEngine.viewModelRequireMetadataKey = 'aurelia:view-model-require';

class Controller {
    constructor(behavior, instruction, viewModel, container) {
        this.behavior = behavior;
        this.instruction = instruction;
        this.viewModel = viewModel;
        this.isAttached = false;
        this.view = null;
        this.isBound = false;
        this.scope = null;
        this.container = container;
        this.elementEvents = container.elementEvents || null;
        let observerLookup = behavior.observerLocator.getOrCreateObserversLookup(viewModel);
        let handlesBind = behavior.handlesBind;
        let attributes = instruction.attributes;
        let boundProperties = this.boundProperties = [];
        let properties = behavior.properties;
        let i;
        let ii;
        behavior._ensurePropertiesDefined(viewModel, observerLookup);
        for (i = 0, ii = properties.length; i < ii; ++i) {
            properties[i]._initialize(viewModel, observerLookup, attributes, handlesBind, boundProperties);
        }
    }
    created(owningView) {
        if (this.behavior.handlesCreated) {
            this.viewModel.created(owningView, this.view);
        }
    }
    automate(overrideContext, owningView) {
        this.view.bindingContext = this.viewModel;
        this.view.overrideContext = overrideContext || (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.createOverrideContext)(this.viewModel);
        this.view._isUserControlled = true;
        if (this.behavior.handlesCreated) {
            this.viewModel.created(owningView || null, this.view);
        }
        this.bind(this.view);
    }
    bind(scope) {
        let skipSelfSubscriber = this.behavior.handlesBind;
        let boundProperties = this.boundProperties;
        let i;
        let ii;
        let x;
        let observer;
        let selfSubscriber;
        if (this.isBound) {
            if (this.scope === scope) {
                return;
            }
            this.unbind();
        }
        this.isBound = true;
        this.scope = scope;
        for (i = 0, ii = boundProperties.length; i < ii; ++i) {
            x = boundProperties[i];
            observer = x.observer;
            selfSubscriber = observer.selfSubscriber;
            observer.publishing = false;
            if (skipSelfSubscriber) {
                observer.selfSubscriber = null;
            }
            x.binding.bind(scope);
            observer.call();
            observer.publishing = true;
            observer.selfSubscriber = selfSubscriber;
        }
        let overrideContext;
        if (this.view !== null) {
            if (skipSelfSubscriber) {
                this.view.viewModelScope = scope;
            }
            if (this.viewModel === scope.overrideContext.bindingContext) {
                overrideContext = scope.overrideContext;
            }
            else if (this.instruction.inheritBindingContext) {
                overrideContext = (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.createOverrideContext)(this.viewModel, scope.overrideContext);
            }
            else {
                overrideContext = (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.createOverrideContext)(this.viewModel);
                overrideContext.__parentOverrideContext = scope.overrideContext;
            }
            this.view.bind(this.viewModel, overrideContext);
        }
        else if (skipSelfSubscriber) {
            overrideContext = scope.overrideContext;
            if (scope.overrideContext.__parentOverrideContext !== undefined
                && this.viewModel.viewFactory && this.viewModel.viewFactory.factoryCreateInstruction.partReplacements) {
                overrideContext = Object.assign({}, scope.overrideContext);
                overrideContext.parentOverrideContext = scope.overrideContext.__parentOverrideContext;
            }
            this.viewModel.bind(scope.bindingContext, overrideContext);
        }
    }
    unbind() {
        if (this.isBound) {
            let boundProperties = this.boundProperties;
            let i;
            let ii;
            this.isBound = false;
            this.scope = null;
            if (this.view !== null) {
                this.view.unbind();
            }
            if (this.behavior.handlesUnbind) {
                this.viewModel.unbind();
            }
            if (this.elementEvents !== null) {
                this.elementEvents.disposeAll();
            }
            for (i = 0, ii = boundProperties.length; i < ii; ++i) {
                boundProperties[i].binding.unbind();
            }
        }
    }
    attached() {
        if (this.isAttached) {
            return;
        }
        this.isAttached = true;
        if (this.behavior.handlesAttached) {
            this.viewModel.attached();
        }
        if (this.view !== null) {
            this.view.attached();
        }
    }
    detached() {
        if (this.isAttached) {
            this.isAttached = false;
            if (this.view !== null) {
                this.view.detached();
            }
            if (this.behavior.handlesDetached) {
                this.viewModel.detached();
            }
        }
    }
}

let lastProviderId = 0;
function nextProviderId() {
    return ++lastProviderId;
}
function doProcessContent() { return true; }
function doProcessAttributes() { }
class HtmlBehaviorResource {
    constructor() {
        this.elementName = null;
        this.attributeName = null;
        this.attributeDefaultBindingMode = undefined;
        this.liftsContent = false;
        this.targetShadowDOM = false;
        this.shadowDOMOptions = null;
        this.processAttributes = doProcessAttributes;
        this.processContent = doProcessContent;
        this.usesShadowDOM = false;
        this.childBindings = null;
        this.hasDynamicOptions = false;
        this.containerless = false;
        this.properties = [];
        this.attributes = {};
        this.isInitialized = false;
        this.primaryProperty = null;
    }
    static convention(name, existing) {
        let behavior;
        if (name.endsWith('CustomAttribute')) {
            behavior = existing || new HtmlBehaviorResource();
            behavior.attributeName = _hyphenate(name.substring(0, name.length - 15));
        }
        if (name.endsWith('CustomElement')) {
            behavior = existing || new HtmlBehaviorResource();
            behavior.elementName = _hyphenate(name.substring(0, name.length - 13));
        }
        return behavior;
    }
    addChildBinding(behavior) {
        if (this.childBindings === null) {
            this.childBindings = [];
        }
        this.childBindings.push(behavior);
    }
    initialize(container, target) {
        let proto = target.prototype;
        let properties = this.properties;
        let attributeName = this.attributeName;
        let attributeDefaultBindingMode = this.attributeDefaultBindingMode;
        let i;
        let ii;
        let current;
        if (this.isInitialized) {
            return;
        }
        this.isInitialized = true;
        target.__providerId__ = nextProviderId();
        this.observerLocator = container.get(aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.ObserverLocator);
        this.taskQueue = container.get(aurelia_task_queue__WEBPACK_IMPORTED_MODULE_7__.TaskQueue);
        this.target = target;
        this.usesShadowDOM = this.targetShadowDOM && aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.FEATURE.shadowDOM;
        this.handlesCreated = ('created' in proto);
        this.handlesBind = ('bind' in proto);
        this.handlesUnbind = ('unbind' in proto);
        this.handlesAttached = ('attached' in proto);
        this.handlesDetached = ('detached' in proto);
        this.htmlName = this.elementName || this.attributeName;
        if (attributeName !== null) {
            if (properties.length === 0) {
                new BindableProperty({
                    name: 'value',
                    changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
                    attribute: attributeName,
                    defaultBindingMode: attributeDefaultBindingMode
                }).registerWith(target, this);
            }
            current = properties[0];
            if (properties.length === 1 && current.name === 'value') {
                current.isDynamic = current.hasOptions = this.hasDynamicOptions;
                current.defineOn(target, this);
            }
            else {
                for (i = 0, ii = properties.length; i < ii; ++i) {
                    properties[i].defineOn(target, this);
                    if (properties[i].primaryProperty) {
                        if (this.primaryProperty) {
                            throw new Error('Only one bindable property on a custom element can be defined as the default');
                        }
                        this.primaryProperty = properties[i];
                    }
                }
                current = new BindableProperty({
                    name: 'value',
                    changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
                    attribute: attributeName,
                    defaultBindingMode: attributeDefaultBindingMode
                });
                current.hasOptions = true;
                current.registerWith(target, this);
            }
        }
        else {
            for (i = 0, ii = properties.length; i < ii; ++i) {
                properties[i].defineOn(target, this);
            }
            this._copyInheritedProperties(container, target);
        }
    }
    register(registry, name) {
        if (this.attributeName !== null) {
            registry.registerAttribute(name || this.attributeName, this, this.attributeName);
            if (Array.isArray(this.aliases)) {
                this.aliases
                    .forEach((alias) => {
                    registry.registerAttribute(alias, this, this.attributeName);
                });
            }
        }
        if (this.elementName !== null) {
            registry.registerElement(name || this.elementName, this);
        }
    }
    aliases(aliases) {
        throw new Error('Method not implemented.');
    }
    load(container, target, loadContext, viewStrategy, transientView) {
        let options;
        if (this.elementName !== null) {
            viewStrategy = container.get(ViewLocator).getViewStrategy(viewStrategy || this.viewStrategy || target);
            options = new ViewCompileInstruction(this.targetShadowDOM, true);
            if (!viewStrategy.moduleId) {
                viewStrategy.moduleId = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Origin.get(target).moduleId;
            }
            return viewStrategy
                .loadViewFactory(container.get(ViewEngine), options, loadContext, target)
                .then(viewFactory => {
                if (!transientView || !this.viewFactory) {
                    this.viewFactory = viewFactory;
                }
                return viewFactory;
            });
        }
        return Promise.resolve(this);
    }
    compile(compiler, resources, node, instruction, parentNode) {
        if (this.liftsContent) {
            if (!instruction.viewFactory) {
                let template = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createElement('template');
                let fragment = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createDocumentFragment();
                let cacheSize = node.getAttribute('view-cache');
                let part = node.getAttribute('part');
                node.removeAttribute(instruction.originalAttrName);
                aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.replaceNode(template, node, parentNode);
                fragment.appendChild(node);
                instruction.viewFactory = compiler.compile(fragment, resources);
                if (part) {
                    instruction.viewFactory.part = part;
                    node.removeAttribute('part');
                }
                if (cacheSize) {
                    instruction.viewFactory.setCacheSize(cacheSize);
                    node.removeAttribute('view-cache');
                }
                node = template;
            }
        }
        else if (this.elementName !== null) {
            let partReplacements = {};
            if (this.processContent(compiler, resources, node, instruction) && node.hasChildNodes()) {
                let currentChild = node.firstChild;
                let contentElement = this.usesShadowDOM ? null : aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createElement('au-content');
                let nextSibling;
                let toReplace;
                while (currentChild) {
                    nextSibling = currentChild.nextSibling;
                    if (currentChild.tagName === 'TEMPLATE' && (toReplace = currentChild.getAttribute('replace-part'))) {
                        partReplacements[toReplace] = compiler.compile(currentChild, resources);
                        aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.removeNode(currentChild, parentNode);
                        instruction.partReplacements = partReplacements;
                    }
                    else if (contentElement !== null) {
                        if (currentChild.nodeType === 3 && _isAllWhitespace(currentChild)) {
                            aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.removeNode(currentChild, parentNode);
                        }
                        else {
                            contentElement.appendChild(currentChild);
                        }
                    }
                    currentChild = nextSibling;
                }
                if (contentElement !== null && contentElement.hasChildNodes()) {
                    node.appendChild(contentElement);
                }
                instruction.skipContentProcessing = false;
            }
            else {
                instruction.skipContentProcessing = true;
            }
        }
        else if (!this.processContent(compiler, resources, node, instruction)) {
            instruction.skipContentProcessing = true;
        }
        return node;
    }
    create(container, instruction, element, bindings) {
        let viewHost;
        let au = null;
        instruction = instruction || BehaviorInstruction.normal;
        element = element || null;
        bindings = bindings || null;
        if (this.elementName !== null && element) {
            if (this.usesShadowDOM) {
                viewHost = element.attachShadow(this.shadowDOMOptions);
                container.registerInstance(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.boundary, viewHost);
            }
            else {
                viewHost = element;
                if (this.targetShadowDOM) {
                    container.registerInstance(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.boundary, viewHost);
                }
            }
        }
        if (element !== null) {
            element.au = au = element.au || {};
        }
        let viewModel = instruction.viewModel || container.get(this.target);
        let controller = new Controller(this, instruction, viewModel, container);
        let childBindings = this.childBindings;
        let viewFactory;
        if (this.liftsContent) {
            au.controller = controller;
        }
        else if (this.elementName !== null) {
            viewFactory = instruction.viewFactory || this.viewFactory;
            container.viewModel = viewModel;
            if (viewFactory) {
                controller.view = viewFactory.create(container, instruction, element);
            }
            if (element !== null) {
                au.controller = controller;
                if (controller.view) {
                    if (!this.usesShadowDOM && (element.childNodes.length === 1 || element.contentElement)) {
                        let contentElement = element.childNodes[0] || element.contentElement;
                        controller.view.contentView = { fragment: contentElement };
                        contentElement.parentNode && aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.removeNode(contentElement);
                    }
                    if (instruction.anchorIsContainer) {
                        if (childBindings !== null) {
                            for (let i = 0, ii = childBindings.length; i < ii; ++i) {
                                controller.view.addBinding(childBindings[i].create(element, viewModel, controller));
                            }
                        }
                        controller.view.appendNodesTo(viewHost);
                    }
                    else {
                        controller.view.insertNodesBefore(viewHost);
                    }
                }
                else if (childBindings !== null) {
                    for (let i = 0, ii = childBindings.length; i < ii; ++i) {
                        bindings.push(childBindings[i].create(element, viewModel, controller));
                    }
                }
            }
            else if (controller.view) {
                controller.view.controller = controller;
                if (childBindings !== null) {
                    for (let i = 0, ii = childBindings.length; i < ii; ++i) {
                        controller.view.addBinding(childBindings[i].create(instruction.host, viewModel, controller));
                    }
                }
            }
            else if (childBindings !== null) {
                for (let i = 0, ii = childBindings.length; i < ii; ++i) {
                    bindings.push(childBindings[i].create(instruction.host, viewModel, controller));
                }
            }
        }
        else if (childBindings !== null) {
            for (let i = 0, ii = childBindings.length; i < ii; ++i) {
                bindings.push(childBindings[i].create(element, viewModel, controller));
            }
        }
        if (au !== null) {
            au[this.htmlName] = controller;
        }
        if (instruction.initiatedByBehavior && viewFactory) {
            controller.view.created();
        }
        return controller;
    }
    _ensurePropertiesDefined(instance, lookup) {
        let properties;
        let i;
        let ii;
        let observer;
        if ('__propertiesDefined__' in lookup) {
            return;
        }
        lookup.__propertiesDefined__ = true;
        properties = this.properties;
        for (i = 0, ii = properties.length; i < ii; ++i) {
            observer = properties[i].createObserver(instance);
            if (observer !== undefined) {
                lookup[observer.propertyName] = observer;
            }
        }
    }
    _copyInheritedProperties(container, target) {
        let behavior;
        let derived = target;
        while (true) {
            let proto = Object.getPrototypeOf(target.prototype);
            target = proto && proto.constructor;
            if (!target) {
                return;
            }
            behavior = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, target);
            if (behavior) {
                break;
            }
        }
        behavior.initialize(container, target);
        for (let i = 0, ii = behavior.properties.length; i < ii; ++i) {
            let prop = behavior.properties[i];
            if (this.properties.some(p => p.name === prop.name)) {
                continue;
            }
            new BindableProperty(prop).registerWith(derived, this);
        }
    }
}

function register(lookup, name, resource, type) {
    if (!name) {
        return;
    }
    let existing = lookup[name];
    if (existing) {
        if (existing !== resource) {
            throw new Error(`Attempted to register ${type} when one with the same name already exists. Name: ${name}.`);
        }
        return;
    }
    lookup[name] = resource;
}
function validateBehaviorName(name, type) {
    if (/[A-Z]/.test(name)) {
        let newName = _hyphenate(name);
        aurelia_logging__WEBPACK_IMPORTED_MODULE_4__.getLogger('templating')
            .warn(`'${name}' is not a valid ${type} name and has been converted to '${newName}'. Upper-case letters are not allowed because the DOM is not case-sensitive.`);
        return newName;
    }
    return name;
}
const conventionMark = '__au_resource__';
class ViewResources {
    constructor(parent, viewUrl) {
        this.bindingLanguage = null;
        this.parent = parent || null;
        this.hasParent = this.parent !== null;
        this.viewUrl = viewUrl || '';
        this.lookupFunctions = {
            valueConverters: this.getValueConverter.bind(this),
            bindingBehaviors: this.getBindingBehavior.bind(this)
        };
        this.attributes = Object.create(null);
        this.elements = Object.create(null);
        this.valueConverters = Object.create(null);
        this.bindingBehaviors = Object.create(null);
        this.attributeMap = Object.create(null);
        this.values = Object.create(null);
        this.beforeCompile = this.afterCompile = this.beforeCreate = this.afterCreate = this.beforeBind = this.beforeUnbind = false;
    }
    static convention(target, existing) {
        let resource;
        if (existing && conventionMark in existing) {
            return existing;
        }
        if ('$resource' in target) {
            let config = target.$resource;
            if (typeof config === 'string') {
                resource = existing || new HtmlBehaviorResource();
                resource[conventionMark] = true;
                if (!resource.elementName) {
                    resource.elementName = validateBehaviorName(config, 'custom element');
                }
            }
            else {
                if (typeof config === 'function') {
                    config = config.call(target);
                }
                if (typeof config === 'string') {
                    config = { name: config };
                }
                config = Object.assign({}, config);
                let resourceType = config.type || 'element';
                let name = config.name;
                switch (resourceType) {
                    case 'element':
                    case 'attribute':
                        resource = existing || new HtmlBehaviorResource();
                        resource[conventionMark] = true;
                        if (resourceType === 'element') {
                            if (!resource.elementName) {
                                resource.elementName = name
                                    ? validateBehaviorName(name, 'custom element')
                                    : _hyphenate(target.name);
                            }
                        }
                        else {
                            if (!resource.attributeName) {
                                resource.attributeName = name
                                    ? validateBehaviorName(name, 'custom attribute')
                                    : _hyphenate(target.name);
                            }
                        }
                        if ('templateController' in config) {
                            config.liftsContent = config.templateController;
                            delete config.templateController;
                        }
                        if ('defaultBindingMode' in config && resource.attributeDefaultBindingMode !== undefined) {
                            config.attributeDefaultBindingMode = config.defaultBindingMode;
                            delete config.defaultBindingMode;
                        }
                        delete config.name;
                        Object.assign(resource, config);
                        break;
                    case 'valueConverter':
                        resource = new aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.ValueConverterResource((0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.camelCase)(name || target.name));
                        break;
                    case 'bindingBehavior':
                        resource = new aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.BindingBehaviorResource((0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.camelCase)(name || target.name));
                        break;
                    case 'viewEngineHooks':
                        resource = new ViewEngineHooksResource();
                        break;
                }
            }
            if (resource instanceof HtmlBehaviorResource) {
                let bindables = typeof config === 'string' ? undefined : config.bindables;
                let currentProps = resource.properties;
                if (Array.isArray(bindables)) {
                    for (let i = 0, ii = bindables.length; ii > i; ++i) {
                        let prop = bindables[i];
                        if (!prop || (typeof prop !== 'string' && !prop.name)) {
                            throw new Error(`Invalid bindable property at "${i}" for class "${target.name}". Expected either a string or an object with "name" property.`);
                        }
                        let newProp = new BindableProperty(prop);
                        let existed = false;
                        for (let j = 0, jj = currentProps.length; jj > j; ++j) {
                            if (currentProps[j].name === newProp.name) {
                                existed = true;
                                break;
                            }
                        }
                        if (existed) {
                            continue;
                        }
                        newProp.registerWith(target, resource);
                    }
                }
            }
        }
        return resource;
    }
    _tryAddHook(obj, name) {
        if (typeof obj[name] === 'function') {
            let func = obj[name].bind(obj);
            let counter = 1;
            let callbackName;
            while (this[callbackName = name + counter.toString()] !== undefined) {
                counter++;
            }
            this[name] = true;
            this[callbackName] = func;
        }
    }
    _invokeHook(name, one, two, three, four) {
        if (this.hasParent) {
            this.parent._invokeHook(name, one, two, three, four);
        }
        if (this[name]) {
            this[name + '1'](one, two, three, four);
            let callbackName = name + '2';
            if (this[callbackName]) {
                this[callbackName](one, two, three, four);
                callbackName = name + '3';
                if (this[callbackName]) {
                    this[callbackName](one, two, three, four);
                    let counter = 4;
                    while (this[callbackName = name + counter.toString()] !== undefined) {
                        this[callbackName](one, two, three, four);
                        counter++;
                    }
                }
            }
        }
    }
    registerViewEngineHooks(hooks) {
        this._tryAddHook(hooks, 'beforeCompile');
        this._tryAddHook(hooks, 'afterCompile');
        this._tryAddHook(hooks, 'beforeCreate');
        this._tryAddHook(hooks, 'afterCreate');
        this._tryAddHook(hooks, 'beforeBind');
        this._tryAddHook(hooks, 'beforeUnbind');
    }
    getBindingLanguage(bindingLanguageFallback) {
        return this.bindingLanguage || (this.bindingLanguage = bindingLanguageFallback);
    }
    patchInParent(newParent) {
        let originalParent = this.parent;
        this.parent = newParent || null;
        this.hasParent = this.parent !== null;
        if (newParent.parent === null) {
            newParent.parent = originalParent;
            newParent.hasParent = originalParent !== null;
        }
    }
    relativeToView(path) {
        return (0,aurelia_path__WEBPACK_IMPORTED_MODULE_3__.relativeToFile)(path, this.viewUrl);
    }
    registerElement(tagName, behavior) {
        register(this.elements, tagName, behavior, 'an Element');
    }
    getElement(tagName) {
        return this.elements[tagName] || (this.hasParent ? this.parent.getElement(tagName) : null);
    }
    mapAttribute(attribute) {
        return this.attributeMap[attribute] || (this.hasParent ? this.parent.mapAttribute(attribute) : null);
    }
    registerAttribute(attribute, behavior, knownAttribute) {
        this.attributeMap[attribute] = knownAttribute;
        register(this.attributes, attribute, behavior, 'an Attribute');
    }
    getAttribute(attribute) {
        return this.attributes[attribute] || (this.hasParent ? this.parent.getAttribute(attribute) : null);
    }
    registerValueConverter(name, valueConverter) {
        register(this.valueConverters, name, valueConverter, 'a ValueConverter');
    }
    getValueConverter(name) {
        return this.valueConverters[name] || (this.hasParent ? this.parent.getValueConverter(name) : null);
    }
    registerBindingBehavior(name, bindingBehavior) {
        register(this.bindingBehaviors, name, bindingBehavior, 'a BindingBehavior');
    }
    getBindingBehavior(name) {
        return this.bindingBehaviors[name] || (this.hasParent ? this.parent.getBindingBehavior(name) : null);
    }
    registerValue(name, value) {
        register(this.values, name, value, 'a value');
    }
    getValue(name) {
        return this.values[name] || (this.hasParent ? this.parent.getValue(name) : null);
    }
    autoRegister(container, impl) {
        let resourceTypeMeta = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, impl);
        if (resourceTypeMeta) {
            if (resourceTypeMeta instanceof HtmlBehaviorResource) {
                ViewResources.convention(impl, resourceTypeMeta);
                if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
                    HtmlBehaviorResource.convention(impl.name, resourceTypeMeta);
                }
                if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
                    resourceTypeMeta.elementName = _hyphenate(impl.name);
                }
            }
        }
        else {
            resourceTypeMeta = ViewResources.convention(impl)
                || HtmlBehaviorResource.convention(impl.name)
                || aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.ValueConverterResource.convention(impl.name)
                || aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.BindingBehaviorResource.convention(impl.name)
                || ViewEngineHooksResource.convention(impl.name);
            if (!resourceTypeMeta) {
                resourceTypeMeta = new HtmlBehaviorResource();
                resourceTypeMeta.elementName = _hyphenate(impl.name);
            }
            aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, resourceTypeMeta, impl);
        }
        resourceTypeMeta.initialize(container, impl);
        resourceTypeMeta.register(this, undefined);
        return resourceTypeMeta;
    }
}

const viewStrategy = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.protocol.create('aurelia:view-strategy', {
    validate(target) {
        if (!(typeof target.loadViewFactory === 'function')) {
            return 'View strategies must implement: loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>';
        }
        return true;
    },
    compose(target) {
        if (!(typeof target.makeRelativeTo === 'function')) {
            target.makeRelativeTo = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.PLATFORM.noop;
        }
    }
});
let RelativeViewStrategy = class RelativeViewStrategy {
    constructor(path) {
        this.path = path;
        this.absolutePath = null;
    }
    loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        if (this.absolutePath === null && this.moduleId) {
            this.absolutePath = (0,aurelia_path__WEBPACK_IMPORTED_MODULE_3__.relativeToFile)(this.path, this.moduleId);
        }
        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(this.absolutePath || this.path, compileInstruction, loadContext, target);
    }
    makeRelativeTo(file) {
        if (this.absolutePath === null) {
            this.absolutePath = (0,aurelia_path__WEBPACK_IMPORTED_MODULE_3__.relativeToFile)(this.path, file);
        }
    }
};
RelativeViewStrategy = __decorate([
    viewStrategy()
], RelativeViewStrategy);
let ConventionalViewStrategy = class ConventionalViewStrategy {
    constructor(viewLocator, origin) {
        this.moduleId = origin.moduleId;
        this.viewUrl = viewLocator.convertOriginToViewUrl(origin);
    }
    loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(this.viewUrl, compileInstruction, loadContext, target);
    }
};
ConventionalViewStrategy = __decorate([
    viewStrategy()
], ConventionalViewStrategy);
let NoViewStrategy = class NoViewStrategy {
    constructor(dependencies, dependencyBaseUrl) {
        this.dependencies = dependencies || null;
        this.dependencyBaseUrl = dependencyBaseUrl || '';
    }
    loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        let entry = this.entry;
        let dependencies = this.dependencies;
        if (entry && entry.factoryIsReady) {
            return Promise.resolve(null);
        }
        this.entry = entry = new aurelia_loader__WEBPACK_IMPORTED_MODULE_1__.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);
        entry.dependencies = [];
        entry.templateIsLoaded = true;
        if (dependencies !== null) {
            for (let i = 0, ii = dependencies.length; i < ii; ++i) {
                let current = dependencies[i];
                if (typeof current === 'string' || typeof current === 'function') {
                    entry.addDependency(current);
                }
                else {
                    entry.addDependency(current.from, current.as);
                }
            }
        }
        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
    }
};
NoViewStrategy = __decorate([
    viewStrategy()
], NoViewStrategy);
let TemplateRegistryViewStrategy = class TemplateRegistryViewStrategy {
    constructor(moduleId, entry) {
        this.moduleId = moduleId;
        this.entry = entry;
    }
    loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        let entry = this.entry;
        if (entry.factoryIsReady) {
            return Promise.resolve(entry.factory);
        }
        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
    }
};
TemplateRegistryViewStrategy = __decorate([
    viewStrategy()
], TemplateRegistryViewStrategy);
let InlineViewStrategy = class InlineViewStrategy {
    constructor(markup, dependencies, dependencyBaseUrl) {
        this.markup = markup;
        this.dependencies = dependencies || null;
        this.dependencyBaseUrl = dependencyBaseUrl || '';
    }
    loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        let entry = this.entry;
        let dependencies = this.dependencies;
        if (entry && entry.factoryIsReady) {
            return Promise.resolve(entry.factory);
        }
        this.entry = entry = new aurelia_loader__WEBPACK_IMPORTED_MODULE_1__.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);
        entry.template = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createTemplateFromMarkup(this.markup);
        if (dependencies !== null) {
            for (let i = 0, ii = dependencies.length; i < ii; ++i) {
                let current = dependencies[i];
                if (typeof current === 'string' || typeof current === 'function') {
                    entry.addDependency(current);
                }
                else {
                    entry.addDependency(current.from, current.as);
                }
            }
        }
        compileInstruction.associatedModuleId = this.moduleId;
        return viewEngine.loadViewFactory(entry, compileInstruction, loadContext, target);
    }
};
InlineViewStrategy = __decorate([
    viewStrategy()
], InlineViewStrategy);
let StaticViewStrategy = class StaticViewStrategy {
    constructor(config) {
        if (typeof config === 'string' || (config instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.Element && config.tagName === 'TEMPLATE')) {
            config = {
                template: config
            };
        }
        this.template = config.template;
        this.dependencies = config.dependencies || [];
        this.factoryIsReady = false;
        this.onReady = null;
        this.moduleId = 'undefined';
    }
    loadViewFactory(viewEngine, compileInstruction, loadContext, target) {
        if (this.factoryIsReady) {
            return Promise.resolve(this.factory);
        }
        let $deps = this.dependencies;
        let deps = typeof $deps === 'function' ? $deps() : $deps;
        deps = deps ? deps : [];
        deps = Array.isArray(deps) ? deps : [deps];
        return Promise.all(deps).then((dependencies) => {
            let container = viewEngine.container;
            let appResources = viewEngine.appResources;
            let viewCompiler = viewEngine.viewCompiler;
            let viewResources = new ViewResources(appResources);
            let resource;
            let elDeps = [];
            if (target) {
                viewResources.autoRegister(container, target);
            }
            for (let dep of dependencies) {
                if (typeof dep === 'function') {
                    resource = viewResources.autoRegister(container, dep);
                    if (resource.elementName !== null) {
                        elDeps.push(resource);
                    }
                }
                else if (dep && typeof dep === 'object') {
                    for (let key in dep) {
                        let exported = dep[key];
                        if (typeof exported === 'function') {
                            resource = viewResources.autoRegister(container, exported);
                            if (resource.elementName !== null) {
                                elDeps.push(resource);
                            }
                        }
                    }
                }
                else {
                    throw new Error(`dependency neither function nor object. Received: "${typeof dep}"`);
                }
            }
            return Promise.all(elDeps.map(el => el.load(container, el.target))).then(() => {
                const factory = this.template !== null
                    ? viewCompiler.compile(this.template, viewResources, compileInstruction)
                    : null;
                this.factoryIsReady = true;
                this.factory = factory;
                return factory;
            });
        });
    }
};
StaticViewStrategy = __decorate([
    viewStrategy()
], StaticViewStrategy);

function remove(viewSlot, previous) {
    return Array.isArray(previous)
        ? viewSlot.removeMany(previous, true)
        : viewSlot.remove(previous, true);
}
const SwapStrategies = {
    before(viewSlot, previous, callback) {
        return (previous === undefined)
            ? callback()
            : callback().then(() => remove(viewSlot, previous));
    },
    with(viewSlot, previous, callback) {
        return (previous === undefined)
            ? callback()
            : Promise.all([remove(viewSlot, previous), callback()]);
    },
    after(viewSlot, previous, callback) {
        return Promise.resolve(viewSlot.removeAll(true)).then(callback);
    }
};

function tryActivateViewModel(context) {
    if (context.skipActivation || typeof context.viewModel.activate !== 'function') {
        return Promise.resolve();
    }
    return context.viewModel.activate(context.model) || Promise.resolve();
}
let CompositionEngine = class CompositionEngine {
    constructor(viewEngine, viewLocator) {
        this.viewEngine = viewEngine;
        this.viewLocator = viewLocator;
    }
    _swap(context, view) {
        let swapStrategy = SwapStrategies[context.swapOrder] || SwapStrategies.after;
        let previousViews = context.viewSlot.children.slice();
        return swapStrategy(context.viewSlot, previousViews, () => {
            return Promise.resolve(context.viewSlot.add(view)).then(() => {
                if (context.currentController) {
                    context.currentController.unbind();
                }
            });
        }).then(() => {
            if (context.compositionTransactionNotifier) {
                context.compositionTransactionNotifier.done();
            }
        });
    }
    _createControllerAndSwap(context) {
        return this.createController(context).then(controller => {
            if (context.compositionTransactionOwnershipToken) {
                return context.compositionTransactionOwnershipToken
                    .waitForCompositionComplete()
                    .then(() => {
                    controller.automate(context.overrideContext, context.owningView);
                    return this._swap(context, controller.view);
                })
                    .then(() => controller);
            }
            controller.automate(context.overrideContext, context.owningView);
            return this._swap(context, controller.view).then(() => controller);
        });
    }
    createController(context) {
        let childContainer;
        let viewModel;
        let viewModelResource;
        let m;
        return this
            .ensureViewModel(context)
            .then(tryActivateViewModel)
            .then(() => {
            childContainer = context.childContainer;
            viewModel = context.viewModel;
            viewModelResource = context.viewModelResource;
            m = viewModelResource.metadata;
            let viewStrategy = this.viewLocator.getViewStrategy(context.view || viewModel);
            if (context.viewResources) {
                viewStrategy.makeRelativeTo(context.viewResources.viewUrl);
            }
            return m.load(childContainer, viewModelResource.value, null, viewStrategy, true);
        }).then(viewFactory => m.create(childContainer, BehaviorInstruction.dynamic(context.host, viewModel, viewFactory)));
    }
    ensureViewModel(context) {
        let childContainer = context.childContainer = (context.childContainer || context.container.createChild());
        if (typeof context.viewModel === 'string') {
            context.viewModel = context.viewResources
                ? context.viewResources.relativeToView(context.viewModel)
                : context.viewModel;
            return this.viewEngine.importViewModelResource(context.viewModel).then(viewModelResource => {
                childContainer.autoRegister(viewModelResource.value);
                if (context.host) {
                    childContainer.registerInstance(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.Element, context.host);
                }
                context.viewModel = childContainer.viewModel = childContainer.get(viewModelResource.value);
                context.viewModelResource = viewModelResource;
                return context;
            });
        }
        let ctor = context.viewModel.constructor;
        let isClass = typeof context.viewModel === 'function';
        if (isClass) {
            ctor = context.viewModel;
            childContainer.autoRegister(ctor);
        }
        let m = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, ctor);
        m.elementName = m.elementName || 'dynamic-element';
        m.initialize(isClass ? childContainer : (context.container || childContainer), ctor);
        context.viewModelResource = { metadata: m, value: ctor };
        if (context.host) {
            childContainer.registerInstance(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.Element, context.host);
        }
        childContainer.viewModel = context.viewModel = isClass ? childContainer.get(ctor) : context.viewModel;
        return Promise.resolve(context);
    }
    compose(context) {
        context.childContainer = context.childContainer || context.container.createChild();
        context.view = this.viewLocator.getViewStrategy(context.view);
        let transaction = context.childContainer.get(CompositionTransaction);
        let compositionTransactionOwnershipToken = transaction.tryCapture();
        if (compositionTransactionOwnershipToken) {
            context.compositionTransactionOwnershipToken = compositionTransactionOwnershipToken;
        }
        else {
            context.compositionTransactionNotifier = transaction.enlist();
        }
        if (context.viewModel) {
            return this._createControllerAndSwap(context);
        }
        else if (context.view) {
            if (context.viewResources) {
                context.view.makeRelativeTo(context.viewResources.viewUrl);
            }
            return context.view.loadViewFactory(this.viewEngine, new ViewCompileInstruction()).then(viewFactory => {
                let result = viewFactory.create(context.childContainer);
                result.bind(context.bindingContext, context.overrideContext);
                if (context.compositionTransactionOwnershipToken) {
                    return context.compositionTransactionOwnershipToken.waitForCompositionComplete()
                        .then(() => this._swap(context, result))
                        .then(() => result);
                }
                return this._swap(context, result).then(() => result);
            });
        }
        else if (context.viewSlot) {
            context.viewSlot.removeAll();
            if (context.compositionTransactionNotifier) {
                context.compositionTransactionNotifier.done();
            }
            return Promise.resolve(null);
        }
        return Promise.resolve(null);
    }
};
CompositionEngine = __decorate([
    (0,aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_6__.inject)(ViewEngine, ViewLocator)
], CompositionEngine);

const animationEvent = {
    enterBegin: 'animation:enter:begin',
    enterActive: 'animation:enter:active',
    enterDone: 'animation:enter:done',
    enterTimeout: 'animation:enter:timeout',
    leaveBegin: 'animation:leave:begin',
    leaveActive: 'animation:leave:active',
    leaveDone: 'animation:leave:done',
    leaveTimeout: 'animation:leave:timeout',
    staggerNext: 'animation:stagger:next',
    removeClassBegin: 'animation:remove-class:begin',
    removeClassActive: 'animation:remove-class:active',
    removeClassDone: 'animation:remove-class:done',
    removeClassTimeout: 'animation:remove-class:timeout',
    addClassBegin: 'animation:add-class:begin',
    addClassActive: 'animation:add-class:active',
    addClassDone: 'animation:add-class:done',
    addClassTimeout: 'animation:add-class:timeout',
    animateBegin: 'animation:animate:begin',
    animateActive: 'animation:animate:active',
    animateDone: 'animation:animate:done',
    animateTimeout: 'animation:animate:timeout',
    sequenceBegin: 'animation:sequence:begin',
    sequenceDone: 'animation:sequence:done'
};

function createChildObserverDecorator(selectorOrConfig, all) {
    return function (target, key, descriptor) {
        let actualTarget = typeof key === 'string' ? target.constructor : target;
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, actualTarget);
        if (typeof selectorOrConfig === 'string') {
            selectorOrConfig = {
                selector: selectorOrConfig,
                name: key
            };
        }
        if (descriptor) {
            descriptor.writable = true;
            descriptor.configurable = true;
        }
        selectorOrConfig.all = all;
        r.addChildBinding(new ChildObserver(selectorOrConfig));
    };
}
function children(selectorOrConfig) {
    return createChildObserverDecorator(selectorOrConfig, true);
}
function child(selectorOrConfig) {
    return createChildObserverDecorator(selectorOrConfig, false);
}
class ChildObserver {
    constructor(config) {
        this.name = config.name;
        this.changeHandler = config.changeHandler || this.name + 'Changed';
        this.selector = config.selector;
        this.all = config.all;
    }
    create(viewHost, viewModel, controller) {
        return new ChildObserverBinder(this.selector, viewHost, this.name, viewModel, controller, this.changeHandler, this.all);
    }
}
const noMutations = [];
function trackMutation(groupedMutations, binder, record) {
    let mutations = groupedMutations.get(binder);
    if (!mutations) {
        mutations = [];
        groupedMutations.set(binder, mutations);
    }
    mutations.push(record);
}
function onChildChange(mutations, observer) {
    let binders = observer.binders;
    let bindersLength = binders.length;
    let groupedMutations = new Map();
    for (let i = 0, ii = mutations.length; i < ii; ++i) {
        let record = mutations[i];
        let added = record.addedNodes;
        let removed = record.removedNodes;
        for (let j = 0, jj = removed.length; j < jj; ++j) {
            let node = removed[j];
            if (node.nodeType === 1) {
                for (let k = 0; k < bindersLength; ++k) {
                    let binder = binders[k];
                    if (binder.onRemove(node)) {
                        trackMutation(groupedMutations, binder, record);
                    }
                }
            }
        }
        for (let j = 0, jj = added.length; j < jj; ++j) {
            let node = added[j];
            if (node.nodeType === 1) {
                for (let k = 0; k < bindersLength; ++k) {
                    let binder = binders[k];
                    if (binder.onAdd(node)) {
                        trackMutation(groupedMutations, binder, record);
                    }
                }
            }
        }
    }
    groupedMutations.forEach((mutationRecords, binder) => {
        if (binder.isBound && binder.changeHandler !== null) {
            binder.viewModel[binder.changeHandler](mutationRecords);
        }
    });
}
class ChildObserverBinder {
    constructor(selector, viewHost, property, viewModel, controller, changeHandler, all) {
        this.selector = selector;
        this.viewHost = viewHost;
        this.property = property;
        this.viewModel = viewModel;
        this.controller = controller;
        this.changeHandler = changeHandler in viewModel ? changeHandler : null;
        this.usesShadowDOM = controller.behavior.usesShadowDOM;
        this.all = all;
        if (!this.usesShadowDOM && controller.view && controller.view.contentView) {
            this.contentView = controller.view.contentView;
        }
        else {
            this.contentView = null;
        }
        this.source = null;
        this.isBound = false;
    }
    matches(element) {
        if (element.matches(this.selector)) {
            if (this.contentView === null) {
                return true;
            }
            let contentView = this.contentView;
            let assignedSlot = element.auAssignedSlot;
            if (assignedSlot && assignedSlot.projectFromAnchors) {
                let anchors = assignedSlot.projectFromAnchors;
                for (let i = 0, ii = anchors.length; i < ii; ++i) {
                    if (anchors[i].auOwnerView === contentView) {
                        return true;
                    }
                }
                return false;
            }
            return element.auOwnerView === contentView;
        }
        return false;
    }
    bind(source) {
        if (this.isBound) {
            if (this.source === source) {
                return;
            }
            this.source = source;
        }
        this.isBound = true;
        let viewHost = this.viewHost;
        let viewModel = this.viewModel;
        let observer = viewHost.__childObserver__;
        if (!observer) {
            observer = viewHost.__childObserver__ = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createMutationObserver(onChildChange);
            let options = {
                childList: true,
                subtree: !this.usesShadowDOM
            };
            observer.observe(viewHost, options);
            observer.binders = [];
        }
        observer.binders.push(this);
        if (this.usesShadowDOM) {
            let current = viewHost.firstElementChild;
            if (this.all) {
                let items = viewModel[this.property];
                if (!items) {
                    items = viewModel[this.property] = [];
                }
                else {
                    items.splice(0);
                }
                while (current) {
                    if (this.matches(current)) {
                        items.push(current.au && current.au.controller ? current.au.controller.viewModel : current);
                    }
                    current = current.nextElementSibling;
                }
                if (this.changeHandler !== null) {
                    this.viewModel[this.changeHandler](noMutations);
                }
            }
            else {
                while (current) {
                    if (this.matches(current)) {
                        let value = current.au && current.au.controller ? current.au.controller.viewModel : current;
                        this.viewModel[this.property] = value;
                        if (this.changeHandler !== null) {
                            this.viewModel[this.changeHandler](value);
                        }
                        break;
                    }
                    current = current.nextElementSibling;
                }
            }
        }
    }
    onRemove(element) {
        if (this.matches(element)) {
            let value = element.au && element.au.controller ? element.au.controller.viewModel : element;
            if (this.all) {
                let items = (this.viewModel[this.property] || (this.viewModel[this.property] = []));
                let index = items.indexOf(value);
                if (index !== -1) {
                    items.splice(index, 1);
                }
                return true;
            }
            const currentValue = this.viewModel[this.property];
            if (currentValue === value) {
                this.viewModel[this.property] = null;
                if (this.isBound && this.changeHandler !== null) {
                    this.viewModel[this.changeHandler](value);
                }
            }
        }
        return false;
    }
    onAdd(element) {
        if (this.matches(element)) {
            let value = element.au && element.au.controller ? element.au.controller.viewModel : element;
            if (this.all) {
                let items = (this.viewModel[this.property] || (this.viewModel[this.property] = []));
                if (this.selector === '*') {
                    items.push(value);
                    return true;
                }
                let index = 0;
                let prev = element.previousElementSibling;
                while (prev) {
                    if (this.matches(prev)) {
                        index++;
                    }
                    prev = prev.previousElementSibling;
                }
                items.splice(index, 0, value);
                return true;
            }
            this.viewModel[this.property] = value;
            if (this.isBound && this.changeHandler !== null) {
                this.viewModel[this.changeHandler](value);
            }
        }
        return false;
    }
    unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.source = null;
        let childObserver = this.viewHost.__childObserver__;
        if (childObserver) {
            let binders = childObserver.binders;
            if (binders && binders.length) {
                let idx = binders.indexOf(this);
                if (idx !== -1) {
                    binders.splice(idx, 1);
                }
                if (binders.length === 0) {
                    childObserver.disconnect();
                    this.viewHost.__childObserver__ = null;
                }
            }
            if (this.usesShadowDOM) {
                this.viewModel[this.property] = null;
            }
        }
    }
}

class ElementConfigResource {
    initialize(container, target) { }
    register(registry, name) { }
    load(container, target) {
        let config = new target();
        let eventManager = container.get(aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.EventManager);
        eventManager.registerElementConfig(config);
    }
}

function resource(instanceOrConfig) {
    return function (target) {
        let isConfig = typeof instanceOrConfig === 'string' || Object.getPrototypeOf(instanceOrConfig) === Object.prototype;
        if (isConfig) {
            target.$resource = instanceOrConfig;
        }
        else {
            aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, instanceOrConfig, target);
        }
    };
}
function behavior(override) {
    return function (target) {
        if (override instanceof HtmlBehaviorResource) {
            aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, override, target);
        }
        else {
            let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, target);
            Object.assign(r, override);
        }
    };
}
function customElement(name) {
    return function (target) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, target);
        r.elementName = validateBehaviorName(name, 'custom element');
    };
}
function customAttribute(name, defaultBindingMode, aliases) {
    return function (target) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, target);
        r.attributeName = validateBehaviorName(name, 'custom attribute');
        r.attributeDefaultBindingMode = defaultBindingMode;
        r.aliases = aliases;
    };
}
function templateController(target) {
    let deco = function (t) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, t);
        r.liftsContent = true;
    };
    return target ? deco(target) : deco;
}
function bindable(nameOrConfigOrTarget, key, descriptor) {
    let deco = function (target, key2, descriptor2) {
        let actualTarget = key2 ? target.constructor : target;
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, actualTarget);
        let prop;
        if (key2) {
            nameOrConfigOrTarget = nameOrConfigOrTarget || {};
            nameOrConfigOrTarget.name = key2;
        }
        prop = new BindableProperty(nameOrConfigOrTarget);
        return prop.registerWith(actualTarget, r, descriptor2);
    };
    if (!nameOrConfigOrTarget) {
        return deco;
    }
    if (key) {
        let target = nameOrConfigOrTarget;
        nameOrConfigOrTarget = null;
        return deco(target, key, descriptor);
    }
    return deco;
}
function dynamicOptions(target) {
    let deco = function (t) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, t);
        r.hasDynamicOptions = true;
    };
    return target ? deco(target) : deco;
}
const defaultShadowDOMOptions = { mode: 'open' };
function useShadowDOM(targetOrOptions) {
    let options = typeof targetOrOptions === 'function' || !targetOrOptions
        ? defaultShadowDOMOptions
        : targetOrOptions;
    let deco = function (t) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, t);
        r.targetShadowDOM = true;
        r.shadowDOMOptions = options;
    };
    return typeof targetOrOptions === 'function' ? deco(targetOrOptions) : deco;
}
function processAttributes(processor) {
    return function (t) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, t);
        r.processAttributes = function (compiler, resources, node, attributes, elementInstruction) {
            try {
                processor(compiler, resources, node, attributes, elementInstruction);
            }
            catch (error) {
                aurelia_logging__WEBPACK_IMPORTED_MODULE_4__.getLogger('templating').error(error);
            }
        };
    };
}
function doNotProcessContent() { return false; }
function processContent(processor) {
    return function (t) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, t);
        r.processContent = processor ? function (compiler, resources, node, instruction) {
            try {
                return processor(compiler, resources, node, instruction);
            }
            catch (error) {
                aurelia_logging__WEBPACK_IMPORTED_MODULE_4__.getLogger('templating').error(error);
                return false;
            }
        } : doNotProcessContent;
    };
}
function containerless(target) {
    let deco = function (t) {
        let r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, HtmlBehaviorResource, t);
        r.containerless = true;
    };
    return target ? deco(target) : deco;
}
function useViewStrategy(strategy) {
    return function (target) {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(ViewLocator.viewStrategyMetadataKey, strategy, target);
    };
}
function useView(path) {
    return useViewStrategy(new RelativeViewStrategy(path));
}
function inlineView(markup, dependencies, dependencyBaseUrl) {
    return useViewStrategy(new InlineViewStrategy(markup, dependencies, dependencyBaseUrl));
}
function noView(targetOrDependencies, dependencyBaseUrl) {
    let target;
    let dependencies;
    if (typeof targetOrDependencies === 'function') {
        target = targetOrDependencies;
    }
    else {
        dependencies = targetOrDependencies;
        target = undefined;
    }
    let deco = function (t) {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(ViewLocator.viewStrategyMetadataKey, new NoViewStrategy(dependencies, dependencyBaseUrl), t);
    };
    return target ? deco(target) : deco;
}
function view(templateOrConfig) {
    return function (target) {
        target.$view = templateOrConfig;
    };
}
function elementConfig(target) {
    let deco = function (t) {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.resource, new ElementConfigResource(), t);
    };
    return target ? deco(target) : deco;
}
function viewResources(...resources) {
    return function (target) {
        aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata.define(ViewEngine.viewModelRequireMetadataKey, resources, target);
    };
}

class TemplatingEngine {
    constructor(container, moduleAnalyzer, viewCompiler, compositionEngine) {
        this._container = container;
        this._moduleAnalyzer = moduleAnalyzer;
        this._viewCompiler = viewCompiler;
        this._compositionEngine = compositionEngine;
        container.registerInstance(Animator, Animator.instance = new Animator());
    }
    configureAnimator(animator) {
        this._container.unregister(Animator);
        this._container.registerInstance(Animator, Animator.instance = animator);
    }
    compose(context) {
        return this._compositionEngine.compose(context);
    }
    enhance(instruction) {
        if (instruction instanceof aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.Element) {
            instruction = { element: instruction };
        }
        let compilerInstructions = { letExpressions: [] };
        let resources = instruction.resources || this._container.get(ViewResources);
        this._viewCompiler._compileNode(instruction.element, resources, compilerInstructions, instruction.element.parentNode, 'root', true);
        let factory = new ViewFactory(instruction.element, compilerInstructions, resources);
        let container = instruction.container || this._container.createChild();
        let view = factory.create(container, BehaviorInstruction.enhance());
        view.bind(instruction.bindingContext || {}, instruction.overrideContext);
        view.firstChild = view.lastChild = view.fragment;
        view.fragment = aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.DOM.createDocumentFragment();
        view.attached();
        return view;
    }
}
TemplatingEngine.inject = [aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_6__.Container, ModuleAnalyzer, ViewCompiler, CompositionEngine];


//# sourceMappingURL=aurelia-templating.js.map


/***/ }),

/***/ "../../node_modules/aurelia-typed-observable-plugin/dist/es2015/index.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/aurelia-typed-observable-plugin/dist/es2015/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bindable: () => (/* binding */ bindable),
/* harmony export */   coerceFunctionMap: () => (/* binding */ coerceFunctionMap),
/* harmony export */   coerceFunctions: () => (/* binding */ coerceFunctions),
/* harmony export */   createTypedBindable: () => (/* binding */ createTypedBindable),
/* harmony export */   createTypedObservable: () => (/* binding */ createTypedObservable),
/* harmony export */   mapCoerceFunction: () => (/* binding */ mapCoerceFunction),
/* harmony export */   observable: () => (/* binding */ observable),
/* harmony export */   usePropertyTypeForBindable: () => (/* binding */ usePropertyType$1),
/* harmony export */   usePropertyTypeForObservable: () => (/* binding */ usePropertyType)
/* harmony export */ });
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-templating */ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js");




const coerceFunctions = {
    none(a) {
        return a;
    },
    number(a) {
        return Number(a);
    },
    string(a) {
        return '' + a;
    },
    boolean(a) {
        return !!a;
    },
    booleanAttr(val) {
        return val || val === '' ? true : false;
    },
    date(val) {
        if (val === null || val === undefined) {
            return null;
        }
        const d = new Date(val);
        return isNaN(d.getTime()) ? null : d;
    }
};
const coerceFunctionMap = new Map([
    [Boolean, 'boolean'],
    [String, 'string'],
    [Date, 'date'],
    [Number, 'number'],
]);
function mapCoerceFunction(type, strType, coerceFunction) {
    coerceFunction = coerceFunction || type.coerce;
    if (typeof strType !== 'string' || typeof coerceFunction !== 'function') {
        aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('map-coerce-function')
            .warn(`Bad attempt at mapping coerce function for type: ${type.name} to: ${strType}`);
        return;
    }
    coerceFunctions[strType] = coerceFunction;
    coerceFunctionMap.set(type, strType);
}

aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.BehaviorPropertyObserver.prototype.setCoerce = function (coerce) {
    this.coerce = typeof coerce === 'function' ? coerce : coerceFunctions[coerce];
    if (this.coerce === undefined) {
        aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('behavior-property-observer')
            .warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);
    }
};
aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.BehaviorPropertyObserver.prototype.setValue = function (newValue) {
    const oldValue = this.currentValue;
    const coercedValue = this.coerce === undefined ? newValue : this.coerce(newValue);
    if (oldValue !== coercedValue) {
        this.oldValue = oldValue;
        this.currentValue = coercedValue;
        if (this.publishing && this.notqueued) {
            if (this.taskQueue.flushing) {
                this.call();
            }
            else {
                this.notqueued = false;
                this.taskQueue.queueMicroTask(this);
            }
        }
    }
};
aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.BindableProperty.prototype.createObserver = function (viewModel) {
    let selfSubscriber = null;
    const defaultValue = this.defaultValue;
    const changeHandlerName = this.changeHandler;
    const name = this.name;
    let initialValue;
    if (this.hasOptions) {
        return undefined;
    }
    if (changeHandlerName in viewModel) {
        if ('propertyChanged' in viewModel) {
            selfSubscriber = (newValue, oldValue) => {
                viewModel[changeHandlerName](newValue, oldValue);
                viewModel.propertyChanged(name, newValue, oldValue);
            };
        }
        else {
            selfSubscriber = (newValue, oldValue) => viewModel[changeHandlerName](newValue, oldValue);
        }
    }
    else if ('propertyChanged' in viewModel) {
        selfSubscriber = (newValue, oldValue) => viewModel.propertyChanged(name, newValue, oldValue);
    }
    else if (changeHandlerName !== null) {
        throw new Error(`Change handler ${changeHandlerName} was specified but not declared on the class.`);
    }
    if (defaultValue !== undefined) {
        initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;
    }
    const observer = new aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.BehaviorPropertyObserver(this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);
    if (this.coerce !== undefined) {
        observer.setCoerce(this.coerce);
        observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(initialValue);
    }
    return observer;
};
aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.BindableProperty.prototype._createDynamicProperty = function (viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {
    const changeHandlerName = `${name}Changed`;
    let selfSubscriber = null;
    let observer;
    let info;
    if (changeHandlerName in viewModel) {
        if ('propertyChanged' in viewModel) {
            selfSubscriber = (newValue, oldValue) => {
                viewModel[changeHandlerName](newValue, oldValue);
                viewModel.propertyChanged(name, newValue, oldValue);
            };
        }
        else {
            selfSubscriber = (newValue, oldValue) => viewModel[changeHandlerName](newValue, oldValue);
        }
    }
    else if ('propertyChanged' in viewModel) {
        selfSubscriber = (newValue, oldValue) => viewModel.propertyChanged(name, newValue, oldValue);
    }
    observer = observerLookup[name] = new aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.BehaviorPropertyObserver(this.owner.taskQueue, viewModel, name, selfSubscriber, undefined);
    observer.setCoerce(this.coerce);
    observer.currentValue = observer.oldValue = observer.coerce === undefined ? observer.currentValue : observer.coerce(undefined);
    Object.defineProperty(viewModel, name, {
        configurable: true,
        enumerable: true,
        get: observer.getValue.bind(observer),
        set: observer.setValue.bind(observer)
    });
    if (behaviorHandlesBind) {
        observer.selfSubscriber = null;
    }
    if (typeof attribute === 'string') {
        viewModel[name] = attribute;
        observer.call();
    }
    else if (attribute) {
        info = { observer: observer, binding: attribute.createBinding(viewModel) };
        boundProperties.push(info);
    }
    observer.publishing = true;
    observer.selfSubscriber = selfSubscriber;
};

let _usePropertyType$1 = false;
const bindable = function bindable(nameOrTargetOrConfig, key, descriptor) {
    const deco = function (target, key2, descriptor2) {
        const actualTarget = key2 ? target.constructor : target;
        const r = aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.metadata.getOrCreateOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.metadata.resource, aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.HtmlBehaviorResource, actualTarget);
        let prop;
        let propType;
        if (key2) {
            nameOrTargetOrConfig = nameOrTargetOrConfig || {};
            nameOrTargetOrConfig.name = key2;
            if (nameOrTargetOrConfig.coerce === undefined && _usePropertyType$1) {
                propType = aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.metadata.getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.metadata.propertyType, target, key2);
                if (propType) {
                    const coerceType = coerceFunctionMap.get(propType);
                    if (coerceType === undefined) {
                        aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('@bindable decorator')
                            .warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);
                    }
                    nameOrTargetOrConfig.coerce = coerceType || 'none';
                }
            }
        }
        prop = new aurelia_templating__WEBPACK_IMPORTED_MODULE_2__.BindableProperty(nameOrTargetOrConfig);
        return prop.registerWith(actualTarget, r, descriptor2);
    };
    if (!nameOrTargetOrConfig) {
        return deco;
    }
    if (key) {
        const target = nameOrTargetOrConfig;
        nameOrTargetOrConfig = undefined;
        return deco(target, key, descriptor);
    }
    return deco;
};
['string', 'number', 'boolean', 'booleanAttr', 'date'].forEach(createTypedBindable);
function usePropertyType$1(shouldUsePropertyType) {
    _usePropertyType$1 = shouldUsePropertyType;
}
function createTypedBindable(type) {
    return bindable[type] = function (nameOrTargetOrConfig, key, descriptor) {
        if (nameOrTargetOrConfig === undefined) {
            return bindable({ coerce: type });
        }
        if (key === undefined) {
            nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;
            nameOrTargetOrConfig.coerce = type;
            return bindable(nameOrTargetOrConfig);
        }
        return bindable({ coerce: type })(nameOrTargetOrConfig, key, descriptor);
    };
}

const observableLogger = aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('aurelia-observable-decorator');
let _usePropertyType = false;
const observable = function observable(nameOrTargetOrConfig, key, descriptor) {
    function deco(target, key, descriptor, config) {
        let coerce = config === undefined || typeof config === 'string' ? undefined : config.coerce;
        let propType;
        let coerceFunction;
        if (coerce) {
            switch (typeof coerce) {
                case 'string':
                    coerceFunction = coerceFunctions[coerce];
                    break;
                case 'function':
                    coerceFunction = coerce;
                    break;
            }
            if (coerceFunction === undefined) {
                observableLogger.warn(`Invalid coerce instruction. Should be either one of ${Object.keys(coerceFunctions)} or a function.`);
            }
        }
        else if (_usePropertyType) {
            propType = aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.metadata.getOwn(aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.metadata.propertyType, target, key);
            if (propType) {
                coerceFunction = coerceFunctions[coerceFunctionMap.get(propType)];
                if (coerceFunction === undefined) {
                    observableLogger.warn(`Unable to find coerce function for type ${propType.name}.`);
                }
            }
        }
        const isClassDecorator = key === undefined;
        if (isClassDecorator) {
            target = target.prototype;
            key = typeof config === 'string' ? config : config.name;
        }
        const innerPropertyName = `_${key}`;
        const innerPropertyDescriptor = {
            configurable: true,
            enumerable: false,
            writable: true
        };
        if (config && 'defaultValue' in config) {
            const initValue = config.defaultValue;
            innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);
        }
        const callbackName = (config && config.changeHandler) || `${key}Changed`;
        if (descriptor) {
            if (typeof descriptor.initializer === 'function') {
                const initValue = descriptor.initializer();
                innerPropertyDescriptor.value = coerceFunction === undefined ? initValue : coerceFunction(initValue);
            }
        }
        else {
            descriptor = {};
        }
        if (!('enumerable' in descriptor)) {
            descriptor.enumerable = true;
        }
        delete descriptor.value;
        delete descriptor.writable;
        delete descriptor.initializer;
        Reflect.defineProperty(target, innerPropertyName, innerPropertyDescriptor);
        descriptor.get = function () { return this[innerPropertyName]; };
        descriptor.set = function (newValue) {
            let oldValue = this[innerPropertyName];
            let coercedValue = coerceFunction === undefined ? newValue : coerceFunction(newValue);
            if (coercedValue === oldValue) {
                return;
            }
            this[innerPropertyName] = coercedValue;
            Reflect.defineProperty(this, innerPropertyName, { enumerable: false });
            if (this[callbackName]) {
                this[callbackName](coercedValue, oldValue, key);
            }
        };
        descriptor.get.dependencies = [innerPropertyName];
        if (isClassDecorator) {
            Reflect.defineProperty(target, key, descriptor);
        }
        else {
            return descriptor;
        }
    }
    if (key === undefined) {
        return (t, k, d) => deco(t, k, d, nameOrTargetOrConfig);
    }
    return deco(nameOrTargetOrConfig, key, descriptor);
};
['string', 'number', 'boolean', 'date'].forEach(createTypedObservable);
function usePropertyType(shouldUsePropType) {
    _usePropertyType = !!shouldUsePropType;
}
function createTypedObservable(type) {
    return observable[type] = function (nameOrTargetOrConfig, key, descriptor) {
        if (nameOrTargetOrConfig === undefined) {
            return observable({ coerce: type });
        }
        if (key === undefined) {
            nameOrTargetOrConfig = typeof nameOrTargetOrConfig === 'string' ? { name: nameOrTargetOrConfig } : nameOrTargetOrConfig;
            nameOrTargetOrConfig.coerce = type;
            return observable(nameOrTargetOrConfig);
        }
        return observable({ coerce: type })(nameOrTargetOrConfig, key, descriptor);
    };
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "../../node_modules/aurelia-webpack-plugin/runtime/empty-entry.js":
/*!************************************************************************!*\
  !*** ../../node_modules/aurelia-webpack-plugin/runtime/empty-entry.js ***!
  \************************************************************************/
/***/ (() => {

// This file contains an empty module that does nothing.
// It's meant to be added as an entry point to the main bundle
// and helps reliably adding some Aurelia dependencies that are attached 
// to no module in particular, such as `includeAll` results or `aureliaApp`.
//
// Trying to attach those dependencies to, for example, 'aurelia-bootstrapper' 
// is unreliable if 'aurelia-bootstrapper' is in a DLL outside the bundle.
//
// Trying to attach to 'aurelia-loader-webpack' works well, unless a user
// configures a customized loader instead (unlikely, but in theory supported).


/***/ }),

/***/ "../../node_modules/aurelia-webpack-plugin/runtime/pal-loader-entry.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/aurelia-webpack-plugin/runtime/pal-loader-entry.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
// With default aurelia-loader-webpack config, this module is added as an extra entry
// before any other code executes so that PAL.Loader is properly configured.
// There are several tricky points worth noticing.
// 
// We don't add aurelia-loader-webpack itself as an entry point (used to until 2.0 RC2)
// because it (transitively) brings too much bagage with itself, most notably polyfills.
// This made it super-hard to add other polyfills before Aurelia's and led to various bugs.
//
// We don't add custom code in aurelia-pal or aurelia-loader or aurelia-bootstrapper to detect
// the Webpack environment and configure the loader because they might live in a DLL.
// If they do, they would bring aurelia-loader-webpack along in the DLL and this is a special 
// library that *has to be in the main chunk.*
//
// The over-complicated design I've settled upon in the end is to use this special module
// as an entry point that configures aurelia-loader-webpack. It has minimal static imports:
// just aurelia-pal, which itself has no other dependencies and doesn't run much code.
// It hacks the loader field into a getter so that it can synchronously load aurelia-loader-webpack
// just in time when it is demanded by aurelia-bootstrapper.
// This enables users to load polyfills before aurelia-loader-webpack is actually loaded.



var Loader;

Object.defineProperty(aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.PLATFORM, "Loader", {
  get: function() {
    return Loader || (Loader = (__webpack_require__(/*! aurelia-loader-webpack */ "../../node_modules/aurelia-loader-webpack/dist/es2015/aurelia-loader-webpack.js").WebpackLoader));
  },
  set: function(value) {
    Loader = value;
  }
});


/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/api.js":
/*!*********************************************************!*\
  !*** ../../node_modules/css-loader/dist/runtime/api.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/getUrl.js":
/*!************************************************************!*\
  !*** ../../node_modules/css-loader/dist/runtime/getUrl.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ "../../node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!****************************************************************!*\
  !*** ../../node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "../../node_modules/tslib/tslib.es6.mjs":
/*!**********************************************!*\
  !*** ../../node_modules/tslib/tslib.es6.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ }),

/***/ "../aurelia-gridstack/src/models.ts":
/*!******************************************!*\
  !*** ../aurelia-gridstack/src/models.ts ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.ResizeHandles = void 0;
    var ResizeHandles;
    (function (ResizeHandles) {
        ResizeHandles["n"] = "n";
        ResizeHandles["ne"] = "ne";
        ResizeHandles["e"] = "e";
        ResizeHandles["se"] = "se";
        ResizeHandles["s"] = "s";
        ResizeHandles["sw"] = "sw";
        ResizeHandles["w"] = "w";
        ResizeHandles["nw"] = "nw";
    })(ResizeHandles || (exports.ResizeHandles = ResizeHandles = {}));
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "../aurelia-gridstack/src/utils.ts":
/*!*****************************************!*\
  !*** ../aurelia-gridstack/src/utils.ts ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ./models */ "../aurelia-gridstack/src/models.ts")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, models_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.getResizeHandleTypesOnly = getResizeHandleTypesOnly;
    function onlyUnique(value, index, self) {
        return self.indexOf(value) === index;
    }
    function getResizeHandleTypesOnly(handles) {
        const handlesArray = [];
        if (handles) {
            let allEntries = handles.replace(/\s/g, '').split(',');
            // remove duplicates
            allEntries = allEntries.filter(onlyUnique);
            // add only ResizeHandleType items
            allEntries.forEach((child) => {
                if (child in models_1.ResizeHandles) {
                    handlesArray.push(child);
                }
            });
        }
        return handlesArray;
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "./node_modules/gridstack/dist/dd-base-impl.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-base-impl.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDBaseImplement: () => (/* binding */ DDBaseImplement)
/* harmony export */ });
/**
 * dd-base-impl.ts 10.3.1
 * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license
 */
class DDBaseImplement {
    constructor() {
        /** @internal */
        this._eventRegister = {};
    }
    /** returns the enable state, but you have to call enable()/disable() to change (as other things need to happen) */
    get disabled() { return this._disabled; }
    on(event, callback) {
        this._eventRegister[event] = callback;
    }
    off(event) {
        delete this._eventRegister[event];
    }
    enable() {
        this._disabled = false;
    }
    disable() {
        this._disabled = true;
    }
    destroy() {
        delete this._eventRegister;
    }
    triggerEvent(eventName, event) {
        if (!this.disabled && this._eventRegister && this._eventRegister[eventName])
            return this._eventRegister[eventName](event);
    }
}
//# sourceMappingURL=dd-base-impl.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-draggable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-draggable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDDraggable: () => (/* binding */ DDDraggable)
/* harmony export */ });
/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ "./node_modules/gridstack/dist/dd-manager.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/gridstack/dist/utils.js");
/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-base-impl */ "./node_modules/gridstack/dist/dd-base-impl.js");
/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ "./node_modules/gridstack/dist/dd-touch.js");
/**
 * dd-draggable.ts 10.3.1
 * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license
 */




// make sure we are not clicking on known object that handles mouseDown
const skipMouseDown = 'input,textarea,button,select,option,[contenteditable="true"],.ui-resizable-handle';
// let count = 0; // TEST
class DDDraggable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_2__.DDBaseImplement {
    constructor(el, option = {}) {
        super();
        this.el = el;
        this.option = option;
        /** @internal */
        this.dragTransform = {
            xScale: 1,
            yScale: 1,
            xOffset: 0,
            yOffset: 0
        };
        // get the element that is actually supposed to be dragged by
        const handleName = option.handle.substring(1);
        const n = el.gridstackNode;
        this.dragEls = el.classList.contains(handleName) ? [el] : (n?.subGrid ? [el.querySelector(option.handle) || el] : Array.from(el.querySelectorAll(option.handle)));
        if (this.dragEls.length === 0) {
            this.dragEls = [el];
        }
        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)
        this._mouseDown = this._mouseDown.bind(this);
        this._mouseMove = this._mouseMove.bind(this);
        this._mouseUp = this._mouseUp.bind(this);
        this._keyEvent = this._keyEvent.bind(this);
        this.enable();
    }
    on(event, callback) {
        super.on(event, callback);
    }
    off(event) {
        super.off(event);
    }
    enable() {
        if (this.disabled === false)
            return;
        super.enable();
        this.dragEls.forEach(dragEl => {
            dragEl.addEventListener('mousedown', this._mouseDown);
            if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {
                dragEl.addEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);
                dragEl.addEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);
                // dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment
            }
        });
        this.el.classList.remove('ui-draggable-disabled');
    }
    disable(forDestroy = false) {
        if (this.disabled === true)
            return;
        super.disable();
        this.dragEls.forEach(dragEl => {
            dragEl.removeEventListener('mousedown', this._mouseDown);
            if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {
                dragEl.removeEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchstart);
                dragEl.removeEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerdown);
            }
        });
        if (!forDestroy)
            this.el.classList.add('ui-draggable-disabled');
    }
    destroy() {
        if (this.dragTimeout)
            window.clearTimeout(this.dragTimeout);
        delete this.dragTimeout;
        if (this.mouseDownEvent)
            this._mouseUp(this.mouseDownEvent);
        this.disable(true);
        delete this.el;
        delete this.helper;
        delete this.option;
        super.destroy();
    }
    updateOption(opts) {
        Object.keys(opts).forEach(key => this.option[key] = opts[key]);
        return this;
    }
    /** @internal call when mouse goes down before a dragstart happens */
    _mouseDown(e) {
        // don't let more than one widget handle mouseStart
        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled)
            return;
        if (e.button !== 0)
            return true; // only left click
        // make sure we are not clicking on known object that handles mouseDown, or ones supplied by the user
        if (!this.dragEls.find(el => el === e.target) && e.target.closest(skipMouseDown))
            return true;
        if (this.option.cancel) {
            if (e.target.closest(this.option.cancel))
                return true;
        }
        // REMOVE: why would we get the event if it wasn't for us or child ?
        // make sure we are clicking on a drag handle or child of it...
        // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)
        // let className = this.option.handle.substring(1);
        // let el = e.target as HTMLElement;
        // while (el && !el.classList.contains(className)) { el = el.parentElement; }
        // if (!el) return;
        this.mouseDownEvent = e;
        delete this.dragging;
        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;
        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;
        // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack
        document.addEventListener('mousemove', this._mouseMove, { capture: true, passive: true }); // true=capture, not bubble
        document.addEventListener('mouseup', this._mouseUp, true);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {
            e.target.addEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove);
            e.target.addEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend);
        }
        e.preventDefault();
        // preventDefault() prevents blur event which occurs just after mousedown event.
        // if an editable content has focus, then blur must be call
        if (document.activeElement)
            document.activeElement.blur();
        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled = true;
        return true;
    }
    /** @internal method to call actual drag event */
    _callDrag(e) {
        if (!this.dragging)
            return;
        const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, { target: this.el, type: 'drag' });
        if (this.option.drag) {
            this.option.drag(ev, this.ui());
        }
        this.triggerEvent('drag', ev);
    }
    /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */
    _mouseMove(e) {
        // console.log(`${count++} move ${e.x},${e.y}`)
        let s = this.mouseDownEvent;
        this.lastDrag = e;
        if (this.dragging) {
            this._dragFollow(e);
            // delay actual grid handling drag until we pause for a while if set
            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) {
                const pause = Number.isInteger(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag) ? _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.pauseDrag : 100;
                if (this.dragTimeout)
                    window.clearTimeout(this.dragTimeout);
                this.dragTimeout = window.setTimeout(() => this._callDrag(e), pause);
            }
            else {
                this._callDrag(e);
            }
        }
        else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {
            /**
             * don't start unless we've moved at least 3 pixels
             */
            this.dragging = true;
            _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement = this;
            // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)
            let grid = this.el.gridstackNode?.grid;
            if (grid) {
                _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = grid.el.ddElement.ddDroppable;
            }
            else {
                delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;
            }
            this.helper = this._createHelper(e);
            this._setupHelperContainmentStyle();
            this.dragTransform = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getValuesFromTransformedElement(this.helperContainment);
            this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);
            this._setupHelperStyle(e);
            const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, { target: this.el, type: 'dragstart' });
            if (this.option.start) {
                this.option.start(ev, this.ui());
            }
            this.triggerEvent('dragstart', ev);
            // now track keyboard events to cancel or rotate
            document.addEventListener('keydown', this._keyEvent);
        }
        // e.preventDefault(); // passive = true. OLD: was needed otherwise we get text sweep text selection as we drag around
        return true;
    }
    /** @internal call when the mouse gets released to drop the item at current location */
    _mouseUp(e) {
        document.removeEventListener('mousemove', this._mouseMove, true);
        document.removeEventListener('mouseup', this._mouseUp, true);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {
            e.target.removeEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchmove, true);
            e.target.removeEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.touchend, true);
        }
        if (this.dragging) {
            delete this.dragging;
            delete this.el.gridstackNode?._origRotate;
            document.removeEventListener('keydown', this._keyEvent);
            // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)
            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement?.el === this.el.parentElement) {
                delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;
            }
            this.helperContainment.style.position = this.parentOriginStylePosition || null;
            if (this.helper === this.el) {
                this._removeHelperStyle();
            }
            else {
                this.helper.remove();
            }
            const ev = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.initEvent(e, { target: this.el, type: 'dragstop' });
            if (this.option.stop) {
                this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!
            }
            this.triggerEvent('dragstop', ev);
            // call the droppable method to receive the item
            if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement) {
                _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement.drop(e);
            }
        }
        delete this.helper;
        delete this.mouseDownEvent;
        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;
        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;
        delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.mouseHandled;
        e.preventDefault();
    }
    /** @internal call when keys are being pressed - use Esc to cancel, R to rotate */
    _keyEvent(e) {
        const n = this.el.gridstackNode;
        if (!n?.grid)
            return;
        const grid = n.grid;
        if (e.key === 'Escape') {
            if (n._origRotate) {
                n._orig = n._origRotate;
                delete n._origRotate;
            }
            grid.engine.restoreInitial();
            this._mouseUp(this.mouseDownEvent);
        }
        else if (e.key === 'r' || e.key === 'R') {
            if (!_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.canBeRotated(n))
                return;
            n._origRotate = n._origRotate || { ...n._orig }; // store the real orig size in case we Esc after doing rotation
            delete n._moving; // force rotate to happen (move waits for >50% coverage otherwise)
            grid.setAnimation(false) // immediate rotate so _getDragOffset() gets the right dom size below
                .rotate(n.el, { top: -this.dragOffset.offsetTop, left: -this.dragOffset.offsetLeft })
                .setAnimation();
            n._moving = true;
            this.dragOffset = this._getDragOffset(this.lastDrag, n.el, this.helperContainment);
            this.helper.style.width = this.dragOffset.width + 'px';
            this.helper.style.height = this.dragOffset.height + 'px';
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.swap(n._orig, 'w', 'h');
            delete n._rect;
            this._mouseMove(this.lastDrag);
        }
    }
    /** @internal create a clone copy (or user defined method) of the original drag item if set */
    _createHelper(event) {
        let helper = this.el;
        if (typeof this.option.helper === 'function') {
            helper = this.option.helper(event);
        }
        else if (this.option.helper === 'clone') {
            helper = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneNode(this.el);
        }
        if (!document.body.contains(helper)) {
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentElement : this.option.appendTo);
        }
        if (helper === this.el) {
            this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);
        }
        return helper;
    }
    /** @internal set the fix position of the dragged item */
    _setupHelperStyle(e) {
        this.helper.classList.add('ui-draggable-dragging');
        // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593
        const style = this.helper.style;
        style.pointerEvents = 'none'; // needed for over items to get enter/leave
        // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)
        style.width = this.dragOffset.width + 'px';
        style.height = this.dragOffset.height + 'px';
        style.willChange = 'left, top';
        style.position = 'fixed'; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'
        this._dragFollow(e); // now position it
        style.transition = 'none'; // show up instantly
        setTimeout(() => {
            if (this.helper) {
                style.transition = null; // recover animation
            }
        }, 0);
        return this;
    }
    /** @internal restore back the original style before dragging */
    _removeHelperStyle() {
        this.helper.classList.remove('ui-draggable-dragging');
        let node = this.helper?.gridstackNode;
        // don't bother restoring styles if we're gonna remove anyway...
        if (!node?._isAboutToRemove && this.dragElementOriginStyle) {
            let helper = this.helper;
            // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.
            // TODO: this also removes resizing animation which doesn't have this issue, but others.
            // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,
            // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'
            // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)
            let transition = this.dragElementOriginStyle['transition'] || null;
            helper.style.transition = this.dragElementOriginStyle['transition'] = 'none'; // can't be NULL #1973
            DDDraggable.originStyleProp.forEach(prop => helper.style[prop] = this.dragElementOriginStyle[prop] || null);
            setTimeout(() => helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)
        }
        delete this.dragElementOriginStyle;
        return this;
    }
    /** @internal updates the top/left position to follow the mouse */
    _dragFollow(e) {
        let containmentRect = { left: 0, top: 0 };
        // if (this.helper.style.position === 'absolute') { // we use 'fixed'
        //   const { left, top } = this.helperContainment.getBoundingClientRect();
        //   containmentRect = { left, top };
        // }
        const style = this.helper.style;
        const offset = this.dragOffset;
        style.left = (e.clientX + offset.offsetLeft - containmentRect.left) * this.dragTransform.xScale + 'px';
        style.top = (e.clientY + offset.offsetTop - containmentRect.top) * this.dragTransform.yScale + 'px';
    }
    /** @internal */
    _setupHelperContainmentStyle() {
        this.helperContainment = this.helper.parentElement;
        if (this.helper.style.position !== 'fixed') {
            this.parentOriginStylePosition = this.helperContainment.style.position;
            if (getComputedStyle(this.helperContainment).position.match(/static/)) {
                this.helperContainment.style.position = 'relative';
            }
        }
        return this;
    }
    /** @internal */
    _getDragOffset(event, el, parent) {
        // in case ancestor has transform/perspective css properties that change the viewpoint
        let xformOffsetX = 0;
        let xformOffsetY = 0;
        if (parent) {
            xformOffsetX = this.dragTransform.xOffset;
            xformOffsetY = this.dragTransform.yOffset;
        }
        const targetOffset = el.getBoundingClientRect();
        return {
            left: targetOffset.left,
            top: targetOffset.top,
            offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,
            offsetTop: -event.clientY + targetOffset.top - xformOffsetY,
            width: targetOffset.width * this.dragTransform.xScale,
            height: targetOffset.height * this.dragTransform.yScale
        };
    }
    /** @internal TODO: set to public as called by DDDroppable! */
    ui() {
        const containmentEl = this.el.parentElement;
        const containmentRect = containmentEl.getBoundingClientRect();
        const offset = this.helper.getBoundingClientRect();
        return {
            position: {
                top: (offset.top - containmentRect.top) * this.dragTransform.yScale,
                left: (offset.left - containmentRect.left) * this.dragTransform.xScale
            }
            /* not used by GridStack for now...
            helper: [this.helper], //The object arr representing the helper that's being dragged.
            offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.
            */
        };
    }
}
/** @internal properties we change during dragging, and restore back */
DDDraggable.originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'minWidth', 'willChange'];

//# sourceMappingURL=dd-draggable.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-droppable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-droppable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDDroppable: () => (/* binding */ DDDroppable)
/* harmony export */ });
/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ "./node_modules/gridstack/dist/dd-manager.js");
/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ "./node_modules/gridstack/dist/dd-base-impl.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/gridstack/dist/utils.js");
/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-touch */ "./node_modules/gridstack/dist/dd-touch.js");
/**
 * dd-droppable.ts 10.3.1
 * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license
 */




// let count = 0; // TEST
class DDDroppable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {
    constructor(el, option = {}) {
        super();
        this.el = el;
        this.option = option;
        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)
        this._mouseEnter = this._mouseEnter.bind(this);
        this._mouseLeave = this._mouseLeave.bind(this);
        this.enable();
        this._setupAccept();
    }
    on(event, callback) {
        super.on(event, callback);
    }
    off(event) {
        super.off(event);
    }
    enable() {
        if (this.disabled === false)
            return;
        super.enable();
        this.el.classList.add('ui-droppable');
        this.el.classList.remove('ui-droppable-disabled');
        this.el.addEventListener('mouseenter', this._mouseEnter);
        this.el.addEventListener('mouseleave', this._mouseLeave);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {
            this.el.addEventListener('pointerenter', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);
            this.el.addEventListener('pointerleave', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);
        }
    }
    disable(forDestroy = false) {
        if (this.disabled === true)
            return;
        super.disable();
        this.el.classList.remove('ui-droppable');
        if (!forDestroy)
            this.el.classList.add('ui-droppable-disabled');
        this.el.removeEventListener('mouseenter', this._mouseEnter);
        this.el.removeEventListener('mouseleave', this._mouseLeave);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_3__.isTouch) {
            this.el.removeEventListener('pointerenter', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerenter);
            this.el.removeEventListener('pointerleave', _dd_touch__WEBPACK_IMPORTED_MODULE_3__.pointerleave);
        }
    }
    destroy() {
        this.disable(true);
        this.el.classList.remove('ui-droppable');
        this.el.classList.remove('ui-droppable-disabled');
        super.destroy();
    }
    updateOption(opts) {
        Object.keys(opts).forEach(key => this.option[key] = opts[key]);
        this._setupAccept();
        return this;
    }
    /** @internal called when the cursor enters our area - prepare for a possible drop and track leaving */
    _mouseEnter(e) {
        // console.log(`${count++} Enter ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST
        if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement)
            return;
        if (!this._canDrop(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement.el))
            return;
        e.preventDefault();
        e.stopPropagation();
        // make sure when we enter this, that the last one gets a leave FIRST to correctly cleanup as we don't always do
        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement && _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this) {
            _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement._mouseLeave(e, true); // calledByEnter = true
        }
        _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement = this;
        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, { target: this.el, type: 'dropover' });
        if (this.option.over) {
            this.option.over(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));
        }
        this.triggerEvent('dropover', ev);
        this.el.classList.add('ui-droppable-over');
        // console.log('tracking'); // TEST
    }
    /** @internal called when the item is leaving our area, stop tracking if we had moving item */
    _mouseLeave(e, calledByEnter = false) {
        // console.log(`${count++} Leave ${this.el.id || (this.el as GridHTMLElement).gridstack.opts.id}`); // TEST
        if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement || _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement !== this)
            return;
        e.preventDefault();
        e.stopPropagation();
        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, { target: this.el, type: 'dropout' });
        if (this.option.out) {
            this.option.out(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));
        }
        this.triggerEvent('dropout', ev);
        if (_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement === this) {
            delete _dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dropElement;
            // console.log('not tracking'); // TEST
            // if we're still over a parent droppable, send it an enter as we don't get one from leaving nested children
            if (!calledByEnter) {
                let parentDrop;
                let parent = this.el.parentElement;
                while (!parentDrop && parent) {
                    parentDrop = parent.ddElement?.ddDroppable;
                    parent = parent.parentElement;
                }
                if (parentDrop) {
                    parentDrop._mouseEnter(e);
                }
            }
        }
    }
    /** item is being dropped on us - called by the drag mouseup handler - this calls the client drop event */
    drop(e) {
        e.preventDefault();
        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(e, { target: this.el, type: 'drop' });
        if (this.option.drop) {
            this.option.drop(ev, this._ui(_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement));
        }
        this.triggerEvent('drop', ev);
    }
    /** @internal true if element matches the string/method accept option */
    _canDrop(el) {
        return el && (!this.accept || this.accept(el));
    }
    /** @internal */
    _setupAccept() {
        if (!this.option.accept)
            return this;
        if (typeof this.option.accept === 'string') {
            this.accept = (el) => el.classList.contains(this.option.accept) || el.matches(this.option.accept);
        }
        else {
            this.accept = this.option.accept;
        }
        return this;
    }
    /** @internal */
    _ui(drag) {
        return {
            draggable: drag.el,
            ...drag.ui()
        };
    }
}
//# sourceMappingURL=dd-droppable.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-element.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-element.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDElement: () => (/* binding */ DDElement)
/* harmony export */ });
/* harmony import */ var _dd_resizable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable */ "./node_modules/gridstack/dist/dd-resizable.js");
/* harmony import */ var _dd_draggable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-draggable */ "./node_modules/gridstack/dist/dd-draggable.js");
/* harmony import */ var _dd_droppable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-droppable */ "./node_modules/gridstack/dist/dd-droppable.js");
/**
 * dd-elements.ts 10.3.1
 * Copyright (c) 2021 Alain Dumesny - see GridStack root license
 */



class DDElement {
    static init(el) {
        if (!el.ddElement) {
            el.ddElement = new DDElement(el);
        }
        return el.ddElement;
    }
    constructor(el) {
        this.el = el;
    }
    on(eventName, callback) {
        if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {
            this.ddDraggable.on(eventName, callback);
        }
        else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {
            this.ddDroppable.on(eventName, callback);
        }
        else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {
            this.ddResizable.on(eventName, callback);
        }
        return this;
    }
    off(eventName) {
        if (this.ddDraggable && ['drag', 'dragstart', 'dragstop'].indexOf(eventName) > -1) {
            this.ddDraggable.off(eventName);
        }
        else if (this.ddDroppable && ['drop', 'dropover', 'dropout'].indexOf(eventName) > -1) {
            this.ddDroppable.off(eventName);
        }
        else if (this.ddResizable && ['resizestart', 'resize', 'resizestop'].indexOf(eventName) > -1) {
            this.ddResizable.off(eventName);
        }
        return this;
    }
    setupDraggable(opts) {
        if (!this.ddDraggable) {
            this.ddDraggable = new _dd_draggable__WEBPACK_IMPORTED_MODULE_1__.DDDraggable(this.el, opts);
        }
        else {
            this.ddDraggable.updateOption(opts);
        }
        return this;
    }
    cleanDraggable() {
        if (this.ddDraggable) {
            this.ddDraggable.destroy();
            delete this.ddDraggable;
        }
        return this;
    }
    setupResizable(opts) {
        if (!this.ddResizable) {
            this.ddResizable = new _dd_resizable__WEBPACK_IMPORTED_MODULE_0__.DDResizable(this.el, opts);
        }
        else {
            this.ddResizable.updateOption(opts);
        }
        return this;
    }
    cleanResizable() {
        if (this.ddResizable) {
            this.ddResizable.destroy();
            delete this.ddResizable;
        }
        return this;
    }
    setupDroppable(opts) {
        if (!this.ddDroppable) {
            this.ddDroppable = new _dd_droppable__WEBPACK_IMPORTED_MODULE_2__.DDDroppable(this.el, opts);
        }
        else {
            this.ddDroppable.updateOption(opts);
        }
        return this;
    }
    cleanDroppable() {
        if (this.ddDroppable) {
            this.ddDroppable.destroy();
            delete this.ddDroppable;
        }
        return this;
    }
}
//# sourceMappingURL=dd-element.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-gridstack.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-gridstack.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDGridStack: () => (/* binding */ DDGridStack)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/gridstack/dist/utils.js");
/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-manager */ "./node_modules/gridstack/dist/dd-manager.js");
/* harmony import */ var _dd_element__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dd-element */ "./node_modules/gridstack/dist/dd-element.js");
/**
 * dd-gridstack.ts 10.3.1
 * Copyright (c) 2021 Alain Dumesny - see GridStack root license
 */



// let count = 0; // TEST
/**
 * HTML Native Mouse and Touch Events Drag and Drop functionality.
 */
class DDGridStack {
    resizable(el, opts, key, value) {
        this._getDDElements(el).forEach(dEl => {
            if (opts === 'disable' || opts === 'enable') {
                dEl.ddResizable && dEl.ddResizable[opts](); // can't create DD as it requires options for setupResizable()
            }
            else if (opts === 'destroy') {
                dEl.ddResizable && dEl.cleanResizable();
            }
            else if (opts === 'option') {
                dEl.setupResizable({ [key]: value });
            }
            else {
                const n = dEl.el.gridstackNode;
                const grid = n.grid;
                let handles = dEl.el.getAttribute('gs-resize-handles') || grid.opts.resizable.handles || 'e,s,se';
                if (handles === 'all')
                    handles = 'n,e,s,w,se,sw,ne,nw';
                // NOTE: keep the resize handles as e,w don't have enough space (10px) to show resize corners anyway. limit during drag instead
                // restrict vertical resize if height is done to match content anyway... odd to have it spring back
                // if (Utils.shouldSizeToContent(n, true)) {
                //   const doE = handles.indexOf('e') !== -1;
                //   const doW = handles.indexOf('w') !== -1;
                //   handles = doE ? (doW ? 'e,w' : 'e') : (doW ? 'w' : '');
                // }
                const autoHide = !grid.opts.alwaysShowResizeHandle;
                dEl.setupResizable({
                    ...grid.opts.resizable,
                    ...{ handles, autoHide },
                    ...{
                        start: opts.start,
                        stop: opts.stop,
                        resize: opts.resize
                    }
                });
            }
        });
        return this;
    }
    draggable(el, opts, key, value) {
        this._getDDElements(el).forEach(dEl => {
            if (opts === 'disable' || opts === 'enable') {
                dEl.ddDraggable && dEl.ddDraggable[opts](); // can't create DD as it requires options for setupDraggable()
            }
            else if (opts === 'destroy') {
                dEl.ddDraggable && dEl.cleanDraggable();
            }
            else if (opts === 'option') {
                dEl.setupDraggable({ [key]: value });
            }
            else {
                const grid = dEl.el.gridstackNode.grid;
                dEl.setupDraggable({
                    ...grid.opts.draggable,
                    ...{
                        // containment: (grid.parentGridItem && grid.opts.dragOut === false) ? grid.el.parentElement : (grid.opts.draggable.containment || null),
                        start: opts.start,
                        stop: opts.stop,
                        drag: opts.drag
                    }
                });
            }
        });
        return this;
    }
    dragIn(el, opts) {
        this._getDDElements(el).forEach(dEl => dEl.setupDraggable(opts));
        return this;
    }
    droppable(el, opts, key, value) {
        if (typeof opts.accept === 'function' && !opts._accept) {
            opts._accept = opts.accept;
            opts.accept = (el) => opts._accept(el);
        }
        this._getDDElements(el).forEach(dEl => {
            if (opts === 'disable' || opts === 'enable') {
                dEl.ddDroppable && dEl.ddDroppable[opts]();
            }
            else if (opts === 'destroy') {
                if (dEl.ddDroppable) { // error to call destroy if not there
                    dEl.cleanDroppable();
                }
            }
            else if (opts === 'option') {
                dEl.setupDroppable({ [key]: value });
            }
            else {
                dEl.setupDroppable(opts);
            }
        });
        return this;
    }
    /** true if element is droppable */
    isDroppable(el) {
        return !!(el && el.ddElement && el.ddElement.ddDroppable && !el.ddElement.ddDroppable.disabled);
    }
    /** true if element is draggable */
    isDraggable(el) {
        return !!(el && el.ddElement && el.ddElement.ddDraggable && !el.ddElement.ddDraggable.disabled);
    }
    /** true if element is draggable */
    isResizable(el) {
        return !!(el && el.ddElement && el.ddElement.ddResizable && !el.ddElement.ddResizable.disabled);
    }
    on(el, name, callback) {
        this._getDDElements(el).forEach(dEl => dEl.on(name, (event) => {
            callback(event, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.el : event.target, _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement ? _dd_manager__WEBPACK_IMPORTED_MODULE_1__.DDManager.dragElement.helper : null);
        }));
        return this;
    }
    off(el, name) {
        this._getDDElements(el).forEach(dEl => dEl.off(name));
        return this;
    }
    /** @internal returns a list of DD elements, creating them on the fly by default */
    _getDDElements(els, create = true) {
        let hosts = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.getElements(els);
        if (!hosts.length)
            return [];
        let list = hosts.map(e => e.ddElement || (create ? _dd_element__WEBPACK_IMPORTED_MODULE_2__.DDElement.init(e) : null));
        if (!create) {
            list.filter(d => d);
        } // remove nulls
        return list;
    }
}
//# sourceMappingURL=dd-gridstack.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-manager.js":
/*!***************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-manager.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDManager: () => (/* binding */ DDManager)
/* harmony export */ });
/**
 * dd-manager.ts 10.3.1
 * Copyright (c) 2021 Alain Dumesny - see GridStack root license
 */
/**
 * globals that are shared across Drag & Drop instances
 */
class DDManager {
}
//# sourceMappingURL=dd-manager.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable-handle.js":
/*!************************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable-handle.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDResizableHandle: () => (/* binding */ DDResizableHandle)
/* harmony export */ });
/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-touch */ "./node_modules/gridstack/dist/dd-touch.js");
/**
 * dd-resizable-handle.ts 10.3.1
 * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license
 */

class DDResizableHandle {
    constructor(host, dir, option) {
        this.host = host;
        this.dir = dir;
        this.option = option;
        /** @internal true after we've moved enough pixels to start a resize */
        this.moving = false;
        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)
        this._mouseDown = this._mouseDown.bind(this);
        this._mouseMove = this._mouseMove.bind(this);
        this._mouseUp = this._mouseUp.bind(this);
        this._keyEvent = this._keyEvent.bind(this);
        this._init();
    }
    /** @internal */
    _init() {
        const el = this.el = document.createElement('div');
        el.classList.add('ui-resizable-handle');
        el.classList.add(`${DDResizableHandle.prefix}${this.dir}`);
        el.style.zIndex = '100';
        el.style.userSelect = 'none';
        this.host.appendChild(this.el);
        this.el.addEventListener('mousedown', this._mouseDown);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {
            this.el.addEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);
            this.el.addEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);
            // this.el.style.touchAction = 'none'; // not needed unlike pointerdown doc comment
        }
        return this;
    }
    /** call this when resize handle needs to be removed and cleaned up */
    destroy() {
        if (this.moving)
            this._mouseUp(this.mouseDownEvent);
        this.el.removeEventListener('mousedown', this._mouseDown);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {
            this.el.removeEventListener('touchstart', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchstart);
            this.el.removeEventListener('pointerdown', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.pointerdown);
        }
        this.host.removeChild(this.el);
        delete this.el;
        delete this.host;
        return this;
    }
    /** @internal called on mouse down on us: capture move on the entire document (mouse might not stay on us) until we release the mouse */
    _mouseDown(e) {
        this.mouseDownEvent = e;
        document.addEventListener('mousemove', this._mouseMove, { capture: true, passive: true }); // capture, not bubble
        document.addEventListener('mouseup', this._mouseUp, true);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {
            this.el.addEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);
            this.el.addEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);
        }
        e.stopPropagation();
        e.preventDefault();
    }
    /** @internal */
    _mouseMove(e) {
        let s = this.mouseDownEvent;
        if (this.moving) {
            this._triggerEvent('move', e);
        }
        else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 2) {
            // don't start unless we've moved at least 3 pixels
            this.moving = true;
            this._triggerEvent('start', this.mouseDownEvent);
            this._triggerEvent('move', e);
            // now track keyboard events to cancel
            document.addEventListener('keydown', this._keyEvent);
        }
        e.stopPropagation();
        // e.preventDefault(); passive = true
    }
    /** @internal */
    _mouseUp(e) {
        if (this.moving) {
            this._triggerEvent('stop', e);
            document.removeEventListener('keydown', this._keyEvent);
        }
        document.removeEventListener('mousemove', this._mouseMove, true);
        document.removeEventListener('mouseup', this._mouseUp, true);
        if (_dd_touch__WEBPACK_IMPORTED_MODULE_0__.isTouch) {
            this.el.removeEventListener('touchmove', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchmove);
            this.el.removeEventListener('touchend', _dd_touch__WEBPACK_IMPORTED_MODULE_0__.touchend);
        }
        delete this.moving;
        delete this.mouseDownEvent;
        e.stopPropagation();
        e.preventDefault();
    }
    /** @internal call when keys are being pressed - use Esc to cancel */
    _keyEvent(e) {
        if (e.key === 'Escape') {
            this.host.gridstackNode?.grid?.engine.restoreInitial();
            this._mouseUp(this.mouseDownEvent);
        }
    }
    /** @internal */
    _triggerEvent(name, event) {
        if (this.option[name])
            this.option[name](event);
        return this;
    }
}
/** @internal */
DDResizableHandle.prefix = 'ui-resizable-';

//# sourceMappingURL=dd-resizable-handle.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-resizable.js":
/*!*****************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-resizable.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDResizable: () => (/* binding */ DDResizable)
/* harmony export */ });
/* harmony import */ var _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-resizable-handle */ "./node_modules/gridstack/dist/dd-resizable-handle.js");
/* harmony import */ var _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dd-base-impl */ "./node_modules/gridstack/dist/dd-base-impl.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./node_modules/gridstack/dist/utils.js");
/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-manager */ "./node_modules/gridstack/dist/dd-manager.js");
/**
 * dd-resizable.ts 10.3.1
 * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license
 */




class DDResizable extends _dd_base_impl__WEBPACK_IMPORTED_MODULE_1__.DDBaseImplement {
    // have to be public else complains for HTMLElementExtendOpt ?
    constructor(el, option = {}) {
        super();
        this.el = el;
        this.option = option;
        /** @internal */
        this.rectScale = { x: 1, y: 1 };
        /** @internal */
        this._ui = () => {
            const containmentEl = this.el.parentElement;
            const containmentRect = containmentEl.getBoundingClientRect();
            const newRect = {
                width: this.originalRect.width,
                height: this.originalRect.height + this.scrolled,
                left: this.originalRect.left,
                top: this.originalRect.top - this.scrolled
            };
            const rect = this.temporalRect || newRect;
            return {
                position: {
                    left: (rect.left - containmentRect.left) * this.rectScale.x,
                    top: (rect.top - containmentRect.top) * this.rectScale.y
                },
                size: {
                    width: rect.width * this.rectScale.x,
                    height: rect.height * this.rectScale.y
                }
                /* Gridstack ONLY needs position set above... keep around in case.
                element: [this.el], // The object representing the element to be resized
                helper: [], // TODO: not support yet - The object representing the helper that's being resized
                originalElement: [this.el],// we don't wrap here, so simplify as this.el //The object representing the original element before it is wrapped
                originalPosition: { // The position represented as { left, top } before the resizable is resized
                  left: this.originalRect.left - containmentRect.left,
                  top: this.originalRect.top - containmentRect.top
                },
                originalSize: { // The size represented as { width, height } before the resizable is resized
                  width: this.originalRect.width,
                  height: this.originalRect.height
                }
                */
            };
        };
        // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)
        this._mouseOver = this._mouseOver.bind(this);
        this._mouseOut = this._mouseOut.bind(this);
        this.enable();
        this._setupAutoHide(this.option.autoHide);
        this._setupHandlers();
    }
    on(event, callback) {
        super.on(event, callback);
    }
    off(event) {
        super.off(event);
    }
    enable() {
        super.enable();
        this.el.classList.remove('ui-resizable-disabled');
        this._setupAutoHide(this.option.autoHide);
    }
    disable() {
        super.disable();
        this.el.classList.add('ui-resizable-disabled');
        this._setupAutoHide(false);
    }
    destroy() {
        this._removeHandlers();
        this._setupAutoHide(false);
        delete this.el;
        super.destroy();
    }
    updateOption(opts) {
        let updateHandles = (opts.handles && opts.handles !== this.option.handles);
        let updateAutoHide = (opts.autoHide && opts.autoHide !== this.option.autoHide);
        Object.keys(opts).forEach(key => this.option[key] = opts[key]);
        if (updateHandles) {
            this._removeHandlers();
            this._setupHandlers();
        }
        if (updateAutoHide) {
            this._setupAutoHide(this.option.autoHide);
        }
        return this;
    }
    /** @internal turns auto hide on/off */
    _setupAutoHide(auto) {
        if (auto) {
            this.el.classList.add('ui-resizable-autohide');
            // use mouseover and not mouseenter to get better performance and track for nested cases
            this.el.addEventListener('mouseover', this._mouseOver);
            this.el.addEventListener('mouseout', this._mouseOut);
        }
        else {
            this.el.classList.remove('ui-resizable-autohide');
            this.el.removeEventListener('mouseover', this._mouseOver);
            this.el.removeEventListener('mouseout', this._mouseOut);
            if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement === this) {
                delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;
            }
        }
        return this;
    }
    /** @internal */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mouseOver(e) {
        // console.log(`${count++} pre-enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)
        // already over a child, ignore. Ideally we just call e.stopPropagation() but see https://github.com/gridstack/gridstack.js/issues/2018
        if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement || _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.dragElement)
            return;
        _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement = this;
        // console.log(`${count++} enter ${(this.el as GridItemHTMLElement).gridstackNode._id}`)
        this.el.classList.remove('ui-resizable-autohide');
    }
    /** @internal */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _mouseOut(e) {
        // console.log(`${count++} pre-leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)
        if (_dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement !== this)
            return;
        delete _dd_manager__WEBPACK_IMPORTED_MODULE_3__.DDManager.overResizeElement;
        // console.log(`${count++} leave ${(this.el as GridItemHTMLElement).gridstackNode._id}`)
        this.el.classList.add('ui-resizable-autohide');
    }
    /** @internal */
    _setupHandlers() {
        this.handlers = this.option.handles.split(',')
            .map(dir => dir.trim())
            .map(dir => new _dd_resizable_handle__WEBPACK_IMPORTED_MODULE_0__.DDResizableHandle(this.el, dir, {
            start: (event) => {
                this._resizeStart(event);
            },
            stop: (event) => {
                this._resizeStop(event);
            },
            move: (event) => {
                this._resizing(event, dir);
            }
        }));
        return this;
    }
    /** @internal */
    _resizeStart(event) {
        this.sizeToContent = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.shouldSizeToContent(this.el.gridstackNode, true); // strick true only and not number
        this.originalRect = this.el.getBoundingClientRect();
        this.scrollEl = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getScrollElement(this.el);
        this.scrollY = this.scrollEl.scrollTop;
        this.scrolled = 0;
        this.startEvent = event;
        this._setupHelper();
        this._applyChange();
        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, { type: 'resizestart', target: this.el });
        if (this.option.start) {
            this.option.start(ev, this._ui());
        }
        this.el.classList.add('ui-resizable-resizing');
        this.triggerEvent('resizestart', ev);
        return this;
    }
    /** @internal */
    _resizing(event, dir) {
        this.scrolled = this.scrollEl.scrollTop - this.scrollY;
        this.temporalRect = this._getChange(event, dir);
        this._applyChange();
        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, { type: 'resize', target: this.el });
        if (this.option.resize) {
            this.option.resize(ev, this._ui());
        }
        this.triggerEvent('resize', ev);
        return this;
    }
    /** @internal */
    _resizeStop(event) {
        const ev = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.initEvent(event, { type: 'resizestop', target: this.el });
        if (this.option.stop) {
            this.option.stop(ev); // Note: ui() not used by gridstack so don't pass
        }
        this.el.classList.remove('ui-resizable-resizing');
        this.triggerEvent('resizestop', ev);
        this._cleanHelper();
        delete this.startEvent;
        delete this.originalRect;
        delete this.temporalRect;
        delete this.scrollY;
        delete this.scrolled;
        return this;
    }
    /** @internal */
    _setupHelper() {
        this.elOriginStyleVal = DDResizable._originStyleProp.map(prop => this.el.style[prop]);
        this.parentOriginStylePosition = this.el.parentElement.style.position;
        const parent = this.el.parentElement;
        const dragTransform = _utils__WEBPACK_IMPORTED_MODULE_2__.Utils.getValuesFromTransformedElement(parent);
        this.rectScale = {
            x: dragTransform.xScale,
            y: dragTransform.yScale
        };
        if (getComputedStyle(this.el.parentElement).position.match(/static/)) {
            this.el.parentElement.style.position = 'relative';
        }
        this.el.style.position = 'absolute';
        this.el.style.opacity = '0.8';
        return this;
    }
    /** @internal */
    _cleanHelper() {
        DDResizable._originStyleProp.forEach((prop, i) => {
            this.el.style[prop] = this.elOriginStyleVal[i] || null;
        });
        this.el.parentElement.style.position = this.parentOriginStylePosition || null;
        return this;
    }
    /** @internal */
    _getChange(event, dir) {
        const oEvent = this.startEvent;
        const newRect = {
            width: this.originalRect.width,
            height: this.originalRect.height + this.scrolled,
            left: this.originalRect.left,
            top: this.originalRect.top - this.scrolled
        };
        const offsetX = event.clientX - oEvent.clientX;
        const offsetY = this.sizeToContent ? 0 : event.clientY - oEvent.clientY; // prevent vert resize
        let moveLeft;
        let moveUp;
        if (dir.indexOf('e') > -1) {
            newRect.width += offsetX;
        }
        else if (dir.indexOf('w') > -1) {
            newRect.width -= offsetX;
            newRect.left += offsetX;
            moveLeft = true;
        }
        if (dir.indexOf('s') > -1) {
            newRect.height += offsetY;
        }
        else if (dir.indexOf('n') > -1) {
            newRect.height -= offsetY;
            newRect.top += offsetY;
            moveUp = true;
        }
        const constrain = this._constrainSize(newRect.width, newRect.height, moveLeft, moveUp);
        if (Math.round(newRect.width) !== Math.round(constrain.width)) { // round to ignore slight round-off errors
            if (dir.indexOf('w') > -1) {
                newRect.left += newRect.width - constrain.width;
            }
            newRect.width = constrain.width;
        }
        if (Math.round(newRect.height) !== Math.round(constrain.height)) {
            if (dir.indexOf('n') > -1) {
                newRect.top += newRect.height - constrain.height;
            }
            newRect.height = constrain.height;
        }
        return newRect;
    }
    /** @internal constrain the size to the set min/max values */
    _constrainSize(oWidth, oHeight, moveLeft, moveUp) {
        const o = this.option;
        const maxWidth = (moveLeft ? o.maxWidthMoveLeft : o.maxWidth) || Number.MAX_SAFE_INTEGER;
        const minWidth = o.minWidth / this.rectScale.x || oWidth;
        const maxHeight = (moveUp ? o.maxHeightMoveUp : o.maxHeight) || Number.MAX_SAFE_INTEGER;
        const minHeight = o.minHeight / this.rectScale.y || oHeight;
        const width = Math.min(maxWidth, Math.max(minWidth, oWidth));
        const height = Math.min(maxHeight, Math.max(minHeight, oHeight));
        return { width, height };
    }
    /** @internal */
    _applyChange() {
        let containmentRect = { left: 0, top: 0, width: 0, height: 0 };
        if (this.el.style.position === 'absolute') {
            const containmentEl = this.el.parentElement;
            const { left, top } = containmentEl.getBoundingClientRect();
            containmentRect = { left, top, width: 0, height: 0 };
        }
        if (!this.temporalRect)
            return this;
        Object.keys(this.temporalRect).forEach(key => {
            const value = this.temporalRect[key];
            const scaleReciprocal = key === 'width' || key === 'left' ? this.rectScale.x : key === 'height' || key === 'top' ? this.rectScale.y : 1;
            this.el.style[key] = (value - containmentRect[key]) * scaleReciprocal + 'px';
        });
        return this;
    }
    /** @internal */
    _removeHandlers() {
        this.handlers.forEach(handle => handle.destroy());
        delete this.handlers;
        return this;
    }
}
/** @internal */
DDResizable._originStyleProp = ['width', 'height', 'position', 'left', 'top', 'opacity', 'zIndex'];

//# sourceMappingURL=dd-resizable.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/dd-touch.js":
/*!*************************************************!*\
  !*** ./node_modules/gridstack/dist/dd-touch.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isTouch: () => (/* binding */ isTouch),
/* harmony export */   pointerdown: () => (/* binding */ pointerdown),
/* harmony export */   pointerenter: () => (/* binding */ pointerenter),
/* harmony export */   pointerleave: () => (/* binding */ pointerleave),
/* harmony export */   touchend: () => (/* binding */ touchend),
/* harmony export */   touchmove: () => (/* binding */ touchmove),
/* harmony export */   touchstart: () => (/* binding */ touchstart)
/* harmony export */ });
/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dd-manager */ "./node_modules/gridstack/dist/dd-manager.js");
/**
 * touch.ts 10.3.1
 * Copyright (c) 2021 Alain Dumesny - see GridStack root license
 */

/**
 * Detect touch support - Windows Surface devices and other touch devices
 * should we use this instead ? (what we had for always showing resize handles)
 * /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
 */
const isTouch = typeof window !== 'undefined' && typeof document !== 'undefined' &&
    ('ontouchstart' in document
        || 'ontouchstart' in window
        // || !!window.TouchEvent // true on Windows 10 Chrome desktop so don't use this
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        || (window.DocumentTouch && document instanceof window.DocumentTouch)
        || navigator.maxTouchPoints > 0
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        || navigator.msMaxTouchPoints > 0);
// interface TouchCoord {x: number, y: number};
class DDTouch {
}
/**
* Get the x,y position of a touch event
*/
// function getTouchCoords(e: TouchEvent): TouchCoord {
//   return {
//     x: e.changedTouches[0].pageX,
//     y: e.changedTouches[0].pageY
//   };
// }
/**
 * Simulate a mouse event based on a corresponding touch event
 * @param {Object} e A touch event
 * @param {String} simulatedType The corresponding mouse event
 */
function simulateMouseEvent(e, simulatedType) {
    // Ignore multi-touch events
    if (e.touches.length > 1)
        return;
    // Prevent "Ignored attempt to cancel a touchmove event with cancelable=false" errors
    if (e.cancelable)
        e.preventDefault();
    const touch = e.changedTouches[0], simulatedEvent = document.createEvent('MouseEvents');
    // Initialize the simulated mouse event using the touch event's coordinates
    simulatedEvent.initMouseEvent(simulatedType, // type
    true, // bubbles
    true, // cancelable
    window, // view
    1, // detail
    touch.screenX, // screenX
    touch.screenY, // screenY
    touch.clientX, // clientX
    touch.clientY, // clientY
    false, // ctrlKey
    false, // altKey
    false, // shiftKey
    false, // metaKey
    0, // button
    null // relatedTarget
    );
    // Dispatch the simulated event to the target element
    e.target.dispatchEvent(simulatedEvent);
}
/**
 * Simulate a mouse event based on a corresponding Pointer event
 * @param {Object} e A pointer event
 * @param {String} simulatedType The corresponding mouse event
 */
function simulatePointerMouseEvent(e, simulatedType) {
    // Prevent "Ignored attempt to cancel a touchmove event with cancelable=false" errors
    if (e.cancelable)
        e.preventDefault();
    const simulatedEvent = document.createEvent('MouseEvents');
    // Initialize the simulated mouse event using the touch event's coordinates
    simulatedEvent.initMouseEvent(simulatedType, // type
    true, // bubbles
    true, // cancelable
    window, // view
    1, // detail
    e.screenX, // screenX
    e.screenY, // screenY
    e.clientX, // clientX
    e.clientY, // clientY
    false, // ctrlKey
    false, // altKey
    false, // shiftKey
    false, // metaKey
    0, // button
    null // relatedTarget
    );
    // Dispatch the simulated event to the target element
    e.target.dispatchEvent(simulatedEvent);
}
/**
 * Handle the touchstart events
 * @param {Object} e The widget element's touchstart event
 */
function touchstart(e) {
    // Ignore the event if another widget is already being handled
    if (DDTouch.touchHandled)
        return;
    DDTouch.touchHandled = true;
    // Simulate the mouse events
    // simulateMouseEvent(e, 'mouseover');
    // simulateMouseEvent(e, 'mousemove');
    simulateMouseEvent(e, 'mousedown');
}
/**
 * Handle the touchmove events
 * @param {Object} e The document's touchmove event
 */
function touchmove(e) {
    // Ignore event if not handled by us
    if (!DDTouch.touchHandled)
        return;
    simulateMouseEvent(e, 'mousemove');
}
/**
 * Handle the touchend events
 * @param {Object} e The document's touchend event
 */
function touchend(e) {
    // Ignore event if not handled
    if (!DDTouch.touchHandled)
        return;
    // cancel delayed leave event when we release on ourself which happens BEFORE we get this!
    if (DDTouch.pointerLeaveTimeout) {
        window.clearTimeout(DDTouch.pointerLeaveTimeout);
        delete DDTouch.pointerLeaveTimeout;
    }
    const wasDragging = !!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement;
    // Simulate the mouseup event
    simulateMouseEvent(e, 'mouseup');
    // simulateMouseEvent(event, 'mouseout');
    // If the touch interaction did not move, it should trigger a click
    if (!wasDragging) {
        simulateMouseEvent(e, 'click');
    }
    // Unset the flag to allow other widgets to inherit the touch event
    DDTouch.touchHandled = false;
}
/**
 * Note we don't get touchenter/touchleave (which are deprecated)
 * see https://stackoverflow.com/questions/27908339/js-touch-equivalent-for-mouseenter
 * so instead of PointerEvent to still get enter/leave and send the matching mouse event.
 */
function pointerdown(e) {
    // console.log("pointer down")
    if (e.pointerType === 'mouse')
        return;
    e.target.releasePointerCapture(e.pointerId); // <- Important!
}
function pointerenter(e) {
    // ignore the initial one we get on pointerdown on ourself
    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {
        // console.log('pointerenter ignored');
        return;
    }
    // console.log('pointerenter');
    if (e.pointerType === 'mouse')
        return;
    simulatePointerMouseEvent(e, 'mouseenter');
}
function pointerleave(e) {
    // ignore the leave on ourself we get before releasing the mouse over ourself
    // by delaying sending the event and having the up event cancel us
    if (!_dd_manager__WEBPACK_IMPORTED_MODULE_0__.DDManager.dragElement) {
        // console.log('pointerleave ignored');
        return;
    }
    if (e.pointerType === 'mouse')
        return;
    DDTouch.pointerLeaveTimeout = window.setTimeout(() => {
        delete DDTouch.pointerLeaveTimeout;
        // console.log('pointerleave delayed');
        simulatePointerMouseEvent(e, 'mouseleave');
    }, 10);
}
//# sourceMappingURL=dd-touch.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack-engine.js":
/*!*********************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack-engine.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridStackEngine: () => (/* binding */ GridStackEngine)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/gridstack/dist/utils.js");
/**
 * gridstack-engine.ts 10.3.1
 * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license
 */

/**
 * Defines the GridStack engine that does most no DOM grid manipulation.
 * See GridStack methods and vars for descriptions.
 *
 * NOTE: values should not be modified directly - call the main GridStack API instead
 */
class GridStackEngine {
    constructor(opts = {}) {
        this.addedNodes = [];
        this.removedNodes = [];
        this.column = opts.column || 12;
        this.maxRow = opts.maxRow;
        this._float = opts.float;
        this.nodes = opts.nodes || [];
        this.onChange = opts.onChange;
    }
    batchUpdate(flag = true, doPack = true) {
        if (!!this.batchMode === flag)
            return this;
        this.batchMode = flag;
        if (flag) {
            this._prevFloat = this._float;
            this._float = true; // let things go anywhere for now... will restore and possibly reposition later
            this.cleanNodes();
            this.saveInitial(); // since begin update (which is called multiple times) won't do this
        }
        else {
            this._float = this._prevFloat;
            delete this._prevFloat;
            if (doPack)
                this._packNodes();
            this._notify();
        }
        return this;
    }
    // use entire row for hitting area (will use bottom reverse sorted first) if we not actively moving DOWN and didn't already skip
    _useEntireRowArea(node, nn) {
        return (!this.float || this.batchMode && !this._prevFloat) && !this._hasLocked && (!node._moving || node._skipDown || nn.y <= node.y);
    }
    /** @internal fix collision on given 'node', going to given new location 'nn', with optional 'collide' node already found.
     * return true if we moved. */
    _fixCollisions(node, nn = node, collide, opt = {}) {
        this.sortNodes(-1); // from last to first, so recursive collision move items in the right order
        collide = collide || this.collide(node, nn); // REAL area collide for swap and skip if none...
        if (!collide)
            return false;
        // swap check: if we're actively moving in gravity mode, see if we collide with an object the same size
        if (node._moving && !opt.nested && !this.float) {
            if (this.swap(node, collide))
                return true;
        }
        // during while() collisions MAKE SURE to check entire row so larger items don't leap frog small ones (push them all down starting last in grid)
        let area = nn;
        if (!this._loading && this._useEntireRowArea(node, nn)) {
            area = { x: 0, w: this.column, y: nn.y, h: nn.h };
            collide = this.collide(node, area, opt.skip); // force new hit
        }
        let didMove = false;
        let newOpt = { nested: true, pack: false };
        while (collide = collide || this.collide(node, area, opt.skip)) { // could collide with more than 1 item... so repeat for each
            let moved;
            // if colliding with a locked item OR loading (move after) OR moving down with top gravity (and collide could move up) -> skip past the collide,
            // but remember that skip down so we only do this once (and push others otherwise).
            if (collide.locked || this._loading || node._moving && !node._skipDown && nn.y > node.y && !this.float &&
                // can take space we had, or before where we're going
                (!this.collide(collide, { ...collide, y: node.y }, node) || !this.collide(collide, { ...collide, y: nn.y - collide.h }, node))) {
                node._skipDown = (node._skipDown || nn.y > node.y);
                moved = this.moveNode(node, { ...nn, y: collide.y + collide.h, ...newOpt });
                if ((collide.locked || this._loading) && moved) {
                    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, node); // moving after lock become our new desired location
                }
                else if (!collide.locked && moved && opt.pack) {
                    // we moved after and will pack: do it now and keep the original drop location, but past the old collide to see what else we might push way
                    this._packNodes();
                    nn.y = collide.y + collide.h;
                    _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);
                }
                didMove = didMove || moved;
            }
            else {
                // move collide down *after* where we will be, ignoring where we are now (don't collide with us)
                moved = this.moveNode(collide, { ...collide, y: nn.y + nn.h, skip: node, ...newOpt });
            }
            if (!moved) {
                return didMove;
            } // break inf loop if we couldn't move after all (ex: maxRow, fixed)
            collide = undefined;
        }
        return didMove;
    }
    /** return the nodes that intercept the given node. Optionally a different area can be used, as well as a second node to skip */
    collide(skip, area = skip, skip2) {
        const skipId = skip._id;
        const skip2Id = skip2?._id;
        return this.nodes.find(n => n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));
    }
    collideAll(skip, area = skip, skip2) {
        const skipId = skip._id;
        const skip2Id = skip2?._id;
        return this.nodes.filter(n => n._id !== skipId && n._id !== skip2Id && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(n, area));
    }
    /** does a pixel coverage collision based on where we started, returning the node that has the most coverage that is >50% mid line */
    directionCollideCoverage(node, o, collides) {
        if (!o.rect || !node._rect)
            return;
        let r0 = node._rect; // where started
        let r = { ...o.rect }; // where we are
        // update dragged rect to show where it's coming from (above or below, etc...)
        if (r.y > r0.y) {
            r.h += r.y - r0.y;
            r.y = r0.y;
        }
        else {
            r.h += r0.y - r.y;
        }
        if (r.x > r0.x) {
            r.w += r.x - r0.x;
            r.x = r0.x;
        }
        else {
            r.w += r0.x - r.x;
        }
        let collide;
        let overMax = 0.5; // need >50%
        for (let n of collides) {
            if (n.locked || !n._rect) {
                break;
            }
            let r2 = n._rect; // overlapping target
            let yOver = Number.MAX_VALUE, xOver = Number.MAX_VALUE;
            // depending on which side we started from, compute the overlap % of coverage
            // (ex: from above/below we only compute the max horizontal line coverage)
            if (r0.y < r2.y) { // from above
                yOver = ((r.y + r.h) - r2.y) / r2.h;
            }
            else if (r0.y + r0.h > r2.y + r2.h) { // from below
                yOver = ((r2.y + r2.h) - r.y) / r2.h;
            }
            if (r0.x < r2.x) { // from the left
                xOver = ((r.x + r.w) - r2.x) / r2.w;
            }
            else if (r0.x + r0.w > r2.x + r2.w) { // from the right
                xOver = ((r2.x + r2.w) - r.x) / r2.w;
            }
            let over = Math.min(xOver, yOver);
            if (over > overMax) {
                overMax = over;
                collide = n;
            }
        }
        o.collide = collide; // save it so we don't have to find it again
        return collide;
    }
    /** does a pixel coverage returning the node that has the most coverage by area */
    /*
    protected collideCoverage(r: GridStackPosition, collides: GridStackNode[]): {collide: GridStackNode, over: number} {
      let collide: GridStackNode;
      let overMax = 0;
      collides.forEach(n => {
        if (n.locked || !n._rect) return;
        let over = Utils.areaIntercept(r, n._rect);
        if (over > overMax) {
          overMax = over;
          collide = n;
        }
      });
      return {collide, over: overMax};
    }
    */
    /** called to cache the nodes pixel rectangles used for collision detection during drag */
    cacheRects(w, h, top, right, bottom, left) {
        this.nodes.forEach(n => n._rect = {
            y: n.y * h + top,
            x: n.x * w + left,
            w: n.w * w - left - right,
            h: n.h * h - top - bottom
        });
        return this;
    }
    /** called to possibly swap between 2 nodes (same size or column, not locked, touching), returning true if successful */
    swap(a, b) {
        if (!b || b.locked || !a || a.locked)
            return false;
        function _doSwap() {
            let x = b.x, y = b.y;
            b.x = a.x;
            b.y = a.y; // b -> a position
            if (a.h != b.h) {
                a.x = x;
                a.y = b.y + b.h; // a -> goes after b
            }
            else if (a.w != b.w) {
                a.x = b.x + b.w;
                a.y = y; // a -> goes after b
            }
            else {
                a.x = x;
                a.y = y; // a -> old b position
            }
            a._dirty = b._dirty = true;
            return true;
        }
        let touching; // remember if we called it (vs undefined)
        // same size and same row or column, and touching
        if (a.w === b.w && a.h === b.h && (a.x === b.x || a.y === b.y) && (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))
            return _doSwap();
        if (touching === false)
            return; // IFF ran test and fail, bail out
        // check for taking same columns (but different height) and touching
        if (a.w === b.w && a.x === b.x && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {
            if (b.y < a.y) {
                let t = a;
                a = b;
                b = t;
            } // swap a <-> b vars so a is first
            return _doSwap();
        }
        if (touching === false)
            return;
        // check if taking same row (but different width) and touching
        if (a.h === b.h && a.y === b.y && (touching || (touching = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isTouching(a, b)))) {
            if (b.x < a.x) {
                let t = a;
                a = b;
                b = t;
            } // swap a <-> b vars so a is first
            return _doSwap();
        }
        return false;
    }
    isAreaEmpty(x, y, w, h) {
        let nn = { x: x || 0, y: y || 0, w: w || 1, h: h || 1 };
        return !this.collide(nn);
    }
    /** re-layout grid items to reclaim any empty space - optionally keeping the sort order exactly the same ('list' mode) vs truly finding an empty spaces */
    compact(layout = 'compact', doSort = true) {
        if (this.nodes.length === 0)
            return this;
        if (doSort)
            this.sortNodes();
        const wasBatch = this.batchMode;
        if (!wasBatch)
            this.batchUpdate();
        const wasColumnResize = this._inColumnResize;
        if (!wasColumnResize)
            this._inColumnResize = true; // faster addNode()
        let copyNodes = this.nodes;
        this.nodes = []; // pretend we have no nodes to conflict layout to start with...
        copyNodes.forEach((n, index, list) => {
            let after;
            if (!n.locked) {
                n.autoPosition = true;
                if (layout === 'list' && index)
                    after = list[index - 1];
            }
            this.addNode(n, false, after); // 'false' for add event trigger
        });
        if (!wasColumnResize)
            delete this._inColumnResize;
        if (!wasBatch)
            this.batchUpdate(false);
        return this;
    }
    /** enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html) */
    set float(val) {
        if (this._float === val)
            return;
        this._float = val || false;
        if (!val) {
            this._packNodes()._notify();
        }
    }
    /** float getter method */
    get float() { return this._float || false; }
    /** sort the nodes array from first to last, or reverse. Called during collision/placement to force an order */
    sortNodes(dir = 1) {
        this.nodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, dir);
        return this;
    }
    /** @internal called to top gravity pack the items back OR revert back to original Y positions when floating */
    _packNodes() {
        if (this.batchMode) {
            return this;
        }
        this.sortNodes(); // first to last
        if (this.float) {
            // restore original Y pos
            this.nodes.forEach(n => {
                if (n._updating || n._orig === undefined || n.y === n._orig.y)
                    return;
                let newY = n.y;
                while (newY > n._orig.y) {
                    --newY;
                    let collide = this.collide(n, { x: n.x, y: newY, w: n.w, h: n.h });
                    if (!collide) {
                        n._dirty = true;
                        n.y = newY;
                    }
                }
            });
        }
        else {
            // top gravity pack
            this.nodes.forEach((n, i) => {
                if (n.locked)
                    return;
                while (n.y > 0) {
                    let newY = i === 0 ? 0 : n.y - 1;
                    let canBeMoved = i === 0 || !this.collide(n, { x: n.x, y: newY, w: n.w, h: n.h });
                    if (!canBeMoved)
                        break;
                    // Note: must be dirty (from last position) for GridStack::OnChange CB to update positions
                    // and move items back. The user 'change' CB should detect changes from the original
                    // starting position instead.
                    n._dirty = (n.y !== newY);
                    n.y = newY;
                }
            });
        }
        return this;
    }
    /**
     * given a random node, makes sure it's coordinates/values are valid in the current grid
     * @param node to adjust
     * @param resizing if out of bound, resize down or move into the grid to fit ?
     */
    prepareNode(node, resizing) {
        node._id = node._id ?? GridStackEngine._idSeq++;
        // if we're missing position, have the grid position us automatically (before we set them to 0,0)
        if (node.x === undefined || node.y === undefined || node.x === null || node.y === null) {
            node.autoPosition = true;
        }
        // assign defaults for missing required fields
        let defaults = { x: 0, y: 0, w: 1, h: 1 };
        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.defaults(node, defaults);
        if (!node.autoPosition) {
            delete node.autoPosition;
        }
        if (!node.noResize) {
            delete node.noResize;
        }
        if (!node.noMove) {
            delete node.noMove;
        }
        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sanitizeMinMax(node);
        // check for NaN (in case messed up strings were passed. can't do parseInt() || defaults.x above as 0 is valid #)
        if (typeof node.x == 'string') {
            node.x = Number(node.x);
        }
        if (typeof node.y == 'string') {
            node.y = Number(node.y);
        }
        if (typeof node.w == 'string') {
            node.w = Number(node.w);
        }
        if (typeof node.h == 'string') {
            node.h = Number(node.h);
        }
        if (isNaN(node.x)) {
            node.x = defaults.x;
            node.autoPosition = true;
        }
        if (isNaN(node.y)) {
            node.y = defaults.y;
            node.autoPosition = true;
        }
        if (isNaN(node.w)) {
            node.w = defaults.w;
        }
        if (isNaN(node.h)) {
            node.h = defaults.h;
        }
        this.nodeBoundFix(node, resizing);
        return node;
    }
    /** part2 of preparing a node to fit inside our grid - checks for x,y,w from grid dimensions */
    nodeBoundFix(node, resizing) {
        let before = node._orig || _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);
        if (node.maxW) {
            node.w = Math.min(node.w, node.maxW);
        }
        if (node.maxH) {
            node.h = Math.min(node.h, node.maxH);
        }
        if (node.minW && node.minW <= this.column) {
            node.w = Math.max(node.w, node.minW);
        }
        if (node.minH) {
            node.h = Math.max(node.h, node.minH);
        }
        // if user loaded a larger than allowed widget for current # of columns,
        // remember it's position & width so we can restore back (1 -> 12 column) #1655 #1985
        // IFF we're not in the middle of column resizing!
        const saveOrig = (node.x || 0) + (node.w || 1) > this.column;
        if (saveOrig && this.column < 12 && !this._inColumnResize && node._id && this.findCacheLayout(node, 12) === -1) {
            let copy = { ...node }; // need _id + positions
            if (copy.autoPosition || copy.x === undefined) {
                delete copy.x;
                delete copy.y;
            }
            else
                copy.x = Math.min(11, copy.x);
            copy.w = Math.min(12, copy.w || 1);
            this.cacheOneLayout(copy, 12);
        }
        if (node.w > this.column) {
            node.w = this.column;
        }
        else if (node.w < 1) {
            node.w = 1;
        }
        if (this.maxRow && node.h > this.maxRow) {
            node.h = this.maxRow;
        }
        else if (node.h < 1) {
            node.h = 1;
        }
        if (node.x < 0) {
            node.x = 0;
        }
        if (node.y < 0) {
            node.y = 0;
        }
        if (node.x + node.w > this.column) {
            if (resizing) {
                node.w = this.column - node.x;
            }
            else {
                node.x = this.column - node.w;
            }
        }
        if (this.maxRow && node.y + node.h > this.maxRow) {
            if (resizing) {
                node.h = this.maxRow - node.y;
            }
            else {
                node.y = this.maxRow - node.h;
            }
        }
        if (!_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, before)) {
            node._dirty = true;
        }
        return this;
    }
    /** returns a list of modified nodes from their original values */
    getDirtyNodes(verify) {
        // compare original x,y,w,h instead as _dirty can be a temporary state
        if (verify) {
            return this.nodes.filter(n => n._dirty && !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig));
        }
        return this.nodes.filter(n => n._dirty);
    }
    /** @internal call this to call onChange callback with dirty nodes so DOM can be updated */
    _notify(removedNodes) {
        if (this.batchMode || !this.onChange)
            return this;
        let dirtyNodes = (removedNodes || []).concat(this.getDirtyNodes());
        this.onChange(dirtyNodes);
        return this;
    }
    /** @internal remove dirty and last tried info */
    cleanNodes() {
        if (this.batchMode)
            return this;
        this.nodes.forEach(n => {
            delete n._dirty;
            delete n._lastTried;
        });
        return this;
    }
    /** @internal called to save initial position/size to track real dirty state.
     * Note: should be called right after we call change event (so next API is can detect changes)
     * as well as right before we start move/resize/enter (so we can restore items to prev values) */
    saveInitial() {
        this.nodes.forEach(n => {
            n._orig = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);
            delete n._dirty;
        });
        this._hasLocked = this.nodes.some(n => n.locked);
        return this;
    }
    /** @internal restore all the nodes back to initial values (called when we leave) */
    restoreInitial() {
        this.nodes.forEach(n => {
            if (_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(n, n._orig))
                return;
            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, n._orig);
            n._dirty = true;
        });
        this._notify();
        return this;
    }
    /** find the first available empty spot for the given node width/height, updating the x,y attributes. return true if found.
     * optionally you can pass your own existing node list and column count, otherwise defaults to that engine data.
     * Optionally pass a widget to start search AFTER, meaning the order will remain the same but possibly have empty slots we skipped
     */
    findEmptyPosition(node, nodeList = this.nodes, column = this.column, after) {
        let start = after ? after.y * column + (after.x + after.w) : 0;
        let found = false;
        for (let i = start; !found; ++i) {
            let x = i % column;
            let y = Math.floor(i / column);
            if (x + node.w > column) {
                continue;
            }
            let box = { x, y, w: node.w, h: node.h };
            if (!nodeList.find(n => _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.isIntercepted(box, n))) {
                if (node.x !== x || node.y !== y)
                    node._dirty = true;
                node.x = x;
                node.y = y;
                delete node.autoPosition;
                found = true;
            }
        }
        return found;
    }
    /** call to add the given node to our list, fixing collision and re-packing */
    addNode(node, triggerAddEvent = false, after) {
        let dup = this.nodes.find(n => n._id === node._id);
        if (dup)
            return dup; // prevent inserting twice! return it instead.
        // skip prepareNode if we're in middle of column resize (not new) but do check for bounds!
        this._inColumnResize ? this.nodeBoundFix(node) : this.prepareNode(node);
        delete node._temporaryRemoved;
        delete node._removeDOM;
        let skipCollision;
        if (node.autoPosition && this.findEmptyPosition(node, this.nodes, this.column, after)) {
            delete node.autoPosition; // found our slot
            skipCollision = true;
        }
        this.nodes.push(node);
        if (triggerAddEvent) {
            this.addedNodes.push(node);
        }
        if (!skipCollision)
            this._fixCollisions(node);
        if (!this.batchMode) {
            this._packNodes()._notify();
        }
        return node;
    }
    removeNode(node, removeDOM = true, triggerEvent = false) {
        if (!this.nodes.find(n => n._id === node._id)) {
            // TEST console.log(`Error: GridStackEngine.removeNode() node._id=${node._id} not found!`)
            return this;
        }
        if (triggerEvent) { // we wait until final drop to manually track removed items (rather than during drag)
            this.removedNodes.push(node);
        }
        if (removeDOM)
            node._removeDOM = true; // let CB remove actual HTML (used to set _id to null, but then we loose layout info)
        // don't use 'faster' .splice(findIndex(),1) in case node isn't in our list, or in multiple times.
        this.nodes = this.nodes.filter(n => n._id !== node._id);
        if (!node._isAboutToRemove)
            this._packNodes(); // if dragged out, no need to relayout as already done...
        this._notify([node]);
        return this;
    }
    removeAll(removeDOM = true, triggerEvent = true) {
        delete this._layouts;
        if (!this.nodes.length)
            return this;
        removeDOM && this.nodes.forEach(n => n._removeDOM = true); // let CB remove actual HTML (used to set _id to null, but then we loose layout info)
        const removedNodes = this.nodes;
        this.removedNodes = triggerEvent ? removedNodes : [];
        this.nodes = [];
        return this._notify(removedNodes);
    }
    /** checks if item can be moved (layout constrain) vs moveNode(), returning true if was able to move.
     * In more complicated cases (maxRow) it will attempt at moving the item and fixing
     * others in a clone first, then apply those changes if still within specs. */
    moveNodeCheck(node, o) {
        // if (node.locked) return false;
        if (!this.changedPosConstrain(node, o))
            return false;
        o.pack = true;
        // simpler case: move item directly...
        if (!this.maxRow) {
            return this.moveNode(node, o);
        }
        // complex case: create a clone with NO maxRow (will check for out of bounds at the end)
        let clonedNode;
        let clone = new GridStackEngine({
            column: this.column,
            float: this.float,
            nodes: this.nodes.map(n => {
                if (n._id === node._id) {
                    clonedNode = { ...n };
                    return clonedNode;
                }
                return { ...n };
            })
        });
        if (!clonedNode)
            return false;
        // check if we're covering 50% collision and could move, while still being under maxRow or at least not making it worse
        // (case where widget was somehow added past our max #2449)
        let canMove = clone.moveNode(clonedNode, o) && clone.getRow() <= Math.max(this.getRow(), this.maxRow);
        // else check if we can force a swap (float=true, or different shapes) on non-resize
        if (!canMove && !o.resizing && o.collide) {
            let collide = o.collide.el.gridstackNode; // find the source node the clone collided with at 50%
            if (this.swap(node, collide)) { // swaps and mark dirty
                this._notify();
                return true;
            }
        }
        if (!canMove)
            return false;
        // if clone was able to move, copy those mods over to us now instead of caller trying to do this all over!
        // Note: we can't use the list directly as elements and other parts point to actual node, so copy content
        clone.nodes.filter(n => n._dirty).forEach(c => {
            let n = this.nodes.find(a => a._id === c._id);
            if (!n)
                return;
            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(n, c);
            n._dirty = true;
        });
        this._notify();
        return true;
    }
    /** return true if can fit in grid height constrain only (always true if no maxRow) */
    willItFit(node) {
        delete node._willFitPos;
        if (!this.maxRow)
            return true;
        // create a clone with NO maxRow and check if still within size
        let clone = new GridStackEngine({
            column: this.column,
            float: this.float,
            nodes: this.nodes.map(n => { return { ...n }; })
        });
        let n = { ...node }; // clone node so we don't mod any settings on it but have full autoPosition and min/max as well! #1687
        this.cleanupNode(n);
        delete n.el;
        delete n._id;
        delete n.content;
        delete n.grid;
        clone.addNode(n);
        if (clone.getRow() <= this.maxRow) {
            node._willFitPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, n);
            return true;
        }
        return false;
    }
    /** true if x,y or w,h are different after clamping to min/max */
    changedPosConstrain(node, p) {
        // first make sure w,h are set for caller
        p.w = p.w || node.w;
        p.h = p.h || node.h;
        if (node.x !== p.x || node.y !== p.y)
            return true;
        // check constrained w,h
        if (node.maxW) {
            p.w = Math.min(p.w, node.maxW);
        }
        if (node.maxH) {
            p.h = Math.min(p.h, node.maxH);
        }
        if (node.minW) {
            p.w = Math.max(p.w, node.minW);
        }
        if (node.minH) {
            p.h = Math.max(p.h, node.minH);
        }
        return (node.w !== p.w || node.h !== p.h);
    }
    /** return true if the passed in node was actually moved (checks for no-op and locked) */
    moveNode(node, o) {
        if (!node || /*node.locked ||*/ !o)
            return false;
        let wasUndefinedPack;
        if (o.pack === undefined && !this.batchMode) {
            wasUndefinedPack = o.pack = true;
        }
        // constrain the passed in values and check if we're still changing our node
        if (typeof o.x !== 'number') {
            o.x = node.x;
        }
        if (typeof o.y !== 'number') {
            o.y = node.y;
        }
        if (typeof o.w !== 'number') {
            o.w = node.w;
        }
        if (typeof o.h !== 'number') {
            o.h = node.h;
        }
        let resizing = (node.w !== o.w || node.h !== o.h);
        let nn = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node, true); // get min/max out first, then opt positions next
        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(nn, o);
        this.nodeBoundFix(nn, resizing);
        _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(o, nn);
        if (!o.forceCollide && _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, o))
            return false;
        let prevPos = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos({}, node);
        // check if we will need to fix collision at our new location
        let collides = this.collideAll(node, nn, o.skip);
        let needToMove = true;
        if (collides.length) {
            let activeDrag = node._moving && !o.nested;
            // check to make sure we actually collided over 50% surface area while dragging
            let collide = activeDrag ? this.directionCollideCoverage(node, o, collides) : collides[0];
            // if we're enabling creation of sub-grids on the fly, see if we're covering 80% of either one, if we didn't already do that
            if (activeDrag && collide && node.grid?.opts?.subGridDynamic && !node.grid._isTemp) {
                let over = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.areaIntercept(o.rect, collide._rect);
                let a1 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(o.rect);
                let a2 = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.area(collide._rect);
                let perc = over / (a1 < a2 ? a1 : a2);
                if (perc > .8) {
                    collide.grid.makeSubGrid(collide.el, undefined, node);
                    collide = undefined;
                }
            }
            if (collide) {
                needToMove = !this._fixCollisions(node, nn, collide, o); // check if already moved...
            }
            else {
                needToMove = false; // we didn't cover >50% for a move, skip...
                if (wasUndefinedPack)
                    delete o.pack;
            }
        }
        // now move (to the original ask vs the collision version which might differ) and repack things
        if (needToMove) {
            node._dirty = true;
            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.copyPos(node, nn);
        }
        if (o.pack) {
            this._packNodes()
                ._notify();
        }
        return !_utils__WEBPACK_IMPORTED_MODULE_0__.Utils.samePos(node, prevPos); // pack might have moved things back
    }
    getRow() {
        return this.nodes.reduce((row, n) => Math.max(row, n.y + n.h), 0);
    }
    beginUpdate(node) {
        if (!node._updating) {
            node._updating = true;
            delete node._skipDown;
            if (!this.batchMode)
                this.saveInitial();
        }
        return this;
    }
    endUpdate() {
        let n = this.nodes.find(n => n._updating);
        if (n) {
            delete n._updating;
            delete n._skipDown;
        }
        return this;
    }
    /** saves a copy of the largest column layout (eg 12 even when rendering oneColumnMode) so we don't loose orig layout,
     * returning a list of widgets for serialization */
    save(saveElement = true, saveCB) {
        // use the highest layout for any saved info so we can have full detail on reload #1849
        let len = this._layouts?.length;
        let layout = len && this.column !== (len - 1) ? this._layouts[len - 1] : null;
        let list = [];
        this.sortNodes();
        this.nodes.forEach(n => {
            let wl = layout?.find(l => l._id === n._id);
            // use layout info fields instead if set
            let w = { ...n, ...(wl || {}) };
            _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.removeInternalForSave(w, !saveElement);
            if (saveCB)
                saveCB(n, w);
            list.push(w);
        });
        return list;
    }
    /** @internal called whenever a node is added or moved - updates the cached layouts */
    layoutsNodesChange(nodes) {
        if (!this._layouts || this._inColumnResize)
            return this;
        // remove smaller layouts - we will re-generate those on the fly... larger ones need to update
        this._layouts.forEach((layout, column) => {
            if (!layout || column === this.column)
                return this;
            if (column < this.column) {
                this._layouts[column] = undefined;
            }
            else {
                // we save the original x,y,w (h isn't cached) to see what actually changed to propagate better.
                // NOTE: we don't need to check against out of bound scaling/moving as that will be done when using those cache values. #1785
                let ratio = column / this.column;
                nodes.forEach(node => {
                    if (!node._orig)
                        return; // didn't change (newly added ?)
                    let n = layout.find(l => l._id === node._id);
                    if (!n)
                        return; // no cache for new nodes. Will use those values.
                    // Y changed, push down same amount
                    // TODO: detect doing item 'swaps' will help instead of move (especially in 1 column mode)
                    if (n.y >= 0 && node.y !== node._orig.y) {
                        n.y += (node.y - node._orig.y);
                    }
                    // X changed, scale from new position
                    if (node.x !== node._orig.x) {
                        n.x = Math.round(node.x * ratio);
                    }
                    // width changed, scale from new width
                    if (node.w !== node._orig.w) {
                        n.w = Math.round(node.w * ratio);
                    }
                    // ...height always carries over from cache
                });
            }
        });
        return this;
    }
    /**
     * @internal Called to scale the widget width & position up/down based on the column change.
     * Note we store previous layouts (especially original ones) to make it possible to go
     * from say 12 -> 1 -> 12 and get back to where we were.
     *
     * @param prevColumn previous number of columns
     * @param column  new column number
     * @param layout specify the type of re-layout that will happen (position, size, etc...).
     * Note: items will never be outside of the current column boundaries. default (moveScale). Ignored for 1 column
     */
    columnChanged(prevColumn, column, layout = 'moveScale') {
        if (!this.nodes.length || !column || prevColumn === column)
            return this;
        // in this mode no layout is done whatsoever, up to the caller to handle it
        if (layout === 'none')
            return this;
        // simpler shortcuts layouts
        const doCompact = layout === 'compact' || layout === 'list';
        if (doCompact) {
            this.sortNodes(1); // sort with original layout once and only once (new column will affect order otherwise)
        }
        // cache the current layout in case they want to go back (like 12 -> 1 -> 12) as it requires original data IFF we're sizing down (see below)
        if (column < prevColumn)
            this.cacheLayout(this.nodes, prevColumn);
        this.batchUpdate(); // do this EARLY as it will call saveInitial() so we can detect where we started for _dirty and collision
        let newNodes = [];
        let nodes = doCompact ? this.nodes : _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(this.nodes, -1); // current column reverse sorting so we can insert last to front (limit collision)
        // see if we have cached previous layout IFF we are going up in size (restore) otherwise always
        // generate next size down from where we are (looks more natural as you gradually size down).
        if (column > prevColumn && this._layouts) {
            const cacheNodes = this._layouts[column] || [];
            // ...if not, start with the largest layout (if not already there) as down-scaling is more accurate
            // by pretending we came from that larger column by assigning those values as starting point
            let lastIndex = this._layouts.length - 1;
            if (!cacheNodes.length && prevColumn !== lastIndex && this._layouts[lastIndex]?.length) {
                prevColumn = lastIndex;
                this._layouts[lastIndex].forEach(cacheNode => {
                    let n = nodes.find(n => n._id === cacheNode._id);
                    if (n) {
                        // still current, use cache info positions
                        if (!doCompact && !cacheNode.autoPosition) {
                            n.x = cacheNode.x ?? n.x;
                            n.y = cacheNode.y ?? n.y;
                        }
                        n.w = cacheNode.w ?? n.w;
                        if (cacheNode.x == undefined || cacheNode.y === undefined)
                            n.autoPosition = true;
                    }
                });
            }
            // if we found cache re-use those nodes that are still current
            cacheNodes.forEach(cacheNode => {
                let j = nodes.findIndex(n => n._id === cacheNode._id);
                if (j !== -1) {
                    const n = nodes[j];
                    // still current, use cache info positions
                    if (doCompact) {
                        n.w = cacheNode.w; // only w is used, and don't trim the list
                        return;
                    }
                    if (cacheNode.autoPosition || isNaN(cacheNode.x) || isNaN(cacheNode.y)) {
                        this.findEmptyPosition(cacheNode, newNodes);
                    }
                    if (!cacheNode.autoPosition) {
                        n.x = cacheNode.x ?? n.x;
                        n.y = cacheNode.y ?? n.y;
                        n.w = cacheNode.w ?? n.w;
                        newNodes.push(n);
                    }
                    nodes.splice(j, 1);
                }
            });
        }
        // much simpler layout that just compacts
        if (doCompact) {
            this.compact(layout, false);
        }
        else {
            // ...and add any extra non-cached ones
            if (nodes.length) {
                if (typeof layout === 'function') {
                    layout(column, prevColumn, newNodes, nodes);
                }
                else {
                    let ratio = doCompact ? 1 : column / prevColumn;
                    let move = (layout === 'move' || layout === 'moveScale');
                    let scale = (layout === 'scale' || layout === 'moveScale');
                    nodes.forEach(node => {
                        // NOTE: x + w could be outside of the grid, but addNode() below will handle that
                        node.x = (column === 1 ? 0 : (move ? Math.round(node.x * ratio) : Math.min(node.x, column - 1)));
                        node.w = ((column === 1 || prevColumn === 1) ? 1 : scale ? (Math.round(node.w * ratio) || 1) : (Math.min(node.w, column)));
                        newNodes.push(node);
                    });
                    nodes = [];
                }
            }
            // finally re-layout them in reverse order (to get correct placement)
            newNodes = _utils__WEBPACK_IMPORTED_MODULE_0__.Utils.sort(newNodes, -1);
            this._inColumnResize = true; // prevent cache update
            this.nodes = []; // pretend we have no nodes to start with (add() will use same structures) to simplify layout
            newNodes.forEach(node => {
                this.addNode(node, false); // 'false' for add event trigger
                delete node._orig; // make sure the commit doesn't try to restore things back to original
            });
        }
        this.nodes.forEach(n => delete n._orig); // clear _orig before batch=false so it doesn't handle float=true restore
        this.batchUpdate(false, !doCompact);
        delete this._inColumnResize;
        return this;
    }
    /**
     * call to cache the given layout internally to the given location so we can restore back when column changes size
     * @param nodes list of nodes
     * @param column corresponding column index to save it under
     * @param clear if true, will force other caches to be removed (default false)
     */
    cacheLayout(nodes, column, clear = false) {
        let copy = [];
        nodes.forEach((n, i) => {
            // make sure we have an id in case this is new layout, else re-use id already set
            if (n._id === undefined) {
                const existing = n.id ? this.nodes.find(n2 => n2.id === n.id) : undefined; // find existing node using users id
                n._id = existing?._id ?? GridStackEngine._idSeq++;
            }
            copy[i] = { x: n.x, y: n.y, w: n.w, _id: n._id }; // only thing we change is x,y,w and id to find it back
        });
        this._layouts = clear ? [] : this._layouts || []; // use array to find larger quick
        this._layouts[column] = copy;
        return this;
    }
    /**
     * call to cache the given node layout internally to the given location so we can restore back when column changes size
     * @param node single node to cache
     * @param column corresponding column index to save it under
     */
    cacheOneLayout(n, column) {
        n._id = n._id ?? GridStackEngine._idSeq++;
        let l = { x: n.x, y: n.y, w: n.w, _id: n._id };
        if (n.autoPosition || n.x === undefined) {
            delete l.x;
            delete l.y;
            if (n.autoPosition)
                l.autoPosition = true;
        }
        this._layouts = this._layouts || [];
        this._layouts[column] = this._layouts[column] || [];
        let index = this.findCacheLayout(n, column);
        if (index === -1)
            this._layouts[column].push(l);
        else
            this._layouts[column][index] = l;
        return this;
    }
    findCacheLayout(n, column) {
        return this._layouts?.[column]?.findIndex(l => l._id === n._id) ?? -1;
    }
    removeNodeFromLayoutCache(n) {
        if (!this._layouts) {
            return;
        }
        for (let i = 0; i < this._layouts.length; i++) {
            let index = this.findCacheLayout(n, i);
            if (index !== -1) {
                this._layouts[i].splice(index, 1);
            }
        }
    }
    /** called to remove all internal values but the _id */
    cleanupNode(node) {
        for (let prop in node) {
            if (prop[0] === '_' && prop !== '_id')
                delete node[prop];
        }
        return this;
    }
}
/** @internal unique global internal _id counter */
GridStackEngine._idSeq = 0;

//# sourceMappingURL=gridstack-engine.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/gridstack.js":
/*!**************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DDGridStack: () => (/* reexport safe */ _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__.DDGridStack),
/* harmony export */   GridStack: () => (/* binding */ GridStack),
/* harmony export */   GridStackEngine: () => (/* reexport safe */ _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine),
/* harmony export */   Utils: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.Utils),
/* harmony export */   dragInDefaultOptions: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_2__.dragInDefaultOptions),
/* harmony export */   gridDefaults: () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults),
/* harmony export */   obsolete: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsolete),
/* harmony export */   obsoleteAttr: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsoleteAttr),
/* harmony export */   obsoleteOpts: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsoleteOpts),
/* harmony export */   obsoleteOptsDel: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_1__.obsoleteOptsDel)
/* harmony export */ });
/* harmony import */ var _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gridstack-engine */ "./node_modules/gridstack/dist/gridstack-engine.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./node_modules/gridstack/dist/utils.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/gridstack/dist/types.js");
/* harmony import */ var _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dd-gridstack */ "./node_modules/gridstack/dist/dd-gridstack.js");
/* harmony import */ var _dd_touch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dd-touch */ "./node_modules/gridstack/dist/dd-touch.js");
/* harmony import */ var _dd_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dd-manager */ "./node_modules/gridstack/dist/dd-manager.js");
/*!
 * GridStack 10.3.1
 * https://gridstackjs.com/
 *
 * Copyright (c) 2021-2022 Alain Dumesny
 * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE
 */



/*
 * and include D&D by default
 * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)
 * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts
 * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039
 */



const dd = new _dd_gridstack__WEBPACK_IMPORTED_MODULE_3__.DDGridStack;
// export all dependent file as well to make it easier for users to just import the main file




/**
 * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.
 * Note: your grid elements MUST have the following classes for the CSS layout to work:
 * @example
 * <div class="grid-stack">
 *   <div class="grid-stack-item">
 *     <div class="grid-stack-item-content">Item 1</div>
 *   </div>
 * </div>
 */
class GridStack {
    /**
     * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will
     * simply return the existing instance (ignore any passed options). There is also an initAll() version that support
     * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.
     * @param options grid options (optional)
     * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)
     *
     * @example
     * let grid = GridStack.init();
     *
     * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later
     * let grid = document.querySelector('.grid-stack').gridstack;
     */
    static init(options = {}, elOrString = '.grid-stack') {
        if (typeof document === 'undefined')
            return null; // temp workaround SSR
        let el = GridStack.getGridElement(elOrString);
        if (!el) {
            if (typeof elOrString === 'string') {
                console.error('GridStack.initAll() no grid was found with selector "' + elOrString + '" - element missing or wrong selector ?' +
                    '\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
            }
            else {
                console.error('GridStack.init() no grid element was passed.');
            }
            return null;
        }
        if (!el.gridstack) {
            el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));
        }
        return el.gridstack;
    }
    /**
     * Will initialize a list of elements (given a selector) and return an array of grids.
     * @param options grid options (optional)
     * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)
     *
     * @example
     * let grids = GridStack.initAll();
     * grids.forEach(...)
     */
    static initAll(options = {}, selector = '.grid-stack') {
        let grids = [];
        if (typeof document === 'undefined')
            return grids; // temp workaround SSR
        GridStack.getGridElements(selector).forEach(el => {
            if (!el.gridstack) {
                el.gridstack = new GridStack(el, _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options));
            }
            grids.push(el.gridstack);
        });
        if (grids.length === 0) {
            console.error('GridStack.initAll() no grid was found with selector "' + selector + '" - element missing or wrong selector ?' +
                '\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.');
        }
        return grids;
    }
    /**
     * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then
     * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from
     * JSON serialized data, including options.
     * @param parent HTML element parent to the grid
     * @param opt grids options used to initialize the grid, and list of children
     */
    static addGrid(parent, opt = {}) {
        if (!parent)
            return null;
        let el = parent;
        if (el.gridstack) {
            // already a grid - set option and load data
            const grid = el.gridstack;
            if (opt)
                grid.opts = { ...grid.opts, ...opt };
            if (opt.children !== undefined)
                grid.load(opt.children);
            return grid;
        }
        // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead
        const parentIsGrid = parent.classList.contains('grid-stack');
        if (!parentIsGrid || GridStack.addRemoveCB) {
            if (GridStack.addRemoveCB) {
                el = GridStack.addRemoveCB(parent, opt, true, true);
            }
            else {
                let doc = document.implementation.createHTMLDocument(''); // IE needs a param
                doc.body.innerHTML = `<div class="grid-stack ${opt.class || ''}"></div>`;
                el = doc.body.children[0];
                parent.appendChild(el);
            }
        }
        // create grid class and load any children
        let grid = GridStack.init(opt, el);
        return grid;
    }
    /** call this method to register your engine instead of the default one.
     * See instead `GridStackOptions.engineClass` if you only need to
     * replace just one instance.
     */
    static registerEngine(engineClass) {
        GridStack.engineClass = engineClass;
    }
    /** @internal create placeholder DIV as needed */
    get placeholder() {
        if (!this._placeholder) {
            let placeholderChild = document.createElement('div'); // child so padding match item-content
            placeholderChild.className = 'placeholder-content';
            if (this.opts.placeholderText) {
                placeholderChild.innerHTML = this.opts.placeholderText;
            }
            this._placeholder = document.createElement('div');
            this._placeholder.classList.add(this.opts.placeholderClass, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);
            this.placeholder.appendChild(placeholderChild);
        }
        return this._placeholder;
    }
    /**
     * Construct a grid item from the given element and options
     * @param el the HTML element tied to this grid after it's been initialized
     * @param opts grid options - public for classes to access, but use methods to modify!
     */
    constructor(el, opts = {}) {
        this.el = el;
        this.opts = opts;
        /** @internal */
        this._gsEventHandler = {};
        /** @internal extra row added when dragging at the bottom of the grid */
        this._extraDragRow = 0;
        /** @internal meant to store the scale of the active grid */
        this.dragTransform = { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 };
        el.gridstack = this;
        opts = opts || {}; // handles null/undefined/0
        if (!el.classList.contains('grid-stack')) {
            this.el.classList.add('grid-stack');
        }
        // if row property exists, replace minRow and maxRow instead
        if (opts.row) {
            opts.minRow = opts.maxRow = opts.row;
            delete opts.row;
        }
        let rowAttr = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-row'));
        // flag only valid in sub-grids (handled by parent, not here)
        if (opts.column === 'auto') {
            delete opts.column;
        }
        // save original setting so we can restore on save
        if (opts.alwaysShowResizeHandle !== undefined) {
            opts._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;
        }
        let bk = opts.columnOpts?.breakpoints;
        // LEGACY: oneColumnMode stuff changed in v10.x - check if user explicitly set something to convert over
        const oldOpts = opts;
        if (oldOpts.oneColumnModeDomSort) {
            delete oldOpts.oneColumnModeDomSort;
            console.log('warning: Gridstack oneColumnModeDomSort no longer supported. Use GridStackOptions.columnOpts instead.');
        }
        if (oldOpts.oneColumnSize || oldOpts.disableOneColumnMode === false) {
            const oneSize = oldOpts.oneColumnSize || 768;
            delete oldOpts.oneColumnSize;
            delete oldOpts.disableOneColumnMode;
            opts.columnOpts = opts.columnOpts || {};
            bk = opts.columnOpts.breakpoints = opts.columnOpts.breakpoints || [];
            let oneColumn = bk.find(b => b.c === 1);
            if (!oneColumn) {
                oneColumn = { c: 1, w: oneSize };
                bk.push(oneColumn, { c: 12, w: oneSize + 1 });
            }
            else
                oneColumn.w = oneSize;
        }
        //...end LEGACY
        // cleanup responsive opts (must have columnWidth | breakpoints) then sort breakpoints by size (so we can match during resize)
        const resp = opts.columnOpts;
        if (resp) {
            if (!resp.columnWidth && !resp.breakpoints?.length) {
                delete opts.columnOpts;
                bk = undefined;
            }
            else {
                resp.columnMax = resp.columnMax || 12;
            }
        }
        if (bk?.length > 1)
            bk.sort((a, b) => (b.w || 0) - (a.w || 0));
        // elements DOM attributes override any passed options (like CSS style) - merge the two together
        let defaults = {
            ..._utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults),
            column: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-column')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.column,
            minRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-min-row')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.minRow,
            maxRow: rowAttr ? rowAttr : _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-max-row')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.maxRow,
            staticGrid: _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-static')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.staticGrid,
            draggable: {
                handle: (opts.handleClass ? '.' + opts.handleClass : (opts.handle ? opts.handle : '')) || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.draggable.handle,
            },
            removableOptions: {
                accept: opts.itemClass || _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.accept,
                decline: _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.removableOptions.decline
            },
        };
        if (el.getAttribute('gs-animate')) { // default to true, but if set to false use that instead
            defaults.animate = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-animate'));
        }
        opts = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(opts, defaults);
        this._initMargin(); // part of settings defaults...
        // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)
        this.checkDynamicColumn();
        this.el.classList.add('gs-' + opts.column);
        if (opts.rtl === 'auto') {
            opts.rtl = (el.style.direction === 'rtl');
        }
        if (opts.rtl) {
            this.el.classList.add('grid-stack-rtl');
        }
        // check if we're been nested, and if so update our style and keep pointer around (used during save)
        const grandParent = this.el.parentElement?.parentElement;
        let parentGridItem = grandParent?.classList.contains(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass) ? grandParent.gridstackNode : undefined;
        if (parentGridItem) {
            parentGridItem.subGrid = this;
            this.parentGridItem = parentGridItem;
            this.el.classList.add('grid-stack-nested');
            parentGridItem.el.classList.add('grid-stack-sub-grid');
        }
        this._isAutoCellHeight = (opts.cellHeight === 'auto');
        if (this._isAutoCellHeight || opts.cellHeight === 'initial') {
            // make the cell content square initially (will use resize/column event to keep it square)
            this.cellHeight(undefined, false);
        }
        else {
            // append unit if any are set
            if (typeof opts.cellHeight == 'number' && opts.cellHeightUnit && opts.cellHeightUnit !== _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.cellHeightUnit) {
                opts.cellHeight = opts.cellHeight + opts.cellHeightUnit;
                delete opts.cellHeightUnit;
            }
            this.cellHeight(opts.cellHeight, false);
        }
        // see if we need to adjust auto-hide
        if (opts.alwaysShowResizeHandle === 'mobile') {
            opts.alwaysShowResizeHandle = _dd_touch__WEBPACK_IMPORTED_MODULE_4__.isTouch;
        }
        this._styleSheetClass = 'gs-id-' + _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine._idSeq++;
        this.el.classList.add(this._styleSheetClass);
        this._setStaticClass();
        let engineClass = opts.engineClass || GridStack.engineClass || _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;
        this.engine = new engineClass({
            column: this.getColumn(),
            float: opts.float,
            maxRow: opts.maxRow,
            onChange: (cbNodes) => {
                let maxH = 0;
                this.engine.nodes.forEach(n => { maxH = Math.max(maxH, n.y + n.h); });
                cbNodes.forEach(n => {
                    let el = n.el;
                    if (!el)
                        return;
                    if (n._removeDOM) {
                        if (el)
                            el.remove();
                        delete n._removeDOM;
                    }
                    else {
                        this._writePosAttr(el, n);
                    }
                });
                this._updateStyles(false, maxH); // false = don't recreate, just append if need be
            }
        });
        // create initial global styles BEFORE loading children so resizeToContent margin can be calculated correctly
        this._updateStyles(false, 0);
        if (opts.auto) {
            this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...
            this.engine._loading = true; // loading collision check
            this.getGridItems().forEach(el => this._prepareElement(el));
            delete this.engine._loading;
            this.batchUpdate(false);
        }
        // load any passed in children as well, which overrides any DOM layout done above
        if (opts.children) {
            const children = opts.children;
            delete opts.children;
            if (children.length)
                this.load(children); // don't load empty
        }
        // if (this.engine.nodes.length) this._updateStyles(); // update based on # of children. done in engine onChange CB
        this.setAnimation();
        // dynamic grids require pausing during drag to detect over to nest vs push
        if (opts.subGridDynamic && !_dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag)
            _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = true;
        if (opts.draggable?.pause !== undefined)
            _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = opts.draggable.pause;
        this._setupRemoveDrop();
        this._setupAcceptWidget();
        this._updateResizeEvent();
    }
    /**
     * add a new widget and returns it.
     *
     * Widget will be always placed even if result height is more than actual grid height.
     * You need to use `willItFit()` before calling addWidget for additional check.
     * See also `makeWidget()`.
     *
     * @example
     * let grid = GridStack.init();
     * grid.addWidget({w: 3, content: 'hello'});
     * grid.addWidget('<div class="grid-stack-item"><div class="grid-stack-item-content">hello</div></div>', {w: 3});
     *
     * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add
     * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget
     */
    addWidget(els, options) {
        function isGridStackWidget(w) {
            return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;
        }
        let el;
        let node;
        if (typeof els === 'string') {
            let doc = document.implementation.createHTMLDocument(''); // IE needs a param
            doc.body.innerHTML = els;
            el = doc.body.children[0];
        }
        else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {
            node = options = els;
            if (node?.el) {
                el = node.el; // re-use element stored in the node
            }
            else if (GridStack.addRemoveCB) {
                el = GridStack.addRemoveCB(this.el, options, true, false);
            }
            else {
                let content = options?.content || '';
                let doc = document.implementation.createHTMLDocument(''); // IE needs a param
                doc.body.innerHTML = `<div class="grid-stack-item ${this.opts.itemClass || ''}"><div class="grid-stack-item-content">${content}</div></div>`;
                el = doc.body.children[0];
            }
        }
        else {
            el = els;
        }
        if (!el)
            return;
        // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest
        node = el.gridstackNode;
        if (node && el.parentElement === this.el && this.engine.nodes.find(n => n._id === node._id))
            return el;
        // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos
        // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.
        // So make sure we load any DOM attributes that are not specified in passed in options (which override)
        let domAttr = this._readAttr(el);
        options = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(options) || {}; // make a copy before we modify in case caller re-uses it
        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.defaults(options, domAttr);
        node = this.engine.prepareNode(options);
        this._writeAttr(el, options);
        this.el.appendChild(el);
        this.makeWidget(el, options);
        return el;
    }
    /**
     * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them
     * from the parent's subGrid options.
     * @param el gridItem element to convert
     * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults
     * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)
     * @param saveContent if true (default) the html inside .grid-stack-content will be saved to child widget
     * @returns newly created grid
     */
    makeSubGrid(el, ops, nodeToAdd, saveContent = true) {
        let node = el.gridstackNode;
        if (!node) {
            node = this.makeWidget(el).gridstackNode;
        }
        if (node.subGrid?.el)
            return node.subGrid; // already done
        // find the template subGrid stored on a parent as fallback...
        let subGridTemplate; // eslint-disable-next-line @typescript-eslint/no-this-alias
        let grid = this;
        while (grid && !subGridTemplate) {
            subGridTemplate = grid.opts?.subGridOpts;
            grid = grid.parentGridItem?.grid;
        }
        //... and set the create options
        ops = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep({ ...(subGridTemplate || {}), children: undefined, ...(ops || node.subGridOpts || {}) });
        node.subGridOpts = ops;
        // if column special case it set, remember that flag and set default
        let autoColumn;
        if (ops.column === 'auto') {
            autoColumn = true;
            ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);
            delete ops.columnOpts; // driven by parent
        }
        // if we're converting an existing full item, move over the content to be the first sub item in the new grid
        let content = node.el.querySelector('.grid-stack-item-content');
        let newItem;
        let newItemOpt;
        if (saveContent) {
            this._removeDD(node.el); // remove D&D since it's set on content div
            newItemOpt = { ...node, x: 0, y: 0 };
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalForSave(newItemOpt);
            delete newItemOpt.subGridOpts;
            if (node.content) {
                newItemOpt.content = node.content;
                delete node.content;
            }
            if (GridStack.addRemoveCB) {
                newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);
            }
            else {
                let doc = document.implementation.createHTMLDocument(''); // IE needs a param
                doc.body.innerHTML = `<div class="grid-stack-item"></div>`;
                newItem = doc.body.children[0];
                newItem.appendChild(content);
                doc.body.innerHTML = `<div class="grid-stack-item-content"></div>`;
                content = doc.body.children[0];
                node.el.appendChild(content);
            }
            this._prepareDragDropByNode(node); // ... and restore original D&D
        }
        // if we're adding an additional item, make the container large enough to have them both
        if (nodeToAdd) {
            let w = autoColumn ? ops.column : node.w;
            let h = node.h + nodeToAdd.h;
            let style = node.el.style;
            style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd
            this.update(node.el, { w, h });
            setTimeout(() => style.transition = null); // recover animation
        }
        let subGrid = node.subGrid = GridStack.addGrid(content, ops);
        if (nodeToAdd?._moving)
            subGrid._isTemp = true; // prevent re-nesting as we add over
        if (autoColumn)
            subGrid._autoColumn = true;
        // add the original content back as a child of hte newly created grid
        if (saveContent) {
            subGrid.addWidget(newItem, newItemOpt);
        }
        // now add any additional node
        if (nodeToAdd) {
            if (nodeToAdd._moving) {
                // create an artificial event even for the just created grid to receive this item
                window.setTimeout(() => _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);
            }
            else {
                subGrid.addWidget(node.el, node);
            }
        }
        return subGrid;
    }
    /**
     * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back
     * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)
     */
    removeAsSubGrid(nodeThatRemoved) {
        let pGrid = this.parentGridItem?.grid;
        if (!pGrid)
            return;
        pGrid.batchUpdate();
        pGrid.removeWidget(this.parentGridItem.el, true, true);
        this.engine.nodes.forEach(n => {
            // migrate any children over and offsetting by our location
            n.x += this.parentGridItem.x;
            n.y += this.parentGridItem.y;
            pGrid.addWidget(n.el, n);
        });
        pGrid.batchUpdate(false);
        if (this.parentGridItem)
            delete this.parentGridItem.subGrid;
        delete this.parentGridItem;
        // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)
        if (nodeThatRemoved) {
            window.setTimeout(() => _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);
        }
    }
    /**
     * saves the current layout returning a list of widgets for serialization which might include any nested grids.
     * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will
     * be removed.
     * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()
     * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.
     * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.
     * @returns list of widgets or full grid option, including .children list of widgets
     */
    save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB) {
        // return copied GridStackWidget (with optionally .el) we can modify at will...
        let list = this.engine.save(saveContent, saveCB);
        // check for HTML content and nested grids
        list.forEach(n => {
            if (saveContent && n.el && !n.subGrid && !saveCB) { // sub-grid are saved differently, not plain content
                let sub = n.el.querySelector('.grid-stack-item-content');
                n.content = sub ? sub.innerHTML : undefined;
                if (!n.content)
                    delete n.content;
            }
            else {
                if (!saveContent && !saveCB) {
                    delete n.content;
                }
                // check for nested grid
                if (n.subGrid?.el) {
                    const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);
                    n.subGridOpts = (saveGridOpt ? listOrOpt : { children: listOrOpt });
                    delete n.subGrid;
                }
            }
            delete n.el;
        });
        // check if save entire grid options (needed for recursive) + children...
        if (saveGridOpt) {
            let o = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(this.opts);
            // delete default values that will be recreated on launch
            if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {
                o.margin = o.marginTop;
                delete o.marginTop;
                delete o.marginRight;
                delete o.marginBottom;
                delete o.marginLeft;
            }
            if (o.rtl === (this.el.style.direction === 'rtl')) {
                o.rtl = 'auto';
            }
            if (this._isAutoCellHeight) {
                o.cellHeight = 'auto';
            }
            if (this._autoColumn) {
                o.column = 'auto';
            }
            const origShow = o._alwaysShowResizeHandle;
            delete o._alwaysShowResizeHandle;
            if (origShow !== undefined) {
                o.alwaysShowResizeHandle = origShow;
            }
            else {
                delete o.alwaysShowResizeHandle;
            }
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeInternalAndSame(o, _types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults);
            o.children = list;
            return o;
        }
        return list;
    }
    /**
     * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.
     *
     * @param layout list of widgets definition to update/create
     * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving
     * the user control of insertion.
     *
     * @example
     * see http://gridstackjs.com/demo/serialization.html
     */
    load(items, addRemove = GridStack.addRemoveCB || true) {
        items = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(items); // so we can mod
        const column = this.getColumn();
        // make sure size 1x1 (default) is present as it may need to override current sizes
        items.forEach(n => { n.w = n.w || 1; n.h = n.h || 1; });
        // sort items. those without coord will be appended last
        items = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sort(items);
        // if we're loading a layout into for example 1 column and items don't fit, make sure to save
        // the original wanted layout so we can scale back up correctly #1471
        let maxColumn = 0;
        items.forEach(n => { maxColumn = Math.max(maxColumn, (n.x || 0) + n.w); });
        if (maxColumn > column) {
            this._ignoreLayoutsNodeChange = true; // skip layout update
            this.engine.cacheLayout(items, maxColumn, true);
        }
        // if given a different callback, temporally set it as global option so creating will use it
        const prevCB = GridStack.addRemoveCB;
        if (typeof (addRemove) === 'function')
            GridStack.addRemoveCB = addRemove;
        let removed = [];
        this.batchUpdate();
        // if we are loading from empty temporarily remove animation
        const blank = !this.engine.nodes.length;
        if (blank)
            this.setAnimation(false);
        // see if any items are missing from new layout and need to be removed first
        if (!blank && addRemove) {
            let copyNodes = [...this.engine.nodes]; // don't loop through array you modify
            copyNodes.forEach(n => {
                if (!n.id)
                    return;
                let item = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(items, n.id);
                if (!item) {
                    if (GridStack.addRemoveCB)
                        GridStack.addRemoveCB(this.el, n, false, false);
                    removed.push(n); // batch keep track
                    this.removeWidget(n.el, true, false);
                }
            });
        }
        // now add/update the widgets - starting with removing items in the new layout we will reposition
        // to reduce collision and add no-coord ones at next available spot
        this.engine._loading = true; // help with collision
        let updateNodes = [];
        this.engine.nodes = this.engine.nodes.filter(n => {
            if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(items, n.id)) {
                updateNodes.push(n);
                return false;
            } // remove if found from list
            return true;
        });
        items.forEach(w => {
            let item = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.find(updateNodes, w.id);
            if (item) {
                // if item sizes to content, re-use the exiting height so it's a better guess at the final size (same if width doesn't change)
                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(item))
                    w.h = item.h;
                // check if missing coord, in which case find next empty slot with new (or old if missing) sizes
                this.engine.nodeBoundFix(w);
                if (w.autoPosition || w.x === undefined || w.y === undefined) {
                    w.w = w.w || item.w;
                    w.h = w.h || item.h;
                    this.engine.findEmptyPosition(w);
                }
                // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now
                this.engine.nodes.push(item);
                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.samePos(item, w)) {
                    this.moveNode(item, { ...w, forceCollide: true });
                }
                this.update(item.el, w);
                if (w.subGridOpts?.children) { // update any sub grid as well
                    let sub = item.el.querySelector('.grid-stack');
                    if (sub && sub.gridstack) {
                        sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?
                    }
                }
            }
            else if (addRemove) {
                this.addWidget(w);
            }
        });
        delete this.engine._loading; // done loading
        this.engine.removedNodes = removed;
        this.batchUpdate(false);
        // after commit, clear that flag
        delete this._ignoreLayoutsNodeChange;
        prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;
        // delay adding animation back
        if (blank && this.opts?.animate)
            this.setAnimation(this.opts.animate, true);
        return this;
    }
    /**
     * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)
     * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.
     */
    batchUpdate(flag = true) {
        this.engine.batchUpdate(flag);
        if (!flag) {
            this._updateContainerHeight();
            this._triggerRemoveEvent();
            this._triggerAddEvent();
            this._triggerChangeEvent();
        }
        return this;
    }
    /**
     * Gets current cell height.
     */
    getCellHeight(forcePixel = false) {
        if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' &&
            (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {
            return this.opts.cellHeight;
        }
        // do rem/em/cm/mm to px conversion
        if (this.opts.cellHeightUnit === 'rem') {
            return this.opts.cellHeight * parseFloat(getComputedStyle(document.documentElement).fontSize);
        }
        if (this.opts.cellHeightUnit === 'em') {
            return this.opts.cellHeight * parseFloat(getComputedStyle(this.el).fontSize);
        }
        if (this.opts.cellHeightUnit === 'cm') {
            // 1cm = 96px/2.54. See https://www.w3.org/TR/css-values-3/#absolute-lengths
            return this.opts.cellHeight * (96 / 2.54);
        }
        if (this.opts.cellHeightUnit === 'mm') {
            return this.opts.cellHeight * (96 / 2.54) / 10;
        }
        // else get first cell height
        let el = this.el.querySelector('.' + this.opts.itemClass);
        if (el) {
            let h = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-h')) || 1; // since we don't write 1 anymore
            return Math.round(el.offsetHeight / h);
        }
        // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)
        let rows = parseInt(this.el.getAttribute('gs-current-row'));
        return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;
    }
    /**
     * Update current cell height - see `GridStackOptions.cellHeight` for format.
     * This method rebuilds an internal CSS style sheet.
     * Note: You can expect performance issues if call this method too often.
     *
     * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),
     * if pass 0 the CSS will be generated by the application instead.
     * @param update (Optional) if false, styles will not be updated
     *
     * @example
     * grid.cellHeight(100); // same as 100px
     * grid.cellHeight('70px');
     * grid.cellHeight(grid.cellWidth() * 1.2);
     */
    cellHeight(val, update = true) {
        // if not called internally, check if we're changing mode
        if (update && val !== undefined) {
            if (this._isAutoCellHeight !== (val === 'auto')) {
                this._isAutoCellHeight = (val === 'auto');
                this._updateResizeEvent();
            }
        }
        if (val === 'initial' || val === 'auto') {
            val = undefined;
        }
        // make item content be square
        if (val === undefined) {
            let marginDiff = -this.opts.marginRight - this.opts.marginLeft
                + this.opts.marginTop + this.opts.marginBottom;
            val = this.cellWidth() + marginDiff;
        }
        let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(val);
        if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {
            return this;
        }
        this.opts.cellHeightUnit = data.unit;
        this.opts.cellHeight = data.h;
        this.resizeToContentCheck();
        if (update) {
            this._updateStyles(true); // true = force re-create for current # of rows
        }
        return this;
    }
    /** Gets current cell width. */
    cellWidth() {
        return this._widthOrContainer() / this.getColumn();
    }
    /** return our expected width (or parent) , and optionally of window for dynamic column check */
    _widthOrContainer(forBreakpoint = false) {
        // use `offsetWidth` or `clientWidth` (no scrollbar) ?
        // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively
        return forBreakpoint && this.opts.columnOpts?.breakpointForWindow ? window.innerWidth : (this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth);
    }
    /** checks for dynamic column count for our current size, returning true if changed */
    checkDynamicColumn() {
        const resp = this.opts.columnOpts;
        if (!resp || (!resp.columnWidth && !resp.breakpoints?.length))
            return false;
        const column = this.getColumn();
        let newColumn = column;
        const w = this._widthOrContainer(true);
        if (resp.columnWidth) {
            newColumn = Math.min(Math.round(w / resp.columnWidth) || 1, resp.columnMax);
        }
        else {
            // find the closest breakpoint (already sorted big to small) that matches
            newColumn = resp.columnMax;
            let i = 0;
            while (i < resp.breakpoints.length && w <= resp.breakpoints[i].w) {
                newColumn = resp.breakpoints[i++].c || column;
            }
        }
        if (newColumn !== column) {
            const bk = resp.breakpoints?.find(b => b.c === newColumn);
            this.column(newColumn, bk?.layout || resp.layout);
            return true;
        }
        return false;
    }
    /**
     * re-layout grid items to reclaim any empty space. Options are:
     * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit
     * 'compact' might re-order items to fill any empty space
     *
     * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)
     */
    compact(layout = 'compact', doSort = true) {
        this.engine.compact(layout, doSort);
        this._triggerChangeEvent();
        return this;
    }
    /**
     * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,
     * as well as cache the original layout so you can revert back to previous positions without loss.
     * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],
     * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)
     * @param column - Integer > 0 (default 12).
     * @param layout specify the type of re-layout that will happen (position, size, etc...).
     * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column
     */
    column(column, layout = 'moveScale') {
        if (!column || column < 1 || this.opts.column === column)
            return this;
        let oldColumn = this.getColumn();
        this.opts.column = column;
        if (!this.engine)
            return this; // called in constructor, noting else to do
        this.engine.column = column;
        this.el.classList.remove('gs-' + oldColumn);
        this.el.classList.add('gs-' + column);
        // update the items now, checking if we have a custom children layout
        /*const newChildren = this.opts.columnOpts?.breakpoints?.find(r => r.c === column)?.children;
        if (newChildren) this.load(newChildren);
        else*/ this.engine.columnChanged(oldColumn, column, layout);
        if (this._isAutoCellHeight)
            this.cellHeight();
        this.resizeToContentCheck(true); // wait for width resizing
        // and trigger our event last...
        this._ignoreLayoutsNodeChange = true; // skip layout update
        this._triggerChangeEvent();
        delete this._ignoreLayoutsNodeChange;
        return this;
    }
    /**
     * get the number of columns in the grid (default 12)
     */
    getColumn() { return this.opts.column; }
    /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */
    getGridItems() {
        return Array.from(this.el.children)
            .filter((el) => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass));
    }
    /**
     * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.
     * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).
     */
    destroy(removeDOM = true) {
        if (!this.el)
            return; // prevent multiple calls
        this.offAll();
        this._updateResizeEvent(true);
        this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)
        this.setAnimation(false);
        if (!removeDOM) {
            this.removeAll(removeDOM);
            this.el.classList.remove(this._styleSheetClass);
            this.el.removeAttribute('gs-current-row');
        }
        else {
            this.el.parentNode.removeChild(this.el);
        }
        this._removeStylesheet();
        if (this.parentGridItem)
            delete this.parentGridItem.subGrid;
        delete this.parentGridItem;
        delete this.opts;
        delete this._placeholder;
        delete this.engine;
        delete this.el.gridstack; // remove circular dependency that would prevent a freeing
        delete this.el;
        return this;
    }
    /**
     * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)
     */
    float(val) {
        if (this.opts.float !== val) {
            this.opts.float = this.engine.float = val;
            this._triggerChangeEvent();
        }
        return this;
    }
    /**
     * get the current float mode
     */
    getFloat() {
        return this.engine.float;
    }
    /**
     * Get the position of the cell under a pixel on screen.
     * @param position the position of the pixel to resolve in
     * absolute coordinates, as an object with top and left properties
     * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).
     * Useful when grid is within `position: relative` element
     *
     * Returns an object with properties `x` and `y` i.e. the column and row in the grid.
     */
    getCellFromPixel(position, useDocRelative = false) {
        let box = this.el.getBoundingClientRect();
        // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)
        let containerPos;
        if (useDocRelative) {
            containerPos = { top: box.top + document.documentElement.scrollTop, left: box.left };
            // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)
        }
        else {
            containerPos = { top: this.el.offsetTop, left: this.el.offsetLeft };
            // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)
        }
        let relativeLeft = position.left - containerPos.left;
        let relativeTop = position.top - containerPos.top;
        let columnWidth = (box.width / this.getColumn());
        let rowHeight = (box.height / parseInt(this.el.getAttribute('gs-current-row')));
        return { x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight) };
    }
    /** returns the current number of rows, which will be at least `minRow` if set */
    getRow() {
        return Math.max(this.engine.getRow(), this.opts.minRow);
    }
    /**
     * Checks if specified area is empty.
     * @param x the position x.
     * @param y the position y.
     * @param w the width of to check
     * @param h the height of to check
     */
    isAreaEmpty(x, y, w, h) {
        return this.engine.isAreaEmpty(x, y, w, h);
    }
    /**
     * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.
     * If you want gridstack to add the elements for you, use `addWidget()` instead.
     * Makes the given element a widget and returns it.
     * @param els widget or single selector to convert.
     * @param options widget definition to use instead of reading attributes or using default sizing values
     *
     * @example
     * let grid = GridStack.init();
     * grid.el.appendChild('<div id="1" gs-w="3"></div>');
     * grid.el.appendChild('<div id="2"></div>');
     * grid.makeWidget('1');
     * grid.makeWidget('2', {w:2, content: 'hello'});
     */
    makeWidget(els, options) {
        let el = GridStack.getElement(els);
        this._prepareElement(el, true, options);
        const node = el.gridstackNode;
        this._updateContainerHeight();
        // see if there is a sub-grid to create
        if (node.subGridOpts) {
            this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass
        }
        // if we're adding an item into 1 column make sure
        // we don't override the larger 12 column layout that was already saved. #1985
        if (this.opts.column === 1) {
            this._ignoreLayoutsNodeChange = true;
        }
        this._triggerAddEvent();
        this._triggerChangeEvent();
        delete this._ignoreLayoutsNodeChange;
        return el;
    }
    on(name, callback) {
        // check for array of names being passed instead
        if (name.indexOf(' ') !== -1) {
            let names = name.split(' ');
            names.forEach(name => this.on(name, callback));
            return this;
        }
        // native CustomEvent handlers - cash the generic handlers so we can easily remove
        if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {
            let noData = (name === 'enable' || name === 'disable');
            if (noData) {
                this._gsEventHandler[name] = (event) => callback(event);
            }
            else {
                this._gsEventHandler[name] = (event) => callback(event, event.detail);
            }
            this.el.addEventListener(name, this._gsEventHandler[name]);
        }
        else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize'
            || name === 'resizestop' || name === 'dropped' || name === 'resizecontent') {
            // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.
            // do same for start event to make it easier...
            this._gsEventHandler[name] = callback;
        }
        else {
            console.error('GridStack.on(' + name + ') event not supported');
        }
        return this;
    }
    /**
     * unsubscribe from the 'on' event GridStackEvent
     * @param name of the event (see possible values) or list of names space separated
     */
    off(name) {
        // check for array of names being passed instead
        if (name.indexOf(' ') !== -1) {
            let names = name.split(' ');
            names.forEach(name => this.off(name));
            return this;
        }
        if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {
            // remove native CustomEvent handlers
            if (this._gsEventHandler[name]) {
                this.el.removeEventListener(name, this._gsEventHandler[name]);
            }
        }
        delete this._gsEventHandler[name];
        return this;
    }
    /** remove all event handlers */
    offAll() {
        Object.keys(this._gsEventHandler).forEach((key) => this.off(key));
        return this;
    }
    /**
     * Removes widget from the grid.
     * @param el  widget or selector to modify
     * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).
     * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).
     */
    removeWidget(els, removeDOM = true, triggerEvent = true) {
        GridStack.getElements(els).forEach(el => {
            if (el.parentElement && el.parentElement !== this.el)
                return; // not our child!
            let node = el.gridstackNode;
            // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272
            if (!node) {
                node = this.engine.nodes.find(n => el === n.el);
            }
            if (!node)
                return;
            if (removeDOM && GridStack.addRemoveCB) {
                GridStack.addRemoveCB(this.el, node, false, false);
            }
            // remove our DOM data (circular link) and drag&drop permanently
            delete el.gridstackNode;
            this._removeDD(el);
            this.engine.removeNode(node, removeDOM, triggerEvent);
            if (removeDOM && el.parentElement) {
                el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM
            }
        });
        if (triggerEvent) {
            this._triggerRemoveEvent();
            this._triggerChangeEvent();
        }
        return this;
    }
    /**
     * Removes all widgets from the grid.
     * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).
     * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).
     */
    removeAll(removeDOM = true, triggerEvent = true) {
        // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently
        this.engine.nodes.forEach(n => {
            if (removeDOM && GridStack.addRemoveCB) {
                GridStack.addRemoveCB(this.el, n, false, false);
            }
            delete n.el.gridstackNode;
            if (!this.opts.staticGrid)
                this._removeDD(n.el);
        });
        this.engine.removeAll(removeDOM, triggerEvent);
        if (triggerEvent)
            this._triggerRemoveEvent();
        return this;
    }
    /**
     * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.
     * @param doAnimate if true the grid will animate.
     * @param delay if true setting will be set on next event loop.
     */
    setAnimation(doAnimate = this.opts.animate, delay) {
        if (delay) {
            // delay, but check to make sure grid (opt) is still around
            setTimeout(() => { if (this.opts)
                this.setAnimation(doAnimate); });
        }
        else if (doAnimate) {
            this.el.classList.add('grid-stack-animate');
        }
        else {
            this.el.classList.remove('grid-stack-animate');
        }
        return this;
    }
    /** @internal */
    hasAnimationCSS() { return this.el.classList.contains('grid-stack-animate'); }
    /**
     * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.
     * Also toggle the grid-stack-static class.
     * @param val if true the grid become static.
     * @param updateClass true (default) if css class gets updated
     * @param recurse true (default) if sub-grids also get updated
     */
    setStatic(val, updateClass = true, recurse = true) {
        if (!!this.opts.staticGrid === val)
            return this;
        val ? this.opts.staticGrid = true : delete this.opts.staticGrid;
        this._setupRemoveDrop();
        this._setupAcceptWidget();
        this.engine.nodes.forEach(n => {
            this._prepareDragDropByNode(n); // either delete or init Drag&drop
            if (n.subGrid && recurse)
                n.subGrid.setStatic(val, updateClass, recurse);
        });
        if (updateClass) {
            this._setStaticClass();
        }
        return this;
    }
    /**
     * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.
     * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)
     * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.
     */
    update(els, opt) {
        // support legacy call for now ?
        if (arguments.length > 2) {
            console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');
            // eslint-disable-next-line prefer-rest-params
            let a = arguments, i = 1;
            opt = { x: a[i++], y: a[i++], w: a[i++], h: a[i++] };
            return this.update(els, opt);
        }
        GridStack.getElements(els).forEach(el => {
            let n = el?.gridstackNode;
            if (!n)
                return;
            let w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items
            this.engine.nodeBoundFix(w);
            delete w.autoPosition;
            delete w.id;
            // move/resize widget if anything changed
            let keys = ['x', 'y', 'w', 'h'];
            let m;
            if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {
                m = {};
                keys.forEach(k => {
                    m[k] = (w[k] !== undefined) ? w[k] : n[k];
                    delete w[k];
                });
            }
            // for a move as well IFF there is any min/max fields set
            if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {
                m = {}; // will use node position but validate values
            }
            // check for content changing
            if (w.content !== undefined) {
                const itemContent = el.querySelector('.grid-stack-item-content');
                if (itemContent && itemContent.innerHTML !== w.content) {
                    itemContent.innerHTML = w.content;
                    // restore any sub-grid back
                    if (n.subGrid?.el) {
                        itemContent.appendChild(n.subGrid.el);
                        if (!n.subGrid.opts.styleInHead)
                            n.subGrid._updateStyles(true); // force create
                    }
                }
                delete w.content;
            }
            // any remaining fields are assigned, but check for dragging changes, resize constrain
            let changed = false;
            let ddChanged = false;
            for (const key in w) {
                if (key[0] !== '_' && n[key] !== w[key]) {
                    n[key] = w[key];
                    changed = true;
                    ddChanged = ddChanged || (!this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked'));
                }
            }
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.sanitizeMinMax(n);
            // finally move the widget and update attr
            if (m) {
                const widthChanged = (m.w !== undefined && m.w !== n.w);
                this.moveNode(n, m);
                this.resizeToContentCheck(widthChanged, n); // wait for animation if we changed width
                delete n._orig; // clear out original position now that we moved #2669
            }
            if (m || changed) {
                this._writeAttr(el, n);
            }
            if (ddChanged) {
                this._prepareDragDropByNode(n);
            }
        });
        return this;
    }
    moveNode(n, m) {
        const wasUpdating = n._updating;
        if (!wasUpdating)
            this.engine.cleanNodes().beginUpdate(n);
        this.engine.moveNode(n, m);
        this._updateContainerHeight();
        if (!wasUpdating) {
            this._triggerChangeEvent();
            this.engine.endUpdate();
        }
    }
    /**
     * Updates widget height to match the content height to avoid v-scrollbar or dead space.
     * Note: this assumes only 1 child under resizeToContentParent='.grid-stack-item-content' (sized to gridItem minus padding) that is at the entire content size wanted.
     * @param el grid item element
     * @param useNodeH set to true if GridStackNode.h should be used instead of actual container height when we don't need to wait for animation to finish to get actual DOM heights
     */
    resizeToContent(el) {
        if (!el)
            return;
        el.classList.remove('size-to-content-max');
        if (!el.clientHeight)
            return; // 0 when hidden, skip
        const n = el.gridstackNode;
        if (!n)
            return;
        const grid = n.grid;
        if (!grid || el.parentElement !== grid.el)
            return; // skip if we are not inside a grid
        const cell = grid.getCellHeight(true);
        if (!cell)
            return;
        let height = n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth
        let item;
        if (n.resizeToContentParent)
            item = el.querySelector(n.resizeToContentParent);
        if (!item)
            item = el.querySelector(GridStack.resizeToContentParent);
        if (!item)
            return;
        const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)
        const itemH = n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)
        let wantedH;
        if (n.subGrid) {
            // sub-grid - use their actual row count * their cell height
            wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight(true);
        }
        else if (n.subGridOpts?.children?.length) {
            // not sub-grid just yet (case above) wait until we do
            return;
        }
        else {
            // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!
            const child = item.firstElementChild;
            if (!child) {
                console.error(`Error: GridStack.resizeToContent() widget id:${n.id} '${GridStack.resizeToContentParent}'.firstElementChild is null, make sure to have a div like container. Skipping sizing.`);
                return;
            }
            wantedH = child.getBoundingClientRect().height || itemH;
        }
        if (itemH === wantedH)
            return;
        height += wantedH - itemH;
        let h = Math.ceil(height / cell);
        // check for min/max and special sizing
        const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent : 0;
        if (softMax && h > softMax) {
            h = softMax;
            el.classList.add('size-to-content-max'); // get v-scroll back
        }
        if (n.minH && h < n.minH)
            h = n.minH;
        else if (n.maxH && h > n.maxH)
            h = n.maxH;
        if (h !== n.h) {
            grid._ignoreLayoutsNodeChange = true;
            grid.moveNode(n, { h });
            delete grid._ignoreLayoutsNodeChange;
        }
    }
    /** call the user resize (so they can do extra work) else our build in version */
    resizeToContentCBCheck(el) {
        if (GridStack.resizeToContentCB)
            GridStack.resizeToContentCB(el);
        else
            this.resizeToContent(el);
    }
    /** rotate (by swapping w & h) the passed in node - called when user press 'r' during dragging
     * @param els  widget or selector of objects to modify
     * @param relative optional pixel coord relative to upper/left corner to rotate around (will keep that cell under cursor)
     */
    rotate(els, relative) {
        GridStack.getElements(els).forEach(el => {
            let n = el.gridstackNode;
            if (!_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.canBeRotated(n))
                return;
            const rot = { w: n.h, h: n.w, minH: n.minW, minW: n.minH, maxH: n.maxW, maxW: n.maxH };
            // if given an offset, adjust x/y by column/row bounds when user presses 'r' during dragging
            if (relative) {
                let pivotX = relative.left > 0 ? Math.floor(relative.left / this.cellWidth()) : 0;
                let pivotY = relative.top > 0 ? Math.floor(relative.top / this.opts.cellHeight) : 0;
                rot.x = n.x + pivotX - (n.h - (pivotY + 1));
                rot.y = (n.y + pivotY) - pivotX;
            }
            Object.keys(rot).forEach(k => { if (rot[k] === undefined)
                delete rot[k]; });
            const _orig = n._orig;
            this.update(el, rot);
            n._orig = _orig; // restore as move() will delete it
        });
        return this;
    }
    /**
     * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).
     * @param value margin value
     */
    margin(value) {
        let isMultiValue = (typeof value === 'string' && value.split(' ').length > 1);
        // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)
        if (!isMultiValue) {
            let data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(value);
            if (this.opts.marginUnit === data.unit && this.opts.margin === data.h)
                return;
        }
        // re-use existing margin handling
        this.opts.margin = value;
        this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;
        this._initMargin();
        this._updateStyles(true); // true = force re-create
        return this;
    }
    /** returns current margin number value (undefined if 4 sides don't match) */
    getMargin() { return this.opts.margin; }
    /**
     * Returns true if the height of the grid will be less than the vertical
     * constraint. Always returns true if grid doesn't have height constraint.
     * @param node contains x,y,w,h,auto-position options
     *
     * @example
     * if (grid.willItFit(newWidget)) {
     *   grid.addWidget(newWidget);
     * } else {
     *   alert('Not enough free space to place the widget');
     * }
     */
    willItFit(node) {
        // support legacy call for now
        if (arguments.length > 1) {
            console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');
            // eslint-disable-next-line prefer-rest-params
            let a = arguments, i = 0, w = { x: a[i++], y: a[i++], w: a[i++], h: a[i++], autoPosition: a[i++] };
            return this.willItFit(w);
        }
        return this.engine.willItFit(node);
    }
    /** @internal */
    _triggerChangeEvent() {
        if (this.engine.batchMode)
            return this;
        let elements = this.engine.getDirtyNodes(true); // verify they really changed
        if (elements && elements.length) {
            if (!this._ignoreLayoutsNodeChange) {
                this.engine.layoutsNodesChange(elements);
            }
            this._triggerEvent('change', elements);
        }
        this.engine.saveInitial(); // we called, now reset initial values & dirty flags
        return this;
    }
    /** @internal */
    _triggerAddEvent() {
        if (this.engine.batchMode)
            return this;
        if (this.engine.addedNodes?.length) {
            if (!this._ignoreLayoutsNodeChange) {
                this.engine.layoutsNodesChange(this.engine.addedNodes);
            }
            // prevent added nodes from also triggering 'change' event (which is called next)
            this.engine.addedNodes.forEach(n => { delete n._dirty; });
            const addedNodes = [...this.engine.addedNodes];
            this.engine.addedNodes = [];
            this._triggerEvent('added', addedNodes);
        }
        return this;
    }
    /** @internal */
    _triggerRemoveEvent() {
        if (this.engine.batchMode)
            return this;
        if (this.engine.removedNodes?.length) {
            const removedNodes = [...this.engine.removedNodes];
            this.engine.removedNodes = [];
            this._triggerEvent('removed', removedNodes);
        }
        return this;
    }
    /** @internal */
    _triggerEvent(type, data) {
        let event = data ? new CustomEvent(type, { bubbles: false, detail: data }) : new Event(type);
        this.el.dispatchEvent(event);
        return this;
    }
    /** @internal called to delete the current dynamic style sheet used for our layout */
    _removeStylesheet() {
        if (this._styles) {
            const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removeStylesheet(this._styleSheetClass, styleLocation);
            delete this._styles;
        }
        return this;
    }
    /** @internal updated/create the CSS styles for row based layout and initial margin setting */
    _updateStyles(forceUpdate = false, maxH) {
        // call to delete existing one if we change cellHeight / margin
        if (forceUpdate) {
            this._removeStylesheet();
        }
        if (maxH === undefined)
            maxH = this.getRow();
        this._updateContainerHeight();
        // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??
        if (this.opts.cellHeight === 0) {
            return this;
        }
        let cellHeight = this.opts.cellHeight;
        let cellHeightUnit = this.opts.cellHeightUnit;
        let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;
        // create one as needed
        if (!this._styles) {
            // insert style to parent (instead of 'head' by default) to support WebComponent
            const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;
            this._styles = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.createStylesheet(this._styleSheetClass, styleLocation, {
                nonce: this.opts.nonce,
            });
            if (!this._styles)
                return this;
            this._styles._max = 0;
            // these are done once only
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, prefix, `height: ${cellHeight}${cellHeightUnit}`);
            // content margins
            let top = this.opts.marginTop + this.opts.marginUnit;
            let bottom = this.opts.marginBottom + this.opts.marginUnit;
            let right = this.opts.marginRight + this.opts.marginUnit;
            let left = this.opts.marginLeft + this.opts.marginUnit;
            let content = `${prefix} > .grid-stack-item-content`;
            let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);
            // resize handles offset (to match margin)
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-n`, `top: ${top};`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-s`, `bottom: ${bottom}`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);
        }
        // now update the height specific fields
        maxH = maxH || this._styles._max;
        if (maxH > this._styles._max) {
            let getHeight = (rows) => (cellHeight * rows) + cellHeightUnit;
            for (let i = this._styles._max + 1; i <= maxH; i++) { // start at 1
                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix}[gs-y="${i}"]`, `top: ${getHeight(i)}`);
                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.addCSSRule(this._styles, `${prefix}[gs-h="${i + 1}"]`, `height: ${getHeight(i + 1)}`); // start at 2
            }
            this._styles._max = maxH;
        }
        return this;
    }
    /** @internal */
    _updateContainerHeight() {
        if (!this.engine || this.engine.batchMode)
            return this;
        const parent = this.parentGridItem;
        let row = this.getRow() + this._extraDragRow; // this checks for minRow already
        const cellHeight = this.opts.cellHeight;
        const unit = this.opts.cellHeightUnit;
        if (!cellHeight)
            return this;
        // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.
        if (!parent) {
            const cssMinHeight = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(getComputedStyle(this.el)['minHeight']);
            if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {
                const minRow = Math.floor(cssMinHeight.h / cellHeight);
                if (row < minRow) {
                    row = minRow;
                }
            }
        }
        this.el.setAttribute('gs-current-row', String(row));
        this.el.style.removeProperty('min-height');
        this.el.style.removeProperty('height');
        if (row) {
            // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars
            this.el.style[parent ? 'minHeight' : 'height'] = row * cellHeight + unit;
        }
        // if we're a nested grid inside an sizeToContent item, tell it to resize itself too
        if (parent && !parent.grid.engine.batchMode && _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(parent)) {
            parent.grid.resizeToContentCBCheck(parent.el);
        }
        return this;
    }
    /** @internal */
    _prepareElement(el, triggerAddEvent = false, node) {
        node = node || this._readAttr(el);
        el.gridstackNode = node;
        node.el = el;
        node.grid = this;
        node = this.engine.addNode(node, triggerAddEvent);
        // write the dom sizes and class
        this._writeAttr(el, node);
        el.classList.add(_types__WEBPACK_IMPORTED_MODULE_2__.gridDefaults.itemClass, this.opts.itemClass);
        const sizeToContent = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(node);
        sizeToContent ? el.classList.add('size-to-content') : el.classList.remove('size-to-content');
        if (sizeToContent)
            this.resizeToContentCheck(false, node);
        this._prepareDragDropByNode(node);
        return this;
    }
    /** @internal call to write position x,y,w,h attributes back to element */
    _writePosAttr(el, n) {
        if (n.x !== undefined && n.x !== null) {
            el.setAttribute('gs-x', String(n.x));
        }
        if (n.y !== undefined && n.y !== null) {
            el.setAttribute('gs-y', String(n.y));
        }
        n.w > 1 ? el.setAttribute('gs-w', String(n.w)) : el.removeAttribute('gs-w');
        n.h > 1 ? el.setAttribute('gs-h', String(n.h)) : el.removeAttribute('gs-h');
        return this;
    }
    /** @internal call to write any default attributes back to element */
    _writeAttr(el, node) {
        if (!node)
            return this;
        this._writePosAttr(el, node);
        let attrs /*: GridStackWidget but strings */ = {
            autoPosition: 'gs-auto-position',
            noResize: 'gs-no-resize',
            noMove: 'gs-no-move',
            locked: 'gs-locked',
            id: 'gs-id',
        };
        for (const key in attrs) {
            if (node[key]) { // 0 is valid for x,y only but done above already and not in list anyway
                el.setAttribute(attrs[key], String(node[key]));
            }
            else {
                el.removeAttribute(attrs[key]);
            }
        }
        return this;
    }
    /** @internal call to read any default attributes from element */
    _readAttr(el, clearDefaultAttr = true) {
        let n = {};
        n.x = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-x'));
        n.y = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-y'));
        n.w = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-w'));
        n.h = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-h'));
        n.autoPosition = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-auto-position'));
        n.noResize = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-no-resize'));
        n.noMove = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-no-move'));
        n.locked = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toBool(el.getAttribute('gs-locked'));
        n.id = el.getAttribute('gs-id');
        // read but never written out
        n.maxW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-max-w'));
        n.minW = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-min-w'));
        n.maxH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-max-h'));
        n.minH = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.toNumber(el.getAttribute('gs-min-h'));
        // v8.x optimization to reduce un-needed attr that don't render or are default CSS
        if (clearDefaultAttr) {
            if (n.w === 1)
                el.removeAttribute('gs-w');
            if (n.h === 1)
                el.removeAttribute('gs-h');
            if (n.maxW)
                el.removeAttribute('gs-max-w');
            if (n.minW)
                el.removeAttribute('gs-min-w');
            if (n.maxH)
                el.removeAttribute('gs-max-h');
            if (n.minH)
                el.removeAttribute('gs-min-h');
        }
        // remove any key not found (null or false which is default)
        for (const key in n) {
            if (!n.hasOwnProperty(key))
                return;
            if (!n[key] && n[key] !== 0) { // 0 can be valid value (x,y only really)
                delete n[key];
            }
        }
        return n;
    }
    /** @internal */
    _setStaticClass() {
        let classes = ['grid-stack-static'];
        if (this.opts.staticGrid) {
            this.el.classList.add(...classes);
            this.el.setAttribute('gs-static', 'true');
        }
        else {
            this.el.classList.remove(...classes);
            this.el.removeAttribute('gs-static');
        }
        return this;
    }
    /**
     * called when we are being resized - check if the one Column Mode needs to be turned on/off
     * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)
     * or `sizeToContent` gridItem options.
     */
    onResize() {
        if (!this.el?.clientWidth)
            return; // return if we're gone or no size yet (will get called again)
        if (this.prevWidth === this.el.clientWidth)
            return; // no-op
        this.prevWidth = this.el.clientWidth;
        // console.log('onResize ', this.el.clientWidth);
        this.batchUpdate();
        // see if we're nested and take our column count from our parent....
        let columnChanged = false;
        if (this._autoColumn && this.parentGridItem) {
            if (this.opts.column !== this.parentGridItem.w) {
                this.column(this.parentGridItem.w, 'none');
                columnChanged = true;
            }
        }
        else {
            // else check for dynamic column
            columnChanged = this.checkDynamicColumn();
        }
        // make the cells content square again
        if (this._isAutoCellHeight)
            this.cellHeight();
        // update any nested grids, or items size
        this.engine.nodes.forEach(n => {
            if (n.subGrid)
                n.subGrid.onResize();
        });
        if (!this._skipInitialResize)
            this.resizeToContentCheck(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)
        delete this._skipInitialResize;
        this.batchUpdate(false);
        return this;
    }
    /** resizes content for given node (or all) if shouldSizeToContent() is true */
    resizeToContentCheck(delay = false, n = undefined) {
        if (!this.engine)
            return; // we've been deleted in between!
        // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count
        // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?
        if (delay && this.hasAnimationCSS())
            return setTimeout(() => this.resizeToContentCheck(false, n), 300 + 10);
        if (n) {
            if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n))
                this.resizeToContentCBCheck(n.el);
        }
        else if (this.engine.nodes.some(n => _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n))) {
            const nodes = [...this.engine.nodes]; // in case order changes while resizing one
            this.batchUpdate();
            nodes.forEach(n => {
                if (_utils__WEBPACK_IMPORTED_MODULE_1__.Utils.shouldSizeToContent(n))
                    this.resizeToContentCBCheck(n.el);
            });
            this.batchUpdate(false);
        }
        // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize
        if (this._gsEventHandler['resizecontent'])
            this._gsEventHandler['resizecontent'](null, n ? [n] : this.engine.nodes);
    }
    /** add or remove the grid element size event handler */
    _updateResizeEvent(forceRemove = false) {
        // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting dynamic column (i.e. doing work)
        // or supporting new sizeToContent option.
        const trackSize = !this.parentGridItem && (this._isAutoCellHeight || this.opts.sizeToContent || this.opts.columnOpts
            || this.engine.nodes.find(n => n.sizeToContent));
        if (!forceRemove && trackSize && !this.resizeObserver) {
            this._sizeThrottle = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.throttle(() => this.onResize(), this.opts.cellHeightThrottle);
            this.resizeObserver = new ResizeObserver(() => this._sizeThrottle());
            this.resizeObserver.observe(this.el);
            this._skipInitialResize = true; // makeWidget will originally have called on startup
        }
        else if ((forceRemove || !trackSize) && this.resizeObserver) {
            this.resizeObserver.disconnect();
            delete this.resizeObserver;
            delete this._sizeThrottle;
        }
        return this;
    }
    /** @internal convert a potential selector into actual element */
    static getElement(els = '.grid-stack-item') { return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElement(els); }
    /** @internal */
    static getElements(els = '.grid-stack-item') { return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els); }
    /** @internal */
    static getGridElement(els) { return GridStack.getElement(els); }
    /** @internal */
    static getGridElements(els) { return _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(els); }
    /** @internal initialize margin top/bottom/left/right and units */
    _initMargin() {
        let data;
        let margin = 0;
        // support passing multiple values like CSS (ex: '5px 10px 0 20px')
        let margins = [];
        if (typeof this.opts.margin === 'string') {
            margins = this.opts.margin.split(' ');
        }
        if (margins.length === 2) { // top/bot, left/right like CSS
            this.opts.marginTop = this.opts.marginBottom = margins[0];
            this.opts.marginLeft = this.opts.marginRight = margins[1];
        }
        else if (margins.length === 4) { // Clockwise like CSS
            this.opts.marginTop = margins[0];
            this.opts.marginRight = margins[1];
            this.opts.marginBottom = margins[2];
            this.opts.marginLeft = margins[3];
        }
        else {
            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.margin);
            this.opts.marginUnit = data.unit;
            margin = this.opts.margin = data.h;
        }
        // see if top/bottom/left/right need to be set as well
        if (this.opts.marginTop === undefined) {
            this.opts.marginTop = margin;
        }
        else {
            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginTop);
            this.opts.marginTop = data.h;
            delete this.opts.margin;
        }
        if (this.opts.marginBottom === undefined) {
            this.opts.marginBottom = margin;
        }
        else {
            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginBottom);
            this.opts.marginBottom = data.h;
            delete this.opts.margin;
        }
        if (this.opts.marginRight === undefined) {
            this.opts.marginRight = margin;
        }
        else {
            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginRight);
            this.opts.marginRight = data.h;
            delete this.opts.margin;
        }
        if (this.opts.marginLeft === undefined) {
            this.opts.marginLeft = margin;
        }
        else {
            data = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.parseHeight(this.opts.marginLeft);
            this.opts.marginLeft = data.h;
            delete this.opts.margin;
        }
        this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...
        if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {
            this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()
        }
        return this;
    }
    /* ===========================================================================================
     * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts
     * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039
     * ===========================================================================================
     */
    /** get the global (but static to this code) DD implementation */
    static getDD() {
        return dd;
    }
    /**
     * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.
     * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar
     * is dynamically create and needs to be set later.
     * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements
     * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}
     * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)
     */
    static setupDragIn(dragIn, dragInOptions, root = document) {
        if (dragInOptions?.pause !== undefined) {
            _dd_manager__WEBPACK_IMPORTED_MODULE_5__.DDManager.pauseDrag = dragInOptions.pause;
        }
        dragInOptions = { ..._types__WEBPACK_IMPORTED_MODULE_2__.dragInDefaultOptions, ...(dragInOptions || {}) };
        let els = (typeof dragIn === 'string') ? _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getElements(dragIn, root) : dragIn;
        if (els.length)
            els?.forEach(el => {
                if (!dd.isDraggable(el))
                    dd.dragIn(el, dragInOptions);
            });
    }
    /**
     * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.
     * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.
     * @param els widget or selector to modify.
     * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.
     */
    movable(els, val) {
        if (this.opts.staticGrid)
            return this; // can't move a static grid!
        GridStack.getElements(els).forEach(el => {
            const n = el.gridstackNode;
            if (!n)
                return;
            val ? delete n.noMove : n.noMove = true;
            this._prepareDragDropByNode(n); // init DD if need be, and adjust
        });
        return this;
    }
    /**
     * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.
     * @param els  widget or selector to modify
     * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.
     */
    resizable(els, val) {
        if (this.opts.staticGrid)
            return this; // can't resize a static grid!
        GridStack.getElements(els).forEach(el => {
            let n = el.gridstackNode;
            if (!n)
                return;
            val ? delete n.noResize : n.noResize = true;
            this._prepareDragDropByNode(n); // init DD if need be, and adjust
        });
        return this;
    }
    /**
     * Temporarily disables widgets moving/resizing.
     * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.
     * Note: no-op for static grid
     * This is a shortcut for:
     * @example
     *  grid.enableMove(false);
     *  grid.enableResize(false);
     * @param recurse true (default) if sub-grids also get updated
     */
    disable(recurse = true) {
        if (this.opts.staticGrid)
            return;
        this.enableMove(false, recurse);
        this.enableResize(false, recurse);
        this._triggerEvent('disable');
        return this;
    }
    /**
     * Re-enables widgets moving/resizing - see disable().
     * Note: no-op for static grid.
     * This is a shortcut for:
     * @example
     *  grid.enableMove(true);
     *  grid.enableResize(true);
     * @param recurse true (default) if sub-grids also get updated
     */
    enable(recurse = true) {
        if (this.opts.staticGrid)
            return;
        this.enableMove(true, recurse);
        this.enableResize(true, recurse);
        this._triggerEvent('enable');
        return this;
    }
    /**
     * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule
     * @param recurse true (default) if sub-grids also get updated
     */
    enableMove(doEnable, recurse = true) {
        if (this.opts.staticGrid)
            return this; // can't move a static grid!
        doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658
        this.engine.nodes.forEach(n => {
            this._prepareDragDropByNode(n);
            if (n.subGrid && recurse)
                n.subGrid.enableMove(doEnable, recurse);
        });
        return this;
    }
    /**
     * Enables/disables widget resizing. No-op for static grids.
     * @param recurse true (default) if sub-grids also get updated
     */
    enableResize(doEnable, recurse = true) {
        if (this.opts.staticGrid)
            return this; // can't size a static grid!
        doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658
        this.engine.nodes.forEach(n => {
            this._prepareDragDropByNode(n);
            if (n.subGrid && recurse)
                n.subGrid.enableResize(doEnable, recurse);
        });
        return this;
    }
    /** @internal removes any drag&drop present (called during destroy) */
    _removeDD(el) {
        dd.draggable(el, 'destroy').resizable(el, 'destroy');
        if (el.gridstackNode) {
            delete el.gridstackNode._initDD; // reset our DD init flag
        }
        delete el.ddElement;
        return this;
    }
    /** @internal called to add drag over to support widgets being added externally */
    _setupAcceptWidget() {
        // check if we need to disable things
        if (this.opts.staticGrid || (!this.opts.acceptWidgets && !this.opts.removable)) {
            dd.droppable(this.el, 'destroy');
            return this;
        }
        // vars shared across all methods
        let cellHeight, cellWidth;
        let onDrag = (event, el, helper) => {
            let node = el.gridstackNode;
            if (!node)
                return;
            helper = helper || el;
            // if the element is being dragged from outside, scale it down to match the grid's scale
            // and slightly adjust its position relative to the mouse
            if (!node.grid?.el) {
                // this scales the helper down
                helper.style.transform = `scale(${1 / this.dragTransform.xScale},${1 / this.dragTransform.yScale})`;
                // this makes it so that the helper is well positioned relative to the mouse after scaling
                const helperRect = helper.getBoundingClientRect();
                helper.style.left = helperRect.x + (this.dragTransform.xScale - 1) * (event.clientX - helperRect.x) / this.dragTransform.xScale + 'px';
                helper.style.top = helperRect.y + (this.dragTransform.yScale - 1) * (event.clientY - helperRect.y) / this.dragTransform.yScale + 'px';
                helper.style.transformOrigin = `0px 0px`;
            }
            let parent = this.el.getBoundingClientRect();
            let { top, left } = helper.getBoundingClientRect();
            left -= parent.left;
            top -= parent.top;
            let ui = {
                position: {
                    top: top * this.dragTransform.xScale,
                    left: left * this.dragTransform.yScale
                }
            };
            if (node._temporaryRemoved) {
                node.x = Math.max(0, Math.round(left / cellWidth));
                node.y = Math.max(0, Math.round(top / cellHeight));
                delete node.autoPosition;
                this.engine.nodeBoundFix(node);
                // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere
                if (!this.engine.willItFit(node)) {
                    node.autoPosition = true; // ignore x,y and try for any slot...
                    if (!this.engine.willItFit(node)) {
                        dd.off(el, 'drag'); // stop calling us
                        return; // full grid or can't grow
                    }
                    if (node._willFitPos) {
                        // use the auto position instead #1687
                        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._willFitPos);
                        delete node._willFitPos;
                    }
                }
                // re-use the existing node dragging method
                this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);
            }
            else {
                // re-use the existing node dragging that does so much of the collision detection
                this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);
            }
        };
        dd.droppable(this.el, {
            accept: (el) => {
                let node = el.gridstackNode || this._readAttr(el, false);
                // set accept drop to true on ourself (which we ignore) so we don't get "can't drop" icon in HTML5 mode while moving
                if (node?.grid === this)
                    return true;
                if (!this.opts.acceptWidgets)
                    return false;
                // check for accept method or class matching
                let canAccept = true;
                if (typeof this.opts.acceptWidgets === 'function') {
                    canAccept = this.opts.acceptWidgets(el);
                }
                else {
                    let selector = (this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets);
                    canAccept = el.matches(selector);
                }
                // finally check to make sure we actually have space left #1571 #2633
                if (canAccept && node && this.opts.maxRow) {
                    let n = { w: node.w, h: node.h, minW: node.minW, minH: node.minH }; // only width/height matters and autoPosition
                    canAccept = this.engine.willItFit(n);
                }
                return canAccept;
            }
        })
            /**
             * entering our grid area
             */
            .on(this.el, 'dropover', (event, el, helper) => {
            // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST
            let node = el.gridstackNode;
            // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item
            if (node?.grid === this && !node._temporaryRemoved) {
                // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)
                return false; // prevent parent from receiving msg (which may be a grid as well)
            }
            // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now
            if (node?.grid && node.grid !== this && !node._temporaryRemoved) {
                // console.log('dropover without leave'); // TEST
                let otherGrid = node.grid;
                otherGrid._leave(el, helper);
            }
            // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...
            cellWidth = this.cellWidth();
            cellHeight = this.getCellHeight(true);
            // load any element attributes if we don't have a node
            if (!node) {
                node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354
            }
            if (!node.grid) {
                node._isExternal = true;
                el.gridstackNode = node;
            }
            // calculate the grid size based on element outer size
            helper = helper || el;
            let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;
            let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;
            // if the item came from another grid, make a copy and save the original info in case we go back there
            if (node.grid && node.grid !== this) {
                // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific
                // console.log('dropover cloning node'); // TEST
                if (!el._gridstackNodeOrig)
                    el._gridstackNodeOrig = node; // shouldn't have multiple nested!
                el.gridstackNode = node = { ...node, w, h, grid: this };
                delete node.x;
                delete node.y;
                this.engine.cleanupNode(node)
                    .nodeBoundFix(node);
                // restore some internal fields we need after clearing them all
                node._initDD =
                    node._isExternal = // DOM needs to be re-parented on a drop
                        node._temporaryRemoved = true; // so it can be inserted onDrag below
            }
            else {
                node.w = w;
                node.h = h;
                node._temporaryRemoved = true; // so we can insert it
            }
            // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)
            GridStack._itemRemoving(node.el, false);
            dd.on(el, 'drag', onDrag);
            // make sure this is called at least once when going fast #1578
            onDrag(event, el, helper);
            return false; // prevent parent from receiving msg (which may be a grid as well)
        })
            /**
             * Leaving our grid area...
             */
            .on(this.el, 'dropout', (event, el, helper) => {
            // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST
            let node = el.gridstackNode;
            if (!node)
                return false;
            // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)
            // so skip this one if we're not the active grid really..
            if (!node.grid || node.grid === this) {
                this._leave(el, helper);
                // if we were created as temporary nested grid, go back to before state
                if (this._isTemp) {
                    this.removeAsSubGrid(node);
                }
            }
            return false; // prevent parent from receiving msg (which may be grid as well)
        })
            /**
             * end - releasing the mouse
             */
            .on(this.el, 'drop', (event, el, helper) => {
            let node = el.gridstackNode;
            // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead
            if (node?.grid === this && !node._isExternal)
                return false;
            const wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419
            this.placeholder.remove();
            // disable animation when replacing a placeholder (already positioned) with actual content
            const noAnim = wasAdded && this.opts.animate;
            if (noAnim)
                this.setAnimation(false);
            // notify previous grid of removal
            // console.log('drop delete _gridstackNodeOrig') // TEST
            let origNode = el._gridstackNodeOrig;
            delete el._gridstackNodeOrig;
            if (wasAdded && origNode?.grid && origNode.grid !== this) {
                let oGrid = origNode.grid;
                oGrid.engine.removeNodeFromLayoutCache(origNode);
                oGrid.engine.removedNodes.push(origNode);
                oGrid._triggerRemoveEvent()._triggerChangeEvent();
                // if it's an empty sub-grid that got auto-created, nuke it
                if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {
                    oGrid.removeAsSubGrid();
                }
            }
            if (!node)
                return false;
            // use existing placeholder node as it's already in our list with drop location
            if (wasAdded) {
                this.engine.cleanupNode(node); // removes all internal _xyz values
                node.grid = this;
            }
            delete node.grid?._isTemp;
            dd.off(el, 'drag');
            // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)
            // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path
            if (helper !== el) {
                helper.remove();
                el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info
                if (wasAdded) {
                    el = el.cloneNode(true);
                }
            }
            else {
                el.remove(); // reduce flicker as we change depth here, and size further down
                this._removeDD(el);
            }
            if (!wasAdded)
                return false;
            el.gridstackNode = node;
            node.el = el;
            let subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present
            // @ts-ignore
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(el); // @ts-ignore
            this.el.appendChild(el); // @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)
            this._prepareElement(el, true, node);
            if (subGrid) {
                subGrid.parentGridItem = node;
                if (!subGrid.opts.styleInHead)
                    subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved
            }
            this._updateContainerHeight();
            this.engine.addedNodes.push(node); // @ts-ignore
            this._triggerAddEvent(); // @ts-ignore
            this._triggerChangeEvent();
            this.engine.endUpdate();
            if (this._gsEventHandler['dropped']) {
                this._gsEventHandler['dropped']({ ...event, type: 'dropped' }, origNode && origNode.grid ? origNode : undefined, node);
            }
            // delay adding animation back
            if (noAnim)
                this.setAnimation(this.opts.animate, true);
            return false; // prevent parent from receiving msg (which may be grid as well)
        });
        return this;
    }
    /** @internal mark item for removal */
    static _itemRemoving(el, remove) {
        const node = el ? el.gridstackNode : undefined;
        if (!node?.grid || el.classList.contains(node.grid.opts.removableOptions.decline))
            return;
        remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;
        remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');
    }
    /** @internal called to setup a trash drop zone if the user specifies it */
    _setupRemoveDrop() {
        if (typeof this.opts.removable !== 'string')
            return this;
        let trashEl = document.querySelector(this.opts.removable);
        if (!trashEl)
            return this;
        // only register ONE static drop-over/dropout callback for the 'trash', and it will
        // update the passed in item and parent grid because the '.trash' is a shared resource anyway,
        // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)
        if (!this.opts.staticGrid && !dd.isDroppable(trashEl)) {
            dd.droppable(trashEl, this.opts.removableOptions)
                .on(trashEl, 'dropover', (event, el) => GridStack._itemRemoving(el, true))
                .on(trashEl, 'dropout', (event, el) => GridStack._itemRemoving(el, false));
        }
        return this;
    }
    /** @internal prepares the element for drag&drop */
    _prepareDragDropByNode(node) {
        let el = node.el;
        const noMove = node.noMove || this.opts.disableDrag;
        const noResize = node.noResize || this.opts.disableResize;
        // check for disabled grid first
        if (this.opts.staticGrid || (noMove && noResize)) {
            if (node._initDD) {
                this._removeDD(el); // nukes everything instead of just disable, will add some styles back next
                delete node._initDD;
            }
            el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435
            return this;
        }
        if (!node._initDD) {
            // variables used/cashed between the 3 start/move/end methods, in addition to node passed above
            let cellWidth;
            let cellHeight;
            /** called when item starts moving/resizing */
            let onStartMoving = (event, ui) => {
                // trigger any 'dragstart' / 'resizestart' manually
                if (this._gsEventHandler[event.type]) {
                    this._gsEventHandler[event.type](event, event.target);
                }
                cellWidth = this.cellWidth();
                cellHeight = this.getCellHeight(true); // force pixels for calculations
                this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);
            };
            /** called when item is being dragged/resized */
            let dragOrResize = (event, ui) => {
                this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);
            };
            /** called when the item stops moving/resizing */
            let onEndMoving = (event) => {
                this.placeholder.remove();
                delete node._moving;
                delete node._event;
                delete node._lastTried;
                const widthChanged = node.w !== node._orig.w;
                // if the item has moved to another grid, we're done here
                let target = event.target;
                if (!target.gridstackNode || target.gridstackNode.grid !== this)
                    return;
                node.el = target;
                if (node._isAboutToRemove) {
                    let grid = el.gridstackNode.grid;
                    if (grid._gsEventHandler[event.type]) {
                        grid._gsEventHandler[event.type](event, target);
                    }
                    grid.engine.nodes.push(node); // temp add it back so we can proper remove it next
                    grid.removeWidget(el, true, true);
                }
                else {
                    _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.removePositioningStyles(target);
                    if (node._temporaryRemoved) {
                        // got removed - restore item back to before dragging position
                        _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.copyPos(node, node._orig); // @ts-ignore
                        this._writePosAttr(target, node);
                        this.engine.addNode(node);
                    }
                    else {
                        // move to new placeholder location
                        this._writePosAttr(target, node);
                    }
                    if (this._gsEventHandler[event.type]) {
                        this._gsEventHandler[event.type](event, target);
                    }
                }
                // @ts-ignore
                this._extraDragRow = 0; // @ts-ignore
                this._updateContainerHeight(); // @ts-ignore
                this._triggerChangeEvent();
                this.engine.endUpdate();
                if (event.type === 'resizestop') {
                    if (Number.isInteger(node.sizeToContent))
                        node.sizeToContent = node.h; // new soft limit
                    this.resizeToContentCheck(widthChanged, node); // wait for width animation if changed
                }
            };
            dd.draggable(el, {
                start: onStartMoving,
                stop: onEndMoving,
                drag: dragOrResize
            }).resizable(el, {
                start: onStartMoving,
                stop: onEndMoving,
                resize: dragOrResize
            });
            node._initDD = true; // we've set DD support now
        }
        // finally fine tune move vs resize by disabling any part...
        dd.draggable(el, noMove ? 'disable' : 'enable')
            .resizable(el, noResize ? 'disable' : 'enable');
        return this;
    }
    /** @internal handles actual drag/resize start */
    _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {
        this.engine.cleanNodes()
            .beginUpdate(node);
        // @ts-ignore
        this._writePosAttr(this.placeholder, node);
        this.el.appendChild(this.placeholder);
        this.placeholder.gridstackNode = node;
        // console.log('_onStartMoving placeholder') // TEST
        // if the element is inside a grid, it has already been scaled
        // we can use that as a scale reference
        if (node.grid?.el) {
            this.dragTransform = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getValuesFromTransformedElement(el);
        }
        // if the element is being dragged from outside (not from any grid)
        // we use the grid as the transformation reference, since the helper is not subject to transformation
        else if (this.placeholder && this.placeholder.closest('.grid-stack')) {
            const gridEl = this.placeholder.closest('.grid-stack');
            this.dragTransform = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.getValuesFromTransformedElement(gridEl);
        }
        // Fallback
        else {
            this.dragTransform = {
                xScale: 1,
                xOffset: 0,
                yScale: 1,
                yOffset: 0,
            };
        }
        node.el = this.placeholder;
        node._lastUiPosition = ui.position;
        node._prevYPix = ui.position.top;
        node._moving = (event.type === 'dragstart'); // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)
        delete node._lastTried;
        if (event.type === 'dropover' && node._temporaryRemoved) {
            // console.log('engine.addNode x=' + node.x); // TEST
            this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved
            node._moving = true; // AFTER, mark as moving object (wanted fix location before)
        }
        // set the min/max resize info taking into account the column count and position (so we don't resize outside the grid)
        this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);
        if (event.type === 'resizestart') {
            const colLeft = this.getColumn() - node.x;
            const rowLeft = (this.opts.maxRow || Number.MAX_SAFE_INTEGER) - node.y;
            dd.resizable(el, 'option', 'minWidth', cellWidth * Math.min(node.minW || 1, colLeft))
                .resizable(el, 'option', 'minHeight', cellHeight * Math.min(node.minH || 1, rowLeft))
                .resizable(el, 'option', 'maxWidth', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, colLeft))
                .resizable(el, 'option', 'maxWidthMoveLeft', cellWidth * Math.min(node.maxW || Number.MAX_SAFE_INTEGER, node.x + node.w))
                .resizable(el, 'option', 'maxHeight', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, rowLeft))
                .resizable(el, 'option', 'maxHeightMoveUp', cellHeight * Math.min(node.maxH || Number.MAX_SAFE_INTEGER, node.y + node.h));
        }
    }
    /** @internal handles actual drag/resize */
    _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {
        let p = { ...node._orig }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)
        let resizing;
        let mLeft = this.opts.marginLeft, mRight = this.opts.marginRight, mTop = this.opts.marginTop, mBottom = this.opts.marginBottom;
        // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855
        let mHeight = Math.round(cellHeight * 0.1), mWidth = Math.round(cellWidth * 0.1);
        mLeft = Math.min(mLeft, mWidth);
        mRight = Math.min(mRight, mWidth);
        mTop = Math.min(mTop, mHeight);
        mBottom = Math.min(mBottom, mHeight);
        if (event.type === 'drag') {
            if (node._temporaryRemoved)
                return; // handled by dropover
            let distance = ui.position.top - node._prevYPix;
            node._prevYPix = ui.position.top;
            if (this.opts.draggable.scroll !== false) {
                _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollPosition(el, ui.position, distance);
            }
            // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)
            let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);
            let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);
            p.x = Math.round(left / cellWidth);
            p.y = Math.round(top / cellHeight);
            // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others
            let prev = this._extraDragRow;
            if (this.engine.collide(node, p)) {
                let row = this.getRow();
                let extra = Math.max(0, (p.y + node.h) - row);
                if (this.opts.maxRow && row + extra > this.opts.maxRow) {
                    extra = Math.max(0, this.opts.maxRow - row);
                } // @ts-ignore
                this._extraDragRow = extra; // @ts-ignore
            }
            else
                this._extraDragRow = 0; // @ts-ignore
            if (this._extraDragRow !== prev)
                this._updateContainerHeight();
            if (node.x === p.x && node.y === p.y)
                return; // skip same
            // DON'T skip one we tried as we might have failed because of coverage <50% before
            // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;
        }
        else if (event.type === 'resize') {
            if (p.x < 0)
                return;
            // Scrolling page if needed
            _utils__WEBPACK_IMPORTED_MODULE_1__.Utils.updateScrollResize(event, el, cellHeight);
            // get new size
            p.w = Math.round((ui.size.width - mLeft) / cellWidth);
            p.h = Math.round((ui.size.height - mTop) / cellHeight);
            if (node.w === p.w && node.h === p.h)
                return;
            if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h)
                return; // skip one we tried (but failed)
            // if we size on left/top side this might move us, so get possible new position as well
            let left = ui.position.left + mLeft;
            let top = ui.position.top + mTop;
            p.x = Math.round(left / cellWidth);
            p.y = Math.round(top / cellHeight);
            resizing = true;
        }
        node._event = event;
        node._lastTried = p; // set as last tried (will nuke if we go there)
        let rect = {
            x: ui.position.left + mLeft,
            y: ui.position.top + mTop,
            w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,
            h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom
        };
        if (this.engine.moveNodeCheck(node, { ...p, cellWidth, cellHeight, rect, resizing })) {
            node._lastUiPosition = ui.position;
            this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);
            delete node._skipDown;
            if (resizing && node.subGrid)
                node.subGrid.onResize();
            this._extraDragRow = 0; // @ts-ignore
            this._updateContainerHeight();
            let target = event.target; // @ts-ignore
            this._writePosAttr(target, node);
            if (this._gsEventHandler[event.type]) {
                this._gsEventHandler[event.type](event, target);
            }
        }
    }
    /** @internal called when item leaving our area by either cursor dropout event
     * or shape is outside our boundaries. remove it from us, and mark temporary if this was
     * our item to start with else restore prev node values from prev grid it came from.
     */
    _leave(el, helper) {
        let node = el.gridstackNode;
        if (!node)
            return;
        helper = helper || el;
        // restore the scale of the helper on leave
        helper.style.transform = 'scale(1)';
        dd.off(el, 'drag'); // no need to track while being outside
        // this gets called when cursor leaves and shape is outside, so only do this once
        if (node._temporaryRemoved)
            return;
        node._temporaryRemoved = true;
        this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue
        node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged
        if (this.opts.removable === true) { // boolean vs a class string
            // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so
            GridStack._itemRemoving(el, true);
        }
        // finally if item originally came from another grid, but left us, restore things back to prev info
        if (el._gridstackNodeOrig) {
            // console.log('leave delete _gridstackNodeOrig') // TEST
            el.gridstackNode = el._gridstackNodeOrig;
            delete el._gridstackNodeOrig;
        }
        else if (node._isExternal) {
            // item came from outside (like a toolbar) so nuke any node info
            delete node.el;
            delete el.gridstackNode;
            // and restore all nodes back to original
            this.engine.restoreInitial();
        }
    }
    // legacy method removed
    commit() { (0,_utils__WEBPACK_IMPORTED_MODULE_1__.obsolete)(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2'); return this; }
}
/** parent class for sizing content. defaults to '.grid-stack-item-content' */
GridStack.resizeToContentParent = '.grid-stack-item-content';
/** scoping so users can call GridStack.Utils.sort() for example */
GridStack.Utils = _utils__WEBPACK_IMPORTED_MODULE_1__.Utils;
/** scoping so users can call new GridStack.Engine(12) for example */
GridStack.Engine = _gridstack_engine__WEBPACK_IMPORTED_MODULE_0__.GridStackEngine;
GridStack.GDRev = '10.3.1';

//# sourceMappingURL=gridstack.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/types.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/types.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dragInDefaultOptions: () => (/* binding */ dragInDefaultOptions),
/* harmony export */   gridDefaults: () => (/* binding */ gridDefaults)
/* harmony export */ });
/**
 * types.ts 10.3.1
 * Copyright (c) 2021 Alain Dumesny - see GridStack root license
 */
// default values for grid options - used during init and when saving out
const gridDefaults = {
    alwaysShowResizeHandle: 'mobile',
    animate: true,
    auto: true,
    cellHeight: 'auto',
    cellHeightThrottle: 100,
    cellHeightUnit: 'px',
    column: 12,
    draggable: { handle: '.grid-stack-item-content', appendTo: 'body', scroll: true },
    handle: '.grid-stack-item-content',
    itemClass: 'grid-stack-item',
    margin: 10,
    marginUnit: 'px',
    maxRow: 0,
    minRow: 0,
    placeholderClass: 'grid-stack-placeholder',
    placeholderText: '',
    removableOptions: { accept: 'grid-stack-item', decline: 'grid-stack-non-removable' },
    resizable: { handles: 'se' },
    rtl: 'auto',
    // **** same as not being set ****
    // disableDrag: false,
    // disableResize: false,
    // float: false,
    // handleClass: null,
    // removable: false,
    // staticGrid: false,
    // styleInHead: false,
    //removable
};
/** default dragIn options */
const dragInDefaultOptions = {
    handle: '.grid-stack-item-content',
    appendTo: 'body',
    // revert: 'invalid',
    // scroll: false,
};
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/gridstack/dist/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/gridstack/dist/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Utils: () => (/* binding */ Utils),
/* harmony export */   obsolete: () => (/* binding */ obsolete),
/* harmony export */   obsoleteAttr: () => (/* binding */ obsoleteAttr),
/* harmony export */   obsoleteOpts: () => (/* binding */ obsoleteOpts),
/* harmony export */   obsoleteOptsDel: () => (/* binding */ obsoleteOptsDel)
/* harmony export */ });
/**
 * utils.ts 10.3.1
 * Copyright (c) 2021 Alain Dumesny - see GridStack root license
 */
/** checks for obsolete method names */
// eslint-disable-next-line
function obsolete(self, f, oldName, newName, rev) {
    let wrapper = (...args) => {
        console.warn('gridstack.js: Function `' + oldName + '` is deprecated in ' + rev + ' and has been replaced ' +
            'with `' + newName + '`. It will be **removed** in a future release');
        return f.apply(self, args);
    };
    wrapper.prototype = f.prototype;
    return wrapper;
}
/** checks for obsolete grid options (can be used for any fields, but msg is about options) */
function obsoleteOpts(opts, oldName, newName, rev) {
    if (opts[oldName] !== undefined) {
        opts[newName] = opts[oldName];
        console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + ' and has been replaced with `' +
            newName + '`. It will be **removed** in a future release');
    }
}
/** checks for obsolete grid options which are gone */
function obsoleteOptsDel(opts, oldName, rev, info) {
    if (opts[oldName] !== undefined) {
        console.warn('gridstack.js: Option `' + oldName + '` is deprecated in ' + rev + info);
    }
}
/** checks for obsolete Jquery element attributes */
function obsoleteAttr(el, oldName, newName, rev) {
    let oldAttr = el.getAttribute(oldName);
    if (oldAttr !== null) {
        el.setAttribute(newName, oldAttr);
        console.warn('gridstack.js: attribute `' + oldName + '`=' + oldAttr + ' is deprecated on this object in ' + rev + ' and has been replaced with `' +
            newName + '`. It will be **removed** in a future release');
    }
}
/**
 * Utility methods
 */
class Utils {
    /** convert a potential selector into actual list of html elements. optional root which defaults to document (for shadow dom) */
    static getElements(els, root = document) {
        if (typeof els === 'string') {
            const doc = ('getElementById' in root) ? root : undefined;
            // Note: very common for people use to id='1,2,3' which is only legal as HTML5 id, but not CSS selectors
            // so if we start with a number, assume it's an id and just return that one item...
            // see https://github.com/gridstack/gridstack.js/issues/2234#issuecomment-1523796562
            if (doc && !isNaN(+els[0])) { // start with digit
                const el = doc.getElementById(els);
                return el ? [el] : [];
            }
            let list = root.querySelectorAll(els);
            if (!list.length && els[0] !== '.' && els[0] !== '#') {
                list = root.querySelectorAll('.' + els);
                if (!list.length) {
                    list = root.querySelectorAll('#' + els);
                }
            }
            return Array.from(list);
        }
        return [els];
    }
    /** convert a potential selector into actual single element. optional root which defaults to document (for shadow dom) */
    static getElement(els, root = document) {
        if (typeof els === 'string') {
            const doc = ('getElementById' in root) ? root : undefined;
            if (!els.length)
                return null;
            if (doc && els[0] === '#') {
                return doc.getElementById(els.substring(1));
            }
            if (els[0] === '#' || els[0] === '.' || els[0] === '[') {
                return root.querySelector(els);
            }
            // if we start with a digit, assume it's an id (error calling querySelector('#1')) as class are not valid CSS
            if (doc && !isNaN(+els[0])) { // start with digit
                return doc.getElementById(els);
            }
            // finally try string, then id, then class
            let el = root.querySelector(els);
            if (doc && !el) {
                el = doc.getElementById(els);
            }
            if (!el) {
                el = root.querySelector('.' + els);
            }
            return el;
        }
        return els;
    }
    /** true if we should resize to content. strict=true when only 'sizeToContent:true' and not a number which lets user adjust */
    static shouldSizeToContent(n, strict = false) {
        return n?.grid && (strict ?
            (n.sizeToContent === true || (n.grid.opts.sizeToContent === true && n.sizeToContent === undefined)) :
            (!!n.sizeToContent || (n.grid.opts.sizeToContent && n.sizeToContent !== false)));
    }
    /** returns true if a and b overlap */
    static isIntercepted(a, b) {
        return !(a.y >= b.y + b.h || a.y + a.h <= b.y || a.x + a.w <= b.x || a.x >= b.x + b.w);
    }
    /** returns true if a and b touch edges or corners */
    static isTouching(a, b) {
        return Utils.isIntercepted(a, { x: b.x - 0.5, y: b.y - 0.5, w: b.w + 1, h: b.h + 1 });
    }
    /** returns the area a and b overlap */
    static areaIntercept(a, b) {
        let x0 = (a.x > b.x) ? a.x : b.x;
        let x1 = (a.x + a.w < b.x + b.w) ? a.x + a.w : b.x + b.w;
        if (x1 <= x0)
            return 0; // no overlap
        let y0 = (a.y > b.y) ? a.y : b.y;
        let y1 = (a.y + a.h < b.y + b.h) ? a.y + a.h : b.y + b.h;
        if (y1 <= y0)
            return 0; // no overlap
        return (x1 - x0) * (y1 - y0);
    }
    /** returns the area */
    static area(a) {
        return a.w * a.h;
    }
    /**
     * Sorts array of nodes
     * @param nodes array to sort
     * @param dir 1 for ascending, -1 for descending (optional)
     **/
    static sort(nodes, dir = 1) {
        const und = 10000;
        return nodes.sort((a, b) => {
            let diffY = dir * ((a.y ?? und) - (b.y ?? und));
            if (diffY === 0)
                return dir * ((a.x ?? und) - (b.x ?? und));
            return diffY;
        });
    }
    /** find an item by id */
    static find(nodes, id) {
        return id ? nodes.find(n => n.id === id) : undefined;
    }
    /**
     * creates a style sheet with style id under given parent
     * @param id will set the 'gs-style-id' attribute to that id
     * @param parent to insert the stylesheet as first child,
     * if none supplied it will be appended to the document head instead.
     */
    static createStylesheet(id, parent, options) {
        let style = document.createElement('style');
        const nonce = options?.nonce;
        if (nonce)
            style.nonce = nonce;
        style.setAttribute('type', 'text/css');
        style.setAttribute('gs-style-id', id);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (style.styleSheet) { // TODO: only CSSImportRule have that and different beast ??
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            style.styleSheet.cssText = '';
        }
        else {
            style.appendChild(document.createTextNode('')); // WebKit hack
        }
        if (!parent) {
            // default to head
            parent = document.getElementsByTagName('head')[0];
            parent.appendChild(style);
        }
        else {
            parent.insertBefore(style, parent.firstChild);
        }
        return style.sheet;
    }
    /** removed the given stylesheet id */
    static removeStylesheet(id, parent) {
        const target = parent || document;
        let el = target.querySelector('STYLE[gs-style-id=' + id + ']');
        if (el && el.parentNode)
            el.remove();
    }
    /** inserts a CSS rule */
    static addCSSRule(sheet, selector, rules) {
        if (typeof sheet.addRule === 'function') {
            sheet.addRule(selector, rules);
        }
        else if (typeof sheet.insertRule === 'function') {
            sheet.insertRule(`${selector}{${rules}}`);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static toBool(v) {
        if (typeof v === 'boolean') {
            return v;
        }
        if (typeof v === 'string') {
            v = v.toLowerCase();
            return !(v === '' || v === 'no' || v === 'false' || v === '0');
        }
        return Boolean(v);
    }
    static toNumber(value) {
        return (value === null || value.length === 0) ? undefined : Number(value);
    }
    static parseHeight(val) {
        let h;
        let unit = 'px';
        if (typeof val === 'string') {
            if (val === 'auto' || val === '')
                h = 0;
            else {
                let match = val.match(/^(-[0-9]+\.[0-9]+|[0-9]*\.[0-9]+|-[0-9]+|[0-9]+)(px|em|rem|vh|vw|%|cm|mm)?$/);
                if (!match) {
                    throw new Error(`Invalid height val = ${val}`);
                }
                unit = match[2] || 'px';
                h = parseFloat(match[1]);
            }
        }
        else {
            h = val;
        }
        return { h, unit };
    }
    /** copies unset fields in target to use the given default sources values */
    // eslint-disable-next-line
    static defaults(target, ...sources) {
        sources.forEach(source => {
            for (const key in source) {
                if (!source.hasOwnProperty(key))
                    return;
                if (target[key] === null || target[key] === undefined) {
                    target[key] = source[key];
                }
                else if (typeof source[key] === 'object' && typeof target[key] === 'object') {
                    // property is an object, recursively add it's field over... #1373
                    this.defaults(target[key], source[key]);
                }
            }
        });
        return target;
    }
    /** given 2 objects return true if they have the same values. Checks for Object {} having same fields and values (just 1 level down) */
    static same(a, b) {
        if (typeof a !== 'object')
            return a == b;
        if (typeof a !== typeof b)
            return false;
        // else we have object, check just 1 level deep for being same things...
        if (Object.keys(a).length !== Object.keys(b).length)
            return false;
        for (const key in a) {
            if (a[key] !== b[key])
                return false;
        }
        return true;
    }
    /** copies over b size & position (GridStackPosition), and optionally min/max as well */
    static copyPos(a, b, doMinMax = false) {
        if (b.x !== undefined)
            a.x = b.x;
        if (b.y !== undefined)
            a.y = b.y;
        if (b.w !== undefined)
            a.w = b.w;
        if (b.h !== undefined)
            a.h = b.h;
        if (doMinMax) {
            if (b.minW)
                a.minW = b.minW;
            if (b.minH)
                a.minH = b.minH;
            if (b.maxW)
                a.maxW = b.maxW;
            if (b.maxH)
                a.maxH = b.maxH;
        }
        return a;
    }
    /** true if a and b has same size & position */
    static samePos(a, b) {
        return a && b && a.x === b.x && a.y === b.y && (a.w || 1) === (b.w || 1) && (a.h || 1) === (b.h || 1);
    }
    /** given a node, makes sure it's min/max are valid */
    static sanitizeMinMax(node) {
        // remove 0, undefine, null
        if (!node.minW) {
            delete node.minW;
        }
        if (!node.minH) {
            delete node.minH;
        }
        if (!node.maxW) {
            delete node.maxW;
        }
        if (!node.maxH) {
            delete node.maxH;
        }
    }
    /** removes field from the first object if same as the second objects (like diffing) and internal '_' for saving */
    static removeInternalAndSame(a, b) {
        if (typeof a !== 'object' || typeof b !== 'object')
            return;
        for (let key in a) {
            const aVal = a[key];
            const bVal = b[key];
            if (key[0] === '_' || aVal === bVal) {
                delete a[key];
            }
            else if (aVal && typeof aVal === 'object' && bVal !== undefined) {
                Utils.removeInternalAndSame(aVal, bVal);
                if (!Object.keys(aVal).length) {
                    delete a[key];
                }
            }
        }
    }
    /** removes internal fields '_' and default values for saving */
    static removeInternalForSave(n, removeEl = true) {
        for (let key in n) {
            if (key[0] === '_' || n[key] === null || n[key] === undefined)
                delete n[key];
        }
        delete n.grid;
        if (removeEl)
            delete n.el;
        // delete default values (will be re-created on read)
        if (!n.autoPosition)
            delete n.autoPosition;
        if (!n.noResize)
            delete n.noResize;
        if (!n.noMove)
            delete n.noMove;
        if (!n.locked)
            delete n.locked;
        if (n.w === 1 || n.w === n.minW)
            delete n.w;
        if (n.h === 1 || n.h === n.minH)
            delete n.h;
    }
    /** return the closest parent (or itself) matching the given class */
    // static closestUpByClass(el: HTMLElement, name: string): HTMLElement {
    //   while (el) {
    //     if (el.classList.contains(name)) return el;
    //     el = el.parentElement
    //   }
    //   return null;
    // }
    /** delay calling the given function for given delay, preventing new calls from happening while waiting */
    static throttle(func, delay) {
        let isWaiting = false;
        return (...args) => {
            if (!isWaiting) {
                isWaiting = true;
                setTimeout(() => { func(...args); isWaiting = false; }, delay);
            }
        };
    }
    static removePositioningStyles(el) {
        let style = el.style;
        if (style.position) {
            style.removeProperty('position');
        }
        if (style.left) {
            style.removeProperty('left');
        }
        if (style.top) {
            style.removeProperty('top');
        }
        if (style.width) {
            style.removeProperty('width');
        }
        if (style.height) {
            style.removeProperty('height');
        }
    }
    /** @internal returns the passed element if scrollable, else the closest parent that will, up to the entire document scrolling element */
    static getScrollElement(el) {
        if (!el)
            return document.scrollingElement || document.documentElement; // IE support
        const style = getComputedStyle(el);
        const overflowRegex = /(auto|scroll)/;
        if (overflowRegex.test(style.overflow + style.overflowY)) {
            return el;
        }
        else {
            return this.getScrollElement(el.parentElement);
        }
    }
    /** @internal */
    static updateScrollPosition(el, position, distance) {
        // is widget in view?
        let rect = el.getBoundingClientRect();
        let innerHeightOrClientHeight = (window.innerHeight || document.documentElement.clientHeight);
        if (rect.top < 0 ||
            rect.bottom > innerHeightOrClientHeight) {
            // set scrollTop of first parent that scrolls
            // if parent is larger than el, set as low as possible
            // to get entire widget on screen
            let offsetDiffDown = rect.bottom - innerHeightOrClientHeight;
            let offsetDiffUp = rect.top;
            let scrollEl = this.getScrollElement(el);
            if (scrollEl !== null) {
                let prevScroll = scrollEl.scrollTop;
                if (rect.top < 0 && distance < 0) {
                    // moving up
                    if (el.offsetHeight > innerHeightOrClientHeight) {
                        scrollEl.scrollTop += distance;
                    }
                    else {
                        scrollEl.scrollTop += Math.abs(offsetDiffUp) > Math.abs(distance) ? distance : offsetDiffUp;
                    }
                }
                else if (distance > 0) {
                    // moving down
                    if (el.offsetHeight > innerHeightOrClientHeight) {
                        scrollEl.scrollTop += distance;
                    }
                    else {
                        scrollEl.scrollTop += offsetDiffDown > distance ? distance : offsetDiffDown;
                    }
                }
                // move widget y by amount scrolled
                position.top += scrollEl.scrollTop - prevScroll;
            }
        }
    }
    /**
     * @internal Function used to scroll the page.
     *
     * @param event `MouseEvent` that triggers the resize
     * @param el `HTMLElement` that's being resized
     * @param distance Distance from the V edges to start scrolling
     */
    static updateScrollResize(event, el, distance) {
        const scrollEl = this.getScrollElement(el);
        const height = scrollEl.clientHeight;
        // #1727 event.clientY is relative to viewport, so must compare this against position of scrollEl getBoundingClientRect().top
        // #1745 Special situation if scrollEl is document 'html': here browser spec states that
        // clientHeight is height of viewport, but getBoundingClientRect() is rectangle of html element;
        // this discrepancy arises because in reality scrollbar is attached to viewport, not html element itself.
        const offsetTop = (scrollEl === this.getScrollElement()) ? 0 : scrollEl.getBoundingClientRect().top;
        const pointerPosY = event.clientY - offsetTop;
        const top = pointerPosY < distance;
        const bottom = pointerPosY > height - distance;
        if (top) {
            // This also can be done with a timeout to keep scrolling while the mouse is
            // in the scrolling zone. (will have smoother behavior)
            scrollEl.scrollBy({ behavior: 'smooth', top: pointerPosY - distance });
        }
        else if (bottom) {
            scrollEl.scrollBy({ behavior: 'smooth', top: distance - (height - pointerPosY) });
        }
    }
    /** single level clone, returning a new object with same top fields. This will share sub objects and arrays */
    static clone(obj) {
        if (obj === null || obj === undefined || typeof (obj) !== 'object') {
            return obj;
        }
        // return Object.assign({}, obj);
        if (obj instanceof Array) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return [...obj];
        }
        return { ...obj };
    }
    /**
     * Recursive clone version that returns a full copy, checking for nested objects and arrays ONLY.
     * Note: this will use as-is any key starting with double __ (and not copy inside) some lib have circular dependencies.
     */
    static cloneDeep(obj) {
        // list of fields we will skip during cloneDeep (nested objects, other internal)
        const skipFields = ['parentGrid', 'el', 'grid', 'subGrid', 'engine'];
        // return JSON.parse(JSON.stringify(obj)); // doesn't work with date format ?
        const ret = Utils.clone(obj);
        for (const key in ret) {
            // NOTE: we don't support function/circular dependencies so skip those properties for now...
            if (ret.hasOwnProperty(key) && typeof (ret[key]) === 'object' && key.substring(0, 2) !== '__' && !skipFields.find(k => k === key)) {
                ret[key] = Utils.cloneDeep(obj[key]);
            }
        }
        return ret;
    }
    /** deep clone the given HTML node, removing teh unique id field */
    static cloneNode(el) {
        const node = el.cloneNode(true);
        node.removeAttribute('id');
        return node;
    }
    static appendTo(el, parent) {
        let parentNode;
        if (typeof parent === 'string') {
            parentNode = Utils.getElement(parent);
        }
        else {
            parentNode = parent;
        }
        if (parentNode) {
            parentNode.appendChild(el);
        }
    }
    // public static setPositionRelative(el: HTMLElement): void {
    //   if (!(/^(?:r|a|f)/).test(getComputedStyle(el).position)) {
    //     el.style.position = "relative";
    //   }
    // }
    static addElStyles(el, styles) {
        if (styles instanceof Object) {
            for (const s in styles) {
                if (styles.hasOwnProperty(s)) {
                    if (Array.isArray(styles[s])) {
                        // support fallback value
                        styles[s].forEach(val => {
                            el.style[s] = val;
                        });
                    }
                    else {
                        el.style[s] = styles[s];
                    }
                }
            }
        }
    }
    static initEvent(e, info) {
        const evt = { type: info.type };
        const obj = {
            button: 0,
            which: 0,
            buttons: 1,
            bubbles: true,
            cancelable: true,
            target: info.target ? info.target : e.target
        };
        ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].forEach(p => evt[p] = e[p]); // keys
        ['pageX', 'pageY', 'clientX', 'clientY', 'screenX', 'screenY'].forEach(p => evt[p] = e[p]); // point info
        return { ...evt, ...obj };
    }
    /** copies the MouseEvent properties and sends it as another event to the given target */
    static simulateMouseEvent(e, simulatedType, target) {
        const simulatedEvent = document.createEvent('MouseEvents');
        simulatedEvent.initMouseEvent(simulatedType, // type
        true, // bubbles
        true, // cancelable
        window, // view
        1, // detail
        e.screenX, // screenX
        e.screenY, // screenY
        e.clientX, // clientX
        e.clientY, // clientY
        e.ctrlKey, // ctrlKey
        e.altKey, // altKey
        e.shiftKey, // shiftKey
        e.metaKey, // metaKey
        0, // button
        e.target // relatedTarget
        );
        (target || e.target).dispatchEvent(simulatedEvent);
    }
    /**
     * defines an element that is used to get the offset and scale from grid transforms
     * returns the scale and offsets from said element
    */
    static getValuesFromTransformedElement(parent) {
        const transformReference = document.createElement('div');
        Utils.addElStyles(transformReference, {
            opacity: '0',
            position: 'fixed',
            top: 0 + 'px',
            left: 0 + 'px',
            width: '1px',
            height: '1px',
            zIndex: '-999999',
        });
        parent.appendChild(transformReference);
        const transformValues = transformReference.getBoundingClientRect();
        parent.removeChild(transformReference);
        transformReference.remove();
        return {
            xScale: 1 / transformValues.width,
            yScale: 1 / transformValues.height,
            xOffset: transformValues.left,
            yOffset: transformValues.top,
        };
    }
    /** swap the given object 2 field values */
    static swap(o, a, b) {
        if (!o)
            return;
        const tmp = o[a];
        o[a] = o[b];
        o[b] = tmp;
    }
    /** returns true if event is inside the given element rectangle */
    // Note: Safari Mac has null event.relatedTarget which causes #1684 so check if DragEvent is inside the coordinates instead
    //    this.el.contains(event.relatedTarget as HTMLElement)
    // public static inside(e: MouseEvent, el: HTMLElement): boolean {
    //   // srcElement, toElement, target: all set to placeholder when leaving simple grid, so we can't use that (Chrome)
    //   let target: HTMLElement = e.relatedTarget || (e as any).fromElement;
    //   if (!target) {
    //     const { bottom, left, right, top } = el.getBoundingClientRect();
    //     return (e.x < right && e.x > left && e.y < bottom && e.y > top);
    //   }
    //   return el.contains(target);
    // }
    /** true if the item can be rotated (checking for prop, not space available) */
    static canBeRotated(n) {
        return !(!n || n.w === n.h || n.locked || n.noResize || n.grid?.opts.disableResize || (n.minW && n.minW === n.maxW) || (n.minH && n.minH === n.maxH));
    }
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "app":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.App = void 0;
    class App {
        constructor() {
            this.items = [
                { x: 0, y: 0, w: 2, h: 1, id: 11, resizeHandles: 'e' },
                { x: 1, y: 1, w: 2, h: 2, id: 22 },
                { x: 3, y: 2, w: 1, h: 2, id: 33 }
            ];
        }
    }
    exports.App = App;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "app.css":
/*!*********************!*\
  !*** ./src/app.css ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.grid-stack-item .item {
  border: 1px solid;
  border-radius: 5px;
  padding: 5px;
  height: 100%;
  box-sizing: border-box;
}
`, "",{"version":3,"sources":["webpack://./src/app.css"],"names":[],"mappings":"AAAA;EACE,iBAAiB;EACjB,kBAAkB;EAClB,YAAY;EACZ,YAAY;EACZ,sBAAsB;AACxB","sourcesContent":[".grid-stack-item .item {\n  border: 1px solid;\n  border-radius: 5px;\n  padding: 5px;\n  height: 100%;\n  box-sizing: border-box;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "app.html":
/*!**********************!*\
  !*** ./src/app.html ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Module
var code = `<template>
  <require from="gridstack/dist/gridstack.min.css"></require>
  <require from="./app.css"></require>
  <grid-stack min-row="5" float>
    <grid-stack-item repeat.for="i of items" x.bind="i.x" y.bind="i.y" w.bind="i.w" h.bind="i.h" id.bind="i.id"
      resize-handles.bind="i.resizeHandles">
      <div class="item">
        <div>Item \${\$index + 1}</div>
        <div>x: \${i.x}</div>
        <div>y: \${i.y}</div>
        <div>w: \${i.w}</div>
        <div>h: \${i.h}</div>
        <div>id: \${i.id}</div>
        <div>resizeHandles: \${i.resizeHandles}</div>
      </div>
    </grid-stack-item>
  </grid-stack>
</template>
`;
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (code);

/***/ }),

/***/ "aurelia-event-aggregator":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/aurelia-event-aggregator/dist/es2015/aurelia-event-aggregator.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventAggregator: () => (/* binding */ EventAggregator),
/* harmony export */   configure: () => (/* binding */ configure),
/* harmony export */   includeEventsIn: () => (/* binding */ includeEventsIn)
/* harmony export */ });
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");


const logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_0__.getLogger('event-aggregator');

let Handler = class Handler {
  constructor(messageType, callback) {
    this.messageType = messageType;
    this.callback = callback;
  }

  handle(message) {
    if (message instanceof this.messageType) {
      this.callback.call(null, message);
    }
  }
};


function invokeCallback(callback, data, event) {
  try {
    callback(data, event);
  } catch (e) {
    logger.error(e);
  }
}

function invokeHandler(handler, data) {
  try {
    handler.handle(data);
  } catch (e) {
    logger.error(e);
  }
}

let EventAggregator = class EventAggregator {
  constructor() {
    this.eventLookup = {};
    this.messageHandlers = [];
  }

  publish(event, data) {
    let subscribers;
    let i;

    if (!event) {
      throw new Error('Event was invalid.');
    }

    if (typeof event === 'string') {
      subscribers = this.eventLookup[event];
      if (subscribers) {
        subscribers = subscribers.slice();
        i = subscribers.length;

        while (i--) {
          invokeCallback(subscribers[i], data, event);
        }
      }
    } else {
      subscribers = this.messageHandlers.slice();
      i = subscribers.length;

      while (i--) {
        invokeHandler(subscribers[i], event);
      }
    }
  }

  subscribe(event, callback) {
    let handler;
    let subscribers;

    if (!event) {
      throw new Error('Event channel/type was invalid.');
    }

    if (typeof event === 'string') {
      handler = callback;
      subscribers = this.eventLookup[event] || (this.eventLookup[event] = []);
    } else {
      handler = new Handler(event, callback);
      subscribers = this.messageHandlers;
    }

    subscribers.push(handler);

    return {
      dispose() {
        let idx = subscribers.indexOf(handler);
        if (idx !== -1) {
          subscribers.splice(idx, 1);
        }
      }
    };
  }

  subscribeOnce(event, callback) {
    let sub = this.subscribe(event, (a, b) => {
      sub.dispose();
      return callback(a, b);
    });

    return sub;
  }
};

function includeEventsIn(obj) {
  let ea = new EventAggregator();

  obj.subscribeOnce = function (event, callback) {
    return ea.subscribeOnce(event, callback);
  };

  obj.subscribe = function (event, callback) {
    return ea.subscribe(event, callback);
  };

  obj.publish = function (event, data) {
    ea.publish(event, data);
  };

  return ea;
}

function configure(config) {
  config.instance(EventAggregator, includeEventsIn(config.aurelia));
}

/***/ }),

/***/ "aurelia-framework":
/*!*****************************************************************************!*\
  !*** ../../node_modules/aurelia-framework/dist/es2015/aurelia-framework.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AccessKeyed: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.AccessKeyed),
/* harmony export */   AccessMember: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.AccessMember),
/* harmony export */   AccessScope: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.AccessScope),
/* harmony export */   AccessThis: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.AccessThis),
/* harmony export */   AggregateError: () => (/* reexport safe */ aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.AggregateError),
/* harmony export */   All: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.All),
/* harmony export */   Animator: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.Animator),
/* harmony export */   Assign: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Assign),
/* harmony export */   Aurelia: () => (/* binding */ Aurelia),
/* harmony export */   BehaviorInstruction: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BehaviorInstruction),
/* harmony export */   BehaviorPropertyObserver: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BehaviorPropertyObserver),
/* harmony export */   Binary: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Binary),
/* harmony export */   BindableProperty: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BindableProperty),
/* harmony export */   Binding: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Binding),
/* harmony export */   BindingBehavior: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingBehavior),
/* harmony export */   BindingBehaviorResource: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingBehaviorResource),
/* harmony export */   BindingEngine: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingEngine),
/* harmony export */   BindingExpression: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingExpression),
/* harmony export */   BindingLanguage: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BindingLanguage),
/* harmony export */   BoundViewFactory: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BoundViewFactory),
/* harmony export */   Call: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Call),
/* harmony export */   CallExpression: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.CallExpression),
/* harmony export */   CallFunction: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.CallFunction),
/* harmony export */   CallMember: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.CallMember),
/* harmony export */   CallScope: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.CallScope),
/* harmony export */   CheckedObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.CheckedObserver),
/* harmony export */   ClassObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ClassObserver),
/* harmony export */   CollectionLengthObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.CollectionLengthObserver),
/* harmony export */   CompositionEngine: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionEngine),
/* harmony export */   CompositionTransaction: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionTransaction),
/* harmony export */   CompositionTransactionNotifier: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionTransactionNotifier),
/* harmony export */   CompositionTransactionOwnershipToken: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionTransactionOwnershipToken),
/* harmony export */   ComputedExpression: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ComputedExpression),
/* harmony export */   Conditional: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Conditional),
/* harmony export */   Container: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Container),
/* harmony export */   Controller: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.Controller),
/* harmony export */   ConventionalViewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ConventionalViewStrategy),
/* harmony export */   DOM: () => (/* reexport safe */ aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM),
/* harmony export */   DataAttributeObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.DataAttributeObserver),
/* harmony export */   DirtyCheckProperty: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.DirtyCheckProperty),
/* harmony export */   DirtyChecker: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.DirtyChecker),
/* harmony export */   ElementConfigResource: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ElementConfigResource),
/* harmony export */   ElementEvents: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ElementEvents),
/* harmony export */   EventManager: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.EventManager),
/* harmony export */   EventSubscriber: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.EventSubscriber),
/* harmony export */   Expression: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Expression),
/* harmony export */   ExpressionCloner: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ExpressionCloner),
/* harmony export */   ExpressionObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ExpressionObserver),
/* harmony export */   FEATURE: () => (/* reexport safe */ aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.FEATURE),
/* harmony export */   Factory: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Factory),
/* harmony export */   FactoryInvoker: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.FactoryInvoker),
/* harmony export */   FrameworkConfiguration: () => (/* binding */ FrameworkConfiguration),
/* harmony export */   HtmlBehaviorResource: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.HtmlBehaviorResource),
/* harmony export */   InlineViewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.InlineViewStrategy),
/* harmony export */   InvocationHandler: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.InvocationHandler),
/* harmony export */   Lazy: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Lazy),
/* harmony export */   Listener: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Listener),
/* harmony export */   ListenerExpression: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ListenerExpression),
/* harmony export */   LiteralArray: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.LiteralArray),
/* harmony export */   LiteralObject: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.LiteralObject),
/* harmony export */   LiteralPrimitive: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.LiteralPrimitive),
/* harmony export */   LiteralString: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.LiteralString),
/* harmony export */   LiteralTemplate: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.LiteralTemplate),
/* harmony export */   Loader: () => (/* reexport safe */ aurelia_loader__WEBPACK_IMPORTED_MODULE_4__.Loader),
/* harmony export */   LogManager: () => (/* reexport module object */ aurelia_logging__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   ModifyCollectionObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ModifyCollectionObserver),
/* harmony export */   ModuleAnalyzer: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ModuleAnalyzer),
/* harmony export */   NameExpression: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.NameExpression),
/* harmony export */   NewInstance: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.NewInstance),
/* harmony export */   NoViewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.NoViewStrategy),
/* harmony export */   ObjectObservationAdapter: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ObjectObservationAdapter),
/* harmony export */   ObserverLocator: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ObserverLocator),
/* harmony export */   Optional: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Optional),
/* harmony export */   Origin: () => (/* reexport safe */ aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.Origin),
/* harmony export */   PLATFORM: () => (/* reexport safe */ aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.PLATFORM),
/* harmony export */   Parent: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Parent),
/* harmony export */   Parser: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Parser),
/* harmony export */   ParserImplementation: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ParserImplementation),
/* harmony export */   PassThroughSlot: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.PassThroughSlot),
/* harmony export */   PrimitiveObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.PrimitiveObserver),
/* harmony export */   RelativeViewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.RelativeViewStrategy),
/* harmony export */   ResourceDescription: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ResourceDescription),
/* harmony export */   ResourceLoadContext: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ResourceLoadContext),
/* harmony export */   ResourceModule: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ResourceModule),
/* harmony export */   SVGAnalyzer: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.SVGAnalyzer),
/* harmony export */   SelectValueObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.SelectValueObserver),
/* harmony export */   SetterObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.SetterObserver),
/* harmony export */   ShadowDOM: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ShadowDOM),
/* harmony export */   ShadowSlot: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ShadowSlot),
/* harmony export */   SingletonRegistration: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.SingletonRegistration),
/* harmony export */   SlotCustomAttribute: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.SlotCustomAttribute),
/* harmony export */   StaticViewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.StaticViewStrategy),
/* harmony export */   Strategy: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Strategy),
/* harmony export */   StrategyResolver: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.StrategyResolver),
/* harmony export */   StyleObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.StyleObserver),
/* harmony export */   SwapStrategies: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.SwapStrategies),
/* harmony export */   TargetInstruction: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.TargetInstruction),
/* harmony export */   TaskQueue: () => (/* reexport safe */ aurelia_task_queue__WEBPACK_IMPORTED_MODULE_5__.TaskQueue),
/* harmony export */   TemplateDependency: () => (/* reexport safe */ aurelia_loader__WEBPACK_IMPORTED_MODULE_4__.TemplateDependency),
/* harmony export */   TemplateRegistryEntry: () => (/* reexport safe */ aurelia_loader__WEBPACK_IMPORTED_MODULE_4__.TemplateRegistryEntry),
/* harmony export */   TemplateRegistryViewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.TemplateRegistryViewStrategy),
/* harmony export */   TemplatingEngine: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.TemplatingEngine),
/* harmony export */   TransientRegistration: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.TransientRegistration),
/* harmony export */   Unary: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Unary),
/* harmony export */   Unparser: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Unparser),
/* harmony export */   ValueAttributeObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ValueAttributeObserver),
/* harmony export */   ValueConverter: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ValueConverter),
/* harmony export */   ValueConverterResource: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ValueConverterResource),
/* harmony export */   View: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.View),
/* harmony export */   ViewCompileInstruction: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewCompileInstruction),
/* harmony export */   ViewCompiler: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewCompiler),
/* harmony export */   ViewEngine: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewEngine),
/* harmony export */   ViewEngineHooksResource: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewEngineHooksResource),
/* harmony export */   ViewFactory: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewFactory),
/* harmony export */   ViewLocator: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewLocator),
/* harmony export */   ViewResources: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewResources),
/* harmony export */   ViewSlot: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot),
/* harmony export */   XLinkAttributeObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.XLinkAttributeObserver),
/* harmony export */   _emptyParameters: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__._emptyParameters),
/* harmony export */   _hyphenate: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__._hyphenate),
/* harmony export */   _isAllWhitespace: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__._isAllWhitespace),
/* harmony export */   all: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.all),
/* harmony export */   animationEvent: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.animationEvent),
/* harmony export */   autoinject: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.autoinject),
/* harmony export */   behavior: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.behavior),
/* harmony export */   bindable: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable),
/* harmony export */   bindingBehavior: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingBehavior),
/* harmony export */   bindingMode: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode),
/* harmony export */   buildQueryString: () => (/* reexport safe */ aurelia_path__WEBPACK_IMPORTED_MODULE_6__.buildQueryString),
/* harmony export */   calcSplices: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.calcSplices),
/* harmony export */   camelCase: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.camelCase),
/* harmony export */   child: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.child),
/* harmony export */   children: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.children),
/* harmony export */   cloneExpression: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.cloneExpression),
/* harmony export */   computedFrom: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.computedFrom),
/* harmony export */   connectBindingToSignal: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.connectBindingToSignal),
/* harmony export */   connectable: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.connectable),
/* harmony export */   containerless: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.containerless),
/* harmony export */   createComputedObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.createComputedObserver),
/* harmony export */   createOverrideContext: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.createOverrideContext),
/* harmony export */   createScopeForTest: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.createScopeForTest),
/* harmony export */   customAttribute: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute),
/* harmony export */   customElement: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customElement),
/* harmony export */   dataAttributeAccessor: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.dataAttributeAccessor),
/* harmony export */   declarePropertyDependencies: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.declarePropertyDependencies),
/* harmony export */   decorators: () => (/* reexport safe */ aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.decorators),
/* harmony export */   delegationStrategy: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.delegationStrategy),
/* harmony export */   deprecated: () => (/* reexport safe */ aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.deprecated),
/* harmony export */   disableConnectQueue: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.disableConnectQueue),
/* harmony export */   dynamicOptions: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.dynamicOptions),
/* harmony export */   elementConfig: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.elementConfig),
/* harmony export */   elements: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.elements),
/* harmony export */   enableConnectQueue: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.enableConnectQueue),
/* harmony export */   enqueueBindingConnect: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.enqueueBindingConnect),
/* harmony export */   factory: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.factory),
/* harmony export */   getArrayObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.getArrayObserver),
/* harmony export */   getChangeRecords: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.getChangeRecords),
/* harmony export */   getConnectQueueSize: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.getConnectQueueSize),
/* harmony export */   getContextFor: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.getContextFor),
/* harmony export */   getDecoratorDependencies: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.getDecoratorDependencies),
/* harmony export */   getMapObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.getMapObserver),
/* harmony export */   getSetObserver: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.getSetObserver),
/* harmony export */   hasDeclaredDependencies: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.hasDeclaredDependencies),
/* harmony export */   initializePAL: () => (/* reexport safe */ aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.initializePAL),
/* harmony export */   inject: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.inject),
/* harmony export */   inlineView: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.inlineView),
/* harmony export */   invokeAsFactory: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.invokeAsFactory),
/* harmony export */   invoker: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.invoker),
/* harmony export */   isInitialized: () => (/* reexport safe */ aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.isInitialized),
/* harmony export */   join: () => (/* reexport safe */ aurelia_path__WEBPACK_IMPORTED_MODULE_6__.join),
/* harmony export */   lazy: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.lazy),
/* harmony export */   mergeSplice: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.mergeSplice),
/* harmony export */   metadata: () => (/* reexport safe */ aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.metadata),
/* harmony export */   mixin: () => (/* reexport safe */ aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.mixin),
/* harmony export */   newInstance: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.newInstance),
/* harmony export */   noView: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.noView),
/* harmony export */   observable: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.observable),
/* harmony export */   optional: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.optional),
/* harmony export */   parent: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.parent),
/* harmony export */   parseQueryString: () => (/* reexport safe */ aurelia_path__WEBPACK_IMPORTED_MODULE_6__.parseQueryString),
/* harmony export */   presentationAttributes: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.presentationAttributes),
/* harmony export */   presentationElements: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.presentationElements),
/* harmony export */   processAttributes: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.processAttributes),
/* harmony export */   processContent: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.processContent),
/* harmony export */   projectArraySplices: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.projectArraySplices),
/* harmony export */   propertyAccessor: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.propertyAccessor),
/* harmony export */   protocol: () => (/* reexport safe */ aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__.protocol),
/* harmony export */   registration: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.registration),
/* harmony export */   relativeToFile: () => (/* reexport safe */ aurelia_path__WEBPACK_IMPORTED_MODULE_6__.relativeToFile),
/* harmony export */   reset: () => (/* reexport safe */ aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.reset),
/* harmony export */   resolver: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.resolver),
/* harmony export */   resource: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.resource),
/* harmony export */   setConnectQueueThreshold: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.setConnectQueueThreshold),
/* harmony export */   signalBindings: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.signalBindings),
/* harmony export */   singleton: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.singleton),
/* harmony export */   sourceContext: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.sourceContext),
/* harmony export */   subscriberCollection: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.subscriberCollection),
/* harmony export */   targetContext: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.targetContext),
/* harmony export */   templateController: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.templateController),
/* harmony export */   transient: () => (/* reexport safe */ aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.transient),
/* harmony export */   useShadowDOM: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useShadowDOM),
/* harmony export */   useView: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useView),
/* harmony export */   useViewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useViewStrategy),
/* harmony export */   validateBehaviorName: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.validateBehaviorName),
/* harmony export */   valueConverter: () => (/* reexport safe */ aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.valueConverter),
/* harmony export */   view: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.view),
/* harmony export */   viewEngineHooks: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.viewEngineHooks),
/* harmony export */   viewResources: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.viewResources),
/* harmony export */   viewStrategy: () => (/* reexport safe */ aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.viewStrategy)
/* harmony export */ });
/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-dependency-injection */ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js");
/* harmony import */ var aurelia_binding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-binding */ "../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-templating */ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js");
/* harmony import */ var aurelia_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-loader */ "../../node_modules/aurelia-loader/dist/es2015/aurelia-loader.js");
/* harmony import */ var aurelia_task_queue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! aurelia-task-queue */ "../../node_modules/aurelia-task-queue/dist/es2015/aurelia-task-queue.js");
/* harmony import */ var aurelia_path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! aurelia-path */ "../../node_modules/aurelia-path/dist/es2015/aurelia-path.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");
















const logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_8__.getLogger('aurelia');
const extPattern = /\.[^/.]+$/;
function runTasks(config, tasks) {
    let current;
    let next = () => {
        current = tasks.shift();
        if (current) {
            return Promise.resolve(current(config)).then(next);
        }
        return Promise.resolve();
    };
    return next();
}
function loadPlugin(fwConfig, loader, info) {
    logger.debug(`Loading plugin ${info.moduleId}.`);
    if (typeof info.moduleId === 'string') {
        fwConfig.resourcesRelativeTo = info.resourcesRelativeTo;
        let id = info.moduleId;
        if (info.resourcesRelativeTo.length > 1) {
            return loader.normalize(info.moduleId, info.resourcesRelativeTo[1])
                .then(normalizedId => _loadPlugin(normalizedId));
        }
        return _loadPlugin(id);
    }
    else if (typeof info.configure === 'function') {
        if (fwConfig.configuredPlugins.indexOf(info.configure) !== -1) {
            return Promise.resolve();
        }
        fwConfig.configuredPlugins.push(info.configure);
        return Promise.resolve(info.configure.call(null, fwConfig, info.config || {}));
    }
    throw new Error(invalidConfigMsg(info.moduleId || info.configure, 'plugin'));
    function _loadPlugin(moduleId) {
        return loader.loadModule(moduleId).then(m => {
            if ('configure' in m) {
                if (fwConfig.configuredPlugins.indexOf(m.configure) !== -1) {
                    return Promise.resolve();
                }
                return Promise.resolve(m.configure(fwConfig, info.config || {})).then(() => {
                    fwConfig.configuredPlugins.push(m.configure);
                    fwConfig.resourcesRelativeTo = null;
                    logger.debug(`Configured plugin ${info.moduleId}.`);
                });
            }
            fwConfig.resourcesRelativeTo = null;
            logger.debug(`Loaded plugin ${info.moduleId}.`);
        });
    }
}
function loadResources(aurelia, resourcesToLoad, appResources) {
    if (Object.keys(resourcesToLoad).length === 0) {
        return Promise.resolve();
    }
    let viewEngine = aurelia.container.get(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewEngine);
    return Promise.all(Object.keys(resourcesToLoad).map(n => _normalize(resourcesToLoad[n])))
        .then(loads => {
        let names = [];
        let importIds = [];
        loads.forEach(l => {
            names.push(undefined);
            importIds.push(l.importId);
        });
        return viewEngine.importViewResources(importIds, names, appResources);
    });
    function _normalize(load) {
        let moduleId = load.moduleId;
        let ext = getExt(moduleId);
        if (isOtherResource(moduleId)) {
            moduleId = removeExt(moduleId);
        }
        return aurelia.loader.normalize(moduleId, load.relativeTo)
            .then(normalized => {
            return {
                name: load.moduleId,
                importId: isOtherResource(load.moduleId) ? addOriginalExt(normalized, ext) : normalized
            };
        });
    }
    function isOtherResource(name) {
        let ext = getExt(name);
        if (!ext)
            return false;
        if (ext === '')
            return false;
        if (ext === '.js' || ext === '.ts')
            return false;
        return true;
    }
    function removeExt(name) {
        return name.replace(extPattern, '');
    }
    function addOriginalExt(normalized, ext) {
        return removeExt(normalized) + '.' + ext;
    }
}
function getExt(name) {
    let match = name.match(extPattern);
    if (match && match.length > 0) {
        return (match[0].split('.'))[1];
    }
}
function loadBehaviors(config) {
    return Promise.all(config.behaviorsToLoad.map(m => m.load(config.container, m.target))).then(() => {
        config.behaviorsToLoad = null;
    });
}
function assertProcessed(plugins) {
    if (plugins.processed) {
        throw new Error('This config instance has already been applied. To load more plugins or global resources, create a new FrameworkConfiguration instance.');
    }
}
function invalidConfigMsg(cfg, type) {
    return `Invalid ${type} [${cfg}], ${type} must be specified as functions or relative module IDs.`;
}
class FrameworkConfiguration {
    constructor(aurelia) {
        this.aurelia = aurelia;
        this.container = aurelia.container;
        this.info = [];
        this.processed = false;
        this.preTasks = [];
        this.postTasks = [];
        this.behaviorsToLoad = [];
        this.configuredPlugins = [];
        this.resourcesToLoad = {};
        this.preTask(() => aurelia.loader.normalize('aurelia-bootstrapper', undefined)
            .then(name => this.bootstrapperName = name));
        this.postTask(() => loadResources(aurelia, this.resourcesToLoad, aurelia.resources));
    }
    instance(type, instance) {
        this.container.registerInstance(type, instance);
        return this;
    }
    singleton(type, implementation) {
        this.container.registerSingleton(type, implementation);
        return this;
    }
    transient(type, implementation) {
        this.container.registerTransient(type, implementation);
        return this;
    }
    preTask(task) {
        assertProcessed(this);
        this.preTasks.push(task);
        return this;
    }
    postTask(task) {
        assertProcessed(this);
        this.postTasks.push(task);
        return this;
    }
    feature(plugin, config = {}) {
        switch (typeof plugin) {
            case 'string':
                let hasIndex = /\/index$/i.test(plugin);
                let moduleId = hasIndex || getExt(plugin) ? plugin : plugin + '/index';
                let root = hasIndex ? plugin.slice(0, -6) : plugin;
                this.info.push({ moduleId, resourcesRelativeTo: [root, ''], config });
                break;
            case 'function':
                this.info.push({ configure: plugin, config: config || {} });
                break;
            default:
                throw new Error(invalidConfigMsg(plugin, 'feature'));
        }
        return this;
    }
    globalResources(resources) {
        assertProcessed(this);
        let toAdd = Array.isArray(resources) ? resources : arguments;
        let resource;
        let resourcesRelativeTo = this.resourcesRelativeTo || ['', ''];
        for (let i = 0, ii = toAdd.length; i < ii; ++i) {
            resource = toAdd[i];
            switch (typeof resource) {
                case 'string':
                    let parent = resourcesRelativeTo[0];
                    let grandParent = resourcesRelativeTo[1];
                    let name = resource;
                    if ((resource.startsWith('./') || resource.startsWith('../')) && parent !== '') {
                        name = (0,aurelia_path__WEBPACK_IMPORTED_MODULE_6__.join)(parent, resource);
                    }
                    this.resourcesToLoad[name] = { moduleId: name, relativeTo: grandParent };
                    break;
                case 'function':
                    let meta = this.aurelia.resources.autoRegister(this.container, resource);
                    if (meta instanceof aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.HtmlBehaviorResource && meta.elementName !== null) {
                        if (this.behaviorsToLoad.push(meta) === 1) {
                            this.postTask(() => loadBehaviors(this));
                        }
                    }
                    break;
                default:
                    throw new Error(invalidConfigMsg(resource, 'resource'));
            }
        }
        return this;
    }
    globalName(resourcePath, newName) {
        assertProcessed(this);
        this.resourcesToLoad[resourcePath] = { moduleId: newName, relativeTo: '' };
        return this;
    }
    plugin(plugin, pluginConfig) {
        assertProcessed(this);
        let info;
        switch (typeof plugin) {
            case 'string':
                info = { moduleId: plugin, resourcesRelativeTo: [plugin, ''], config: pluginConfig || {} };
                break;
            case 'function':
                info = { configure: plugin, config: pluginConfig || {} };
                break;
            default:
                throw new Error(invalidConfigMsg(plugin, 'plugin'));
        }
        this.info.push(info);
        return this;
    }
    _addNormalizedPlugin(name, config) {
        let plugin = { moduleId: name, resourcesRelativeTo: [name, ''], config: config || {} };
        this.info.push(plugin);
        this.preTask(() => {
            let relativeTo = [name, this.bootstrapperName];
            plugin.moduleId = name;
            plugin.resourcesRelativeTo = relativeTo;
            return Promise.resolve();
        });
        return this;
    }
    defaultBindingLanguage() {
        return this._addNormalizedPlugin('aurelia-templating-binding');
    }
    router() {
        return this._addNormalizedPlugin('aurelia-templating-router');
    }
    history() {
        return this._addNormalizedPlugin('aurelia-history-browser');
    }
    defaultResources() {
        return this._addNormalizedPlugin('aurelia-templating-resources');
    }
    eventAggregator() {
        return this._addNormalizedPlugin('aurelia-event-aggregator');
    }
    basicConfiguration() {
        return this.defaultBindingLanguage().defaultResources().eventAggregator();
    }
    standardConfiguration() {
        return this.basicConfiguration().history().router();
    }
    developmentLogging(level) {
        let logLevel = level ? aurelia_logging__WEBPACK_IMPORTED_MODULE_8__.logLevel[level] : undefined;
        if (logLevel === undefined) {
            logLevel = aurelia_logging__WEBPACK_IMPORTED_MODULE_8__.logLevel.debug;
        }
        this.preTask(() => {
            return this.aurelia.loader.normalize('aurelia-logging-console', this.bootstrapperName).then(name => {
                return this.aurelia.loader.loadModule(name).then(m => {
                    aurelia_logging__WEBPACK_IMPORTED_MODULE_8__.addAppender(new m.ConsoleAppender());
                    aurelia_logging__WEBPACK_IMPORTED_MODULE_8__.setLevel(logLevel);
                });
            });
        });
        return this;
    }
    apply() {
        if (this.processed) {
            return Promise.resolve();
        }
        return runTasks(this, this.preTasks).then(() => {
            let loader = this.aurelia.loader;
            let info = this.info;
            let current;
            let next = () => {
                current = info.shift();
                if (current) {
                    return loadPlugin(this, loader, current).then(next);
                }
                this.processed = true;
                this.configuredPlugins = null;
                return Promise.resolve();
            };
            return next().then(() => runTasks(this, this.postTasks));
        });
    }
}

function preventActionlessFormSubmit() {
    aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.addEventListener('submit', evt => {
        const target = evt.target;
        const action = target.action;
        if (target.tagName.toLowerCase() === 'form' && !action) {
            evt.preventDefault();
        }
    }, false);
}
class Aurelia {
    constructor(loader, container, resources) {
        this.loader = loader || new aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.PLATFORM.Loader();
        this.container = container || (new aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Container()).makeGlobal();
        this.resources = resources || new aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewResources();
        this.use = new FrameworkConfiguration(this);
        this.logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_8__.getLogger('aurelia');
        this.hostConfigured = false;
        this.host = null;
        this.use.instance(Aurelia, this);
        this.use.instance(aurelia_loader__WEBPACK_IMPORTED_MODULE_4__.Loader, this.loader);
        this.use.instance(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewResources, this.resources);
    }
    start() {
        if (this._started) {
            return this._started;
        }
        this.logger.info('Aurelia Starting');
        return this._started = this.use.apply().then(() => {
            preventActionlessFormSubmit();
            if (!this.container.hasResolver(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BindingLanguage)) {
                let message = 'You must configure Aurelia with a BindingLanguage implementation.';
                this.logger.error(message);
                throw new Error(message);
            }
            this.logger.info('Aurelia Started');
            let evt = aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.createCustomEvent('aurelia-started', { bubbles: true, cancelable: true });
            aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.dispatchEvent(evt);
            return this;
        });
    }
    enhance(bindingContext = {}, applicationHost = null) {
        this._configureHost(applicationHost || aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.querySelectorAll('body')[0]);
        return new Promise(resolve => {
            let engine = this.container.get(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.TemplatingEngine);
            this.root = engine.enhance({ container: this.container, element: this.host, resources: this.resources, bindingContext: bindingContext });
            this.root.attached();
            this._onAureliaComposed();
            resolve(this);
        });
    }
    setRoot(root = null, applicationHost = null) {
        let instruction = {};
        if (this.root && this.root.viewModel && this.root.viewModel.router) {
            this.root.viewModel.router.deactivate();
            this.root.viewModel.router.reset();
        }
        this._configureHost(applicationHost);
        let engine = this.container.get(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.TemplatingEngine);
        let transaction = this.container.get(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionTransaction);
        delete transaction.initialComposition;
        if (!root) {
            if (this.configModuleId) {
                root = (0,aurelia_path__WEBPACK_IMPORTED_MODULE_6__.relativeToFile)('./app', this.configModuleId);
            }
            else {
                root = 'app';
            }
        }
        instruction.viewModel = root;
        instruction.container = instruction.childContainer = this.container;
        instruction.viewSlot = this.hostSlot;
        instruction.host = this.host;
        return engine.compose(instruction).then((r) => {
            this.root = r;
            instruction.viewSlot.attached();
            this._onAureliaComposed();
            return this;
        });
    }
    _configureHost(applicationHost) {
        if (this.hostConfigured) {
            return;
        }
        applicationHost = applicationHost || this.host;
        if (!applicationHost || typeof applicationHost === 'string') {
            this.host = aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.getElementById(applicationHost || 'applicationHost');
        }
        else {
            this.host = applicationHost;
        }
        if (!this.host) {
            throw new Error('No applicationHost was specified.');
        }
        this.hostConfigured = true;
        this.host.aurelia = this;
        this.hostSlot = new aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot(this.host, true);
        this.hostSlot.transformChildNodesIntoView();
        this.container.registerInstance(aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.boundary, this.host);
    }
    _onAureliaComposed() {
        let evt = aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.createCustomEvent('aurelia-composed', { bubbles: true, cancelable: true });
        setTimeout(() => aurelia_pal__WEBPACK_IMPORTED_MODULE_7__.DOM.dispatchEvent(evt), 1);
    }
}


//# sourceMappingURL=aurelia-framework.js.map


/***/ }),

/***/ "aurelia-gridstack":
/*!*****************************************!*\
  !*** ../aurelia-gridstack/src/index.ts ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! aurelia-framework */ "aurelia-framework"), __webpack_require__(/*! ./elements/grid-stack/grid-stack */ "aurelia-gridstack/elements/grid-stack/grid-stack"), __webpack_require__(/*! ./elements/grid-stack-item/grid-stack-item */ "aurelia-gridstack/elements/grid-stack-item/grid-stack-item")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, aurelia_framework_1, grid_stack_1, grid_stack_item_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.GridStackItem = exports.GridStack = void 0;
    exports.configure = configure;
    function configure(aurelia) {
        aurelia.globalResources([
            './elements/grid-stack/grid-stack',
            './elements/grid-stack-item/grid-stack-item'
        ]);
    }
    Object.defineProperty(exports, "GridStack", ({ enumerable: true, get: function () { return grid_stack_1.GridStack; } }));
    Object.defineProperty(exports, "GridStackItem", ({ enumerable: true, get: function () { return grid_stack_item_1.GridStackItem; } }));
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "aurelia-gridstack/elements/grid-stack-item/grid-stack-item":
/*!****************************************************************************!*\
  !*** ../aurelia-gridstack/src/elements/grid-stack-item/grid-stack-item.ts ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs"), __webpack_require__(/*! aurelia-binding */ "../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js"), __webpack_require__(/*! aurelia-dependency-injection */ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js"), __webpack_require__(/*! ../../utils */ "../aurelia-gridstack/src/utils.ts"), __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js"), __webpack_require__(/*! aurelia-templating */ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js"), __webpack_require__(/*! aurelia-typed-observable-plugin */ "../../node_modules/aurelia-typed-observable-plugin/dist/es2015/index.js"), __webpack_require__(/*! ../grid-stack/grid-stack */ "aurelia-gridstack/elements/grid-stack/grid-stack")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, tslib_1, aurelia_binding_1, aurelia_dependency_injection_1, utils_1, aurelia_pal_1, aurelia_templating_1, aurelia_typed_observable_plugin_1, grid_stack_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.GridStackItem = void 0;
    let GridStackItem = class GridStackItem {
        constructor(root, gridstack) {
            this.root = root;
            this.gridstack = gridstack;
            this.suppressGridUpdate = false;
        }
        xChanged() {
            var _a;
            if (this.x !== undefined) {
                this.root.setAttribute('gs-x', this.x.toString());
            }
            else {
                this.root.removeAttribute('gs-x');
            }
            if (!this.suppressGridUpdate) {
                (_a = this.gridstack.grid) === null || _a === void 0 ? void 0 : _a.update(this.root, { x: this.x });
            }
        }
        yChanged() {
            var _a;
            if (this.y !== undefined) {
                this.root.setAttribute('gs-y', this.y.toString());
            }
            else {
                this.root.removeAttribute('gs-y');
            }
            if (!this.suppressGridUpdate) {
                (_a = this.gridstack.grid) === null || _a === void 0 ? void 0 : _a.update(this.root, { y: this.y });
            }
        }
        wChanged() {
            var _a;
            if (this.w !== undefined) {
                this.root.setAttribute('gs-w', this.w.toString());
            }
            else {
                this.root.removeAttribute('gs-w');
            }
            if (!this.suppressGridUpdate) {
                (_a = this.gridstack.grid) === null || _a === void 0 ? void 0 : _a.update(this.root, { w: this.w });
            }
        }
        hChanged() {
            var _a;
            if (this.h !== undefined) {
                this.root.setAttribute('gs-h', this.h.toString());
            }
            else {
                this.root.removeAttribute('gs-h');
            }
            if (!this.suppressGridUpdate) {
                (_a = this.gridstack.grid) === null || _a === void 0 ? void 0 : _a.update(this.root, { h: this.h });
            }
        }
        minWChanged() {
            if (this.minW !== undefined) {
                this.root.setAttribute('gs-min-w', this.minW.toString());
            }
            else {
                this.root.removeAttribute('gs-min-w');
            }
        }
        minHChanged() {
            if (this.minH !== undefined) {
                this.root.setAttribute('gs-min-h', this.minH.toString());
            }
            else {
                this.root.removeAttribute('gs-min-h');
            }
        }
        maxWChanged() {
            if (this.maxW !== undefined) {
                this.root.setAttribute('gs-max-w', this.maxW.toString());
            }
            else {
                this.root.removeAttribute('gs-max-w');
            }
        }
        maxHChanged() {
            if (this.maxH !== undefined) {
                this.root.setAttribute('gs-max-h', this.maxH.toString());
            }
            else {
                this.root.removeAttribute('gs-max-h');
            }
        }
        idChanged() {
            if (this.id !== undefined) {
                this.root.setAttribute('gs-id', this.id.toString());
            }
            else {
                this.root.removeAttribute('gs-id');
            }
        }
        noMoveChanged() {
            if (this.noMove) {
                this.root.setAttribute('gs-no-move', 'true');
            }
            else {
                this.root.removeAttribute('gs-no-move');
            }
        }
        noResizeChanged() {
            if (this.noResize) {
                this.root.setAttribute('gs-no-resize', 'true');
            }
            else {
                this.root.removeAttribute('gs-no-resize');
            }
        }
        lockedChanged() {
            if (this.locked) {
                this.root.setAttribute('gs-locked', 'true');
            }
            else {
                this.root.removeAttribute('gs-locked');
            }
        }
        autoPositionChanged() {
            if (this.autoPosition) {
                this.root.setAttribute('gs-auto-position', 'true');
            }
            else {
                this.root.removeAttribute('gs-auto-position');
            }
        }
        resizeHandlesChanged() {
            if (this.resizeHandles !== undefined) {
                const filteredHandles = (0, utils_1.getResizeHandleTypesOnly)(this.resizeHandles);
                this.root.setAttribute('gs-resize-handles', filteredHandles.toString());
            }
            else {
                this.root.removeAttribute('gs-resize-handles');
            }
        }
        beginSuppressUpdate() {
            this.suppressGridUpdate = true;
        }
        endSuppressUpdate() {
            this.suppressGridUpdate = false;
        }
    };
    exports.GridStackItem = GridStackItem;
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "x", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "y", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "w", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "h", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "minW", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "minH", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "maxW", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "maxH", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number({ defaultBindingMode: aurelia_binding_1.bindingMode.twoWay }),
        tslib_1.__metadata("design:type", Number)
    ], GridStackItem.prototype, "id", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.booleanAttr,
        tslib_1.__metadata("design:type", Boolean)
    ], GridStackItem.prototype, "noMove", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.booleanAttr,
        tslib_1.__metadata("design:type", Boolean)
    ], GridStackItem.prototype, "noResize", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.booleanAttr,
        tslib_1.__metadata("design:type", Boolean)
    ], GridStackItem.prototype, "locked", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.booleanAttr,
        tslib_1.__metadata("design:type", Boolean)
    ], GridStackItem.prototype, "autoPosition", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.string,
        tslib_1.__metadata("design:type", String)
    ], GridStackItem.prototype, "resizeHandles", void 0);
    exports.GridStackItem = GridStackItem = tslib_1.__decorate([
        (0, aurelia_dependency_injection_1.inject)(Element, grid_stack_1.GridStack),
        (0, aurelia_templating_1.customElement)('grid-stack-item'),
        (0, aurelia_templating_1.useView)('./grid-stack-item.html'),
        tslib_1.__metadata("design:paramtypes", [Object, grid_stack_1.GridStack])
    ], GridStackItem);
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "aurelia-gridstack/elements/grid-stack-item/grid-stack-item.html":
/*!******************************************************************************!*\
  !*** ../aurelia-gridstack/src/elements/grid-stack-item/grid-stack-item.html ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Module
var code = `<template class="grid-stack-item" style="display: block;">
  <div class="grid-stack-item-content">
    <slot></slot>
  </div>
</template>
`;
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (code);

/***/ }),

/***/ "aurelia-gridstack/elements/grid-stack/grid-stack":
/*!******************************************************************!*\
  !*** ../aurelia-gridstack/src/elements/grid-stack/grid-stack.ts ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs"), __webpack_require__(/*! aurelia-dependency-injection */ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js"), __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js"), __webpack_require__(/*! aurelia-templating */ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js"), __webpack_require__(/*! aurelia-typed-observable-plugin */ "../../node_modules/aurelia-typed-observable-plugin/dist/es2015/index.js"), __webpack_require__(/*! gridstack */ "./node_modules/gridstack/dist/gridstack.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, tslib_1, aurelia_dependency_injection_1, aurelia_pal_1, aurelia_templating_1, aurelia_typed_observable_plugin_1, gs) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.GridStack = void 0;
    gs = tslib_1.__importStar(gs);
    let GridStack = class GridStack {
        constructor(root) {
            this.root = root;
        }
        minRowChanged() {
            this.root.setAttribute('gs-min-row', this.minRow.toString());
        }
        floatChanged() {
            var _a;
            (_a = this.grid) === null || _a === void 0 ? void 0 : _a.float(this.getFloat());
        }
        getFloat() {
            return this.float || this.float === '' ? true : false;
        }
        staticChanged() {
            var _a;
            (_a = this.grid) === null || _a === void 0 ? void 0 : _a.setStatic(this.getStatic());
        }
        getStatic() {
            return this.static || this.static === '' ? true : false;
        }
        itemsChanged() {
            if (!this.grid || !this.items) {
                return;
            }
            const removed = this.grid.engine.nodes.filter(x => !this.items.find(y => y.root === x.el));
            removed.forEach(x => this.grid.engine.removeNode(x, false, false));
            const newItems = this.items.map(x => x.root).filter(x => !x.gridstackNode);
            newItems.forEach(x => {
                this.grid.makeWidget(x);
                if (x.gridstackNode) {
                    this.updateNodeVmAttributes(x.gridstackNode);
                }
            });
        }
        attached() {
            var _a;
            const options = (_a = this.options) !== null && _a !== void 0 ? _a : {};
            if (this.float !== undefined) {
                options.float = this.getFloat();
            }
            if (this.static !== undefined) {
                options.staticGrid = this.getStatic();
            }
            this.grid = gs.GridStack.init(options, this.root);
            this.itemsChanged();
        }
        detached() {
            this.grid.destroy();
            this.grid = undefined;
        }
        handleChange(nodes) {
            if (!(nodes instanceof Array)) {
                return;
            }
            nodes.forEach(x => this.updateNodeVmAttributes(x));
        }
        updateNodeVmAttributes(node) {
            const itemVm = node.el.au.controller.viewModel;
            itemVm.beginSuppressUpdate();
            itemVm.x = node.x;
            itemVm.y = node.y;
            itemVm.w = node.w;
            itemVm.h = node.h;
            itemVm.endSuppressUpdate();
        }
    };
    exports.GridStack = GridStack;
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.number,
        tslib_1.__metadata("design:type", Number)
    ], GridStack.prototype, "minRow", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.none,
        tslib_1.__metadata("design:type", Object)
    ], GridStack.prototype, "float", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.none,
        tslib_1.__metadata("design:type", Object)
    ], GridStack.prototype, "static", void 0);
    tslib_1.__decorate([
        aurelia_typed_observable_plugin_1.bindable.none,
        tslib_1.__metadata("design:type", Object)
    ], GridStack.prototype, "options", void 0);
    tslib_1.__decorate([
        (0, aurelia_templating_1.children)('.grid-stack-item'),
        tslib_1.__metadata("design:type", Array)
    ], GridStack.prototype, "items", void 0);
    exports.GridStack = GridStack = tslib_1.__decorate([
        (0, aurelia_dependency_injection_1.inject)(Element),
        (0, aurelia_templating_1.customElement)('grid-stack'),
        (0, aurelia_templating_1.useView)('./grid-stack.html'),
        tslib_1.__metadata("design:paramtypes", [HTMLElement])
    ], GridStack);
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),

/***/ "aurelia-gridstack/elements/grid-stack/grid-stack.html":
/*!********************************************************************!*\
  !*** ../aurelia-gridstack/src/elements/grid-stack/grid-stack.html ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Module
var code = `<template class="grid-stack" style="display: block;" change.trigger="handleChange(\$event.detail)">
  <slot></slot>
</template>
`;
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (code);

/***/ }),

/***/ "aurelia-history-browser":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/aurelia-history-browser/dist/es2015/aurelia-history-browser.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserHistory: () => (/* binding */ BrowserHistory),
/* harmony export */   DefaultLinkHandler: () => (/* binding */ DefaultLinkHandler),
/* harmony export */   LinkHandler: () => (/* binding */ LinkHandler),
/* harmony export */   configure: () => (/* binding */ configure)
/* harmony export */ });
/* harmony import */ var aurelia_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-history */ "../../node_modules/aurelia-history/dist/es2015/aurelia-history.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");



class LinkHandler {
    activate(history) { }
    deactivate() { }
}
class DefaultLinkHandler extends LinkHandler {
    constructor() {
        super();
        this.handler = (e) => {
            let { shouldHandleEvent, href } = DefaultLinkHandler.getEventInfo(e);
            if (shouldHandleEvent) {
                e.preventDefault();
                this.history.navigate(href);
            }
        };
    }
    activate(history) {
        if (history._hasPushState) {
            this.history = history;
            aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.addEventListener('click', this.handler, true);
        }
    }
    deactivate() {
        aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.removeEventListener('click', this.handler, true);
    }
    static getEventInfo(event) {
        let $event = event;
        let info = {
            shouldHandleEvent: false,
            href: null,
            anchor: null
        };
        let target = DefaultLinkHandler.findClosestAnchor($event.target);
        if (!target || !DefaultLinkHandler.targetIsThisWindow(target)) {
            return info;
        }
        if (hasAttribute(target, 'download')
            || hasAttribute(target, 'router-ignore')
            || hasAttribute(target, 'data-router-ignore')) {
            return info;
        }
        if ($event.altKey || $event.ctrlKey || $event.metaKey || $event.shiftKey) {
            return info;
        }
        let href = target.getAttribute('href');
        info.anchor = target;
        info.href = href;
        let leftButtonClicked = $event.which === 1;
        let isRelative = href && !(href.charAt(0) === '#' || (/^[a-z]+:/i).test(href));
        info.shouldHandleEvent = leftButtonClicked && isRelative;
        return info;
    }
    static findClosestAnchor(el) {
        while (el) {
            if (el.tagName === 'A') {
                return el;
            }
            el = el.parentNode;
        }
    }
    static targetIsThisWindow(target) {
        let targetWindow = target.getAttribute('target');
        let win = aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.global;
        return !targetWindow ||
            targetWindow === win.name ||
            targetWindow === '_self';
    }
}
const hasAttribute = (el, attr) => el.hasAttribute(attr);

class BrowserHistory extends aurelia_history__WEBPACK_IMPORTED_MODULE_0__.History {
    constructor(linkHandler) {
        super();
        this._isActive = false;
        this._checkUrlCallback = this._checkUrl.bind(this);
        this.location = aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.location;
        this.history = aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.history;
        this.linkHandler = linkHandler;
    }
    activate(options) {
        if (this._isActive) {
            throw new Error('History has already been activated.');
        }
        let $history = this.history;
        let wantsPushState = !!options.pushState;
        this._isActive = true;
        let normalizedOptions = this.options = Object.assign({}, { root: '/' }, this.options, options);
        let rootUrl = this.root = ('/' + normalizedOptions.root + '/').replace(rootStripper, '/');
        let wantsHashChange = this._wantsHashChange = normalizedOptions.hashChange !== false;
        let hasPushState = this._hasPushState = !!(normalizedOptions.pushState && $history && $history.pushState);
        let eventName;
        if (hasPushState) {
            eventName = 'popstate';
        }
        else if (wantsHashChange) {
            eventName = 'hashchange';
        }
        aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.addEventListener(eventName, this._checkUrlCallback);
        if (wantsHashChange && wantsPushState) {
            let $location = this.location;
            let atRoot = $location.pathname.replace(/[^\/]$/, '$&/') === rootUrl;
            if (!hasPushState && !atRoot) {
                let fragment = this.fragment = this._getFragment(null, true);
                $location.replace(rootUrl + $location.search + '#' + fragment);
                return true;
            }
            else if (hasPushState && atRoot && $location.hash) {
                let fragment = this.fragment = this._getHash().replace(routeStripper, '');
                $history.replaceState({}, aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.title, rootUrl + fragment + $location.search);
            }
        }
        if (!this.fragment) {
            this.fragment = this._getFragment('');
        }
        this.linkHandler.activate(this);
        if (!normalizedOptions.silent) {
            return this._loadUrl('');
        }
    }
    deactivate() {
        const handler = this._checkUrlCallback;
        aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.removeEventListener('popstate', handler);
        aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.PLATFORM.removeEventListener('hashchange', handler);
        this._isActive = false;
        this.linkHandler.deactivate();
    }
    getAbsoluteRoot() {
        let $location = this.location;
        let origin = createOrigin($location.protocol, $location.hostname, $location.port);
        return `${origin}${this.root}`;
    }
    navigate(fragment, { trigger = true, replace = false } = {}) {
        let location = this.location;
        if (fragment && absoluteUrl.test(fragment)) {
            location.href = fragment;
            return true;
        }
        if (!this._isActive) {
            return false;
        }
        fragment = this._getFragment(fragment || '');
        if (this.fragment === fragment && !replace) {
            return false;
        }
        this.fragment = fragment;
        let url = this.root + fragment;
        if (fragment === '' && url !== '/') {
            url = url.slice(0, -1);
        }
        if (this._hasPushState) {
            url = url.replace('//', '/');
            this.history[replace ? 'replaceState' : 'pushState']({}, aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.title, url);
        }
        else if (this._wantsHashChange) {
            updateHash(location, fragment, replace);
        }
        else {
            location.assign(url);
        }
        if (trigger) {
            return this._loadUrl(fragment);
        }
        return true;
    }
    navigateBack() {
        this.history.back();
    }
    setTitle(title) {
        aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.title = title;
    }
    setState(key, value) {
        let $history = this.history;
        let state = Object.assign({}, $history.state);
        let { pathname, search, hash } = this.location;
        state[key] = value;
        $history.replaceState(state, null, `${pathname}${search}${hash}`);
    }
    getState(key) {
        let state = Object.assign({}, this.history.state);
        return state[key];
    }
    getHistoryIndex() {
        let historyIndex = this.getState('HistoryIndex');
        if (historyIndex === undefined) {
            historyIndex = this.history.length - 1;
            this.setState('HistoryIndex', historyIndex);
        }
        return historyIndex;
    }
    go(movement) {
        this.history.go(movement);
    }
    _getHash() {
        return this.location.hash.substr(1);
    }
    _getFragment(fragment, forcePushState) {
        let rootUrl;
        if (!fragment) {
            if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                let location = this.location;
                fragment = location.pathname + location.search;
                rootUrl = this.root.replace(trailingSlash, '');
                if (!fragment.indexOf(rootUrl)) {
                    fragment = fragment.substr(rootUrl.length);
                }
            }
            else {
                fragment = this._getHash();
            }
        }
        return '/' + fragment.replace(routeStripper, '');
    }
    _checkUrl() {
        let current = this._getFragment('');
        if (current !== this.fragment) {
            this._loadUrl('');
        }
    }
    _loadUrl(fragmentOverride) {
        let fragment = this.fragment = this._getFragment(fragmentOverride);
        return this.options.routeHandler ?
            this.options.routeHandler(fragment) :
            false;
    }
}
BrowserHistory.inject = [LinkHandler];
const routeStripper = /^#?\/*|\s+$/g;
const rootStripper = /^\/+|\/+$/g;
const trailingSlash = /\/$/;
const absoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;
function updateHash($location, fragment, replace) {
    if (replace) {
        let href = $location.href.replace(/(javascript:|#).*$/, '');
        $location.replace(href + '#' + fragment);
    }
    else {
        $location.hash = '#' + fragment;
    }
}
function createOrigin(protocol, hostname, port) {
    return `${protocol}//${hostname}${port ? ':' + port : ''}`;
}

function configure(config) {
    const $config = config;
    $config.singleton(aurelia_history__WEBPACK_IMPORTED_MODULE_0__.History, BrowserHistory);
    $config.transient(LinkHandler, DefaultLinkHandler);
}


//# sourceMappingURL=aurelia-history-browser.js.map


/***/ }),

/***/ "aurelia-logging-console":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/aurelia-logging-console/dist/es2015/aurelia-logging-console.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConsoleAppender: () => (/* binding */ ConsoleAppender)
/* harmony export */ });

let ConsoleAppender = class ConsoleAppender {
  debug(logger, ...rest) {
    console.debug(`DEBUG [${logger.id}]`, ...rest);
  }

  info(logger, ...rest) {
    console.info(`INFO [${logger.id}]`, ...rest);
  }

  warn(logger, ...rest) {
    console.warn(`WARN [${logger.id}]`, ...rest);
  }

  error(logger, ...rest) {
    console.error(`ERROR [${logger.id}]`, ...rest);
  }
};

/***/ }),

/***/ "aurelia-pal-browser":
/*!*********************************************************************************!*\
  !*** ../../node_modules/aurelia-pal-browser/dist/es2015/aurelia-pal-browser.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _DOM: () => (/* binding */ _DOM),
/* harmony export */   _FEATURE: () => (/* binding */ _FEATURE),
/* harmony export */   _PLATFORM: () => (/* binding */ _PLATFORM),
/* harmony export */   initialize: () => (/* binding */ initialize)
/* harmony export */ });
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");


const _PLATFORM = {
  location: window.location,
  history: window.history,
  addEventListener(eventName, callback, capture) {
    this.global.addEventListener(eventName, callback, capture);
  },
  removeEventListener(eventName, callback, capture) {
    this.global.removeEventListener(eventName, callback, capture);
  },
  performance: window.performance,
  requestAnimationFrame(callback) {
    return this.global.requestAnimationFrame(callback);
  }
};

if (typeof FEATURE_NO_IE === 'undefined') {
  function test() {}

  if (test.name === undefined) {
    Object.defineProperty(Function.prototype, 'name', {
      get: function () {
        let name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];

        Object.defineProperty(this, 'name', { value: name });
        return name;
      }
    });
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  if (!('classList' in document.createElement('_')) || document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
    let protoProp = 'prototype';
    let strTrim = String.prototype.trim;
    let arrIndexOf = Array.prototype.indexOf;
    let emptyArray = [];

    let DOMEx = function (type, message) {
      this.name = type;
      this.code = DOMException[type];
      this.message = message;
    };

    let checkTokenAndGetIndex = function (classList, token) {
      if (token === '') {
        throw new DOMEx('SYNTAX_ERR', 'An invalid or illegal string was specified');
      }

      if (/\s/.test(token)) {
        throw new DOMEx('INVALID_CHARACTER_ERR', 'String contains an invalid character');
      }

      return arrIndexOf.call(classList, token);
    };

    let ClassList = function (elem) {
      let trimmedClasses = strTrim.call(elem.getAttribute('class') || '');
      let classes = trimmedClasses ? trimmedClasses.split(/\s+/) : emptyArray;

      for (let i = 0, ii = classes.length; i < ii; ++i) {
        this.push(classes[i]);
      }

      this._updateClassName = function () {
        elem.setAttribute('class', this.toString());
      };
    };

    let classListProto = ClassList[protoProp] = [];

    DOMEx[protoProp] = Error[protoProp];

    classListProto.item = function (i) {
      return this[i] || null;
    };

    classListProto.contains = function (token) {
      token += '';
      return checkTokenAndGetIndex(this, token) !== -1;
    };

    classListProto.add = function () {
      let tokens = arguments;
      let i = 0;
      let ii = tokens.length;
      let token;
      let updated = false;

      do {
        token = tokens[i] + '';
        if (checkTokenAndGetIndex(this, token) === -1) {
          this.push(token);
          updated = true;
        }
      } while (++i < ii);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.remove = function () {
      let tokens = arguments;
      let i = 0;
      let ii = tokens.length;
      let token;
      let updated = false;
      let index;

      do {
        token = tokens[i] + '';
        index = checkTokenAndGetIndex(this, token);
        while (index !== -1) {
          this.splice(index, 1);
          updated = true;
          index = checkTokenAndGetIndex(this, token);
        }
      } while (++i < ii);

      if (updated) {
        this._updateClassName();
      }
    };

    classListProto.toggle = function (token, force) {
      token += '';

      let result = this.contains(token);
      let method = result ? force !== true && 'remove' : force !== false && 'add';

      if (method) {
        this[method](token);
      }

      if (force === true || force === false) {
        return force;
      }

      return !result;
    };

    classListProto.toString = function () {
      return this.join(' ');
    };

    Object.defineProperty(Element.prototype, 'classList', {
      get: function () {
        return new ClassList(this);
      },
      enumerable: true,
      configurable: true
    });
  } else {
    let testElement = document.createElement('_');
    testElement.classList.add('c1', 'c2');

    if (!testElement.classList.contains('c2')) {
      let createMethod = function (method) {
        let original = DOMTokenList.prototype[method];

        DOMTokenList.prototype[method] = function (token) {
          for (let i = 0, ii = arguments.length; i < ii; ++i) {
            token = arguments[i];
            original.call(this, token);
          }
        };
      };

      createMethod('add');
      createMethod('remove');
    }

    testElement.classList.toggle('c3', false);

    if (testElement.classList.contains('c3')) {
      let _toggle = DOMTokenList.prototype.toggle;

      DOMTokenList.prototype.toggle = function (token, force) {
        if (1 in arguments && !this.contains(token) === !force) {
          return force;
        }

        return _toggle.call(this, token);
      };
    }

    testElement = null;
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  // @license http://opensource.org/licenses/MIT
  if ('performance' in window === false) {
    window.performance = {};
  }

  if ('now' in window.performance === false) {
    let nowOffset = Date.now();

    if (performance.timing && performance.timing.navigationStart) {
      nowOffset = performance.timing.navigationStart;
    }

    window.performance.now = function now() {
      return Date.now() - nowOffset;
    };
  }

  const startOffset = Date.now ? Date.now() : +new Date();
  const _entries = [];
  const _marksIndex = {};

  function _filterEntries(key, value) {
    var i = 0,
        n = _entries.length,
        result = [];
    for (; i < n; i++) {
      if (_entries[i][key] == value) {
        result.push(_entries[i]);
      }
    }
    return result;
  }

  function _clearEntries(type, name) {
    var i = _entries.length,
        entry;
    while (i--) {
      entry = _entries[i];
      if (entry.entryType == type && (name === void 0 || entry.name == name)) {
        _entries.splice(i, 1);
      }
    }
  };

  if (!window.performance.mark) {
    window.performance.mark = window.performance.webkitMark || function (name) {
      const mark = {
        name,
        entryType: "mark",
        startTime: window.performance.now(),
        duration: 0
      };

      _entries.push(mark);
      _marksIndex[name] = mark;
    };
  }

  if (!window.performance.measure) {
    window.performance.measure = window.performance.webkitMeasure || function (name, startMark, endMark) {
      startMark = _marksIndex[startMark].startTime;
      endMark = _marksIndex[endMark].startTime;

      _entries.push({
        name,
        entryType: "measure",
        startTime: startMark,
        duration: endMark - startMark
      });
    };
  }

  if (!window.performance.getEntriesByType) {
    window.performance.getEntriesByType = window.performance.webkitGetEntriesByType || function (type) {
      return _filterEntries("entryType", type);
    };
  }

  if (!window.performance.getEntriesByName) {
    window.performance.getEntriesByName = window.performance.webkitGetEntriesByName || function (name) {
      return _filterEntries("name", name);
    };
  }

  if (!window.performance.clearMarks) {
    window.performance.clearMarks = window.performance.webkitClearMarks || function (name) {
      _clearEntries("mark", name);
    };
  }

  if (!window.performance.clearMeasures) {
    window.performance.clearMeasures = window.performance.webkitClearMeasures || function (name) {
      _clearEntries("measure", name);
    };
  }

  _PLATFORM.performance = window.performance;
}

if (typeof FEATURE_NO_IE === 'undefined') {
  let con = window.console = window.console || {};
  let nop = function () {};

  if (!con.memory) con.memory = {};
  ('assert,clear,count,debug,dir,dirxml,error,exception,group,' + 'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' + 'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',').forEach(m => {
    if (!con[m]) con[m] = nop;
  });

  if (typeof con.log === 'object') {
    'log,info,warn,error,assert,dir,clear,profile,profileEnd'.split(',').forEach(function (method) {
      console[method] = this.bind(console[method], console);
    }, Function.prototype.call);
  }
}

if (typeof FEATURE_NO_IE === 'undefined') {
  if (!window.CustomEvent || typeof window.CustomEvent !== 'function') {
    let CustomEvent = function (event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };

      let evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    };

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
  }
}

if (Element && !Element.prototype.matches) {
  let proto = Element.prototype;
  proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
}

const _FEATURE = {
  shadowDOM: !!HTMLElement.prototype.attachShadow,
  scopedCSS: 'scoped' in document.createElement('style'),
  htmlTemplateElement: function () {
    let d = document.createElement('div');
    d.innerHTML = '<template></template>';
    return 'content' in d.children[0];
  }(),
  mutationObserver: !!(window.MutationObserver || window.WebKitMutationObserver),
  ensureHTMLTemplateElement: t => t
};

if (typeof FEATURE_NO_IE === 'undefined') {
  function isSVGTemplate(el) {
    return el.tagName === 'template' && el.namespaceURI === 'http://www.w3.org/2000/svg';
  }

  function fixSVGTemplateElement(el) {
    let template = el.ownerDocument.createElement('template');
    let attrs = el.attributes;
    let length = attrs.length;
    let attr;

    el.parentNode.insertBefore(template, el);

    while (length-- > 0) {
      attr = attrs[length];
      template.setAttribute(attr.name, attr.value);
      el.removeAttribute(attr.name);
    }

    el.parentNode.removeChild(el);

    return fixHTMLTemplateElement(template);
  }

  function fixHTMLTemplateElement(template) {
    let content = template.content = document.createDocumentFragment();
    let child;

    while (child = template.firstChild) {
      content.appendChild(child);
    }

    return template;
  }

  function fixHTMLTemplateElementRoot(template) {
    let content = fixHTMLTemplateElement(template).content;
    let childTemplates = content.querySelectorAll('template');

    for (let i = 0, ii = childTemplates.length; i < ii; ++i) {
      let child = childTemplates[i];

      if (isSVGTemplate(child)) {
        fixSVGTemplateElement(child);
      } else {
        fixHTMLTemplateElement(child);
      }
    }

    return template;
  }

  if (!_FEATURE.htmlTemplateElement) {
    _FEATURE.ensureHTMLTemplateElement = fixHTMLTemplateElementRoot;
  }
}

let shadowPoly = window.ShadowDOMPolyfill || null;

const _DOM = {
  Element: Element,
  NodeList: NodeList,
  SVGElement: SVGElement,
  boundary: 'aurelia-dom-boundary',
  addEventListener(eventName, callback, capture) {
    document.addEventListener(eventName, callback, capture);
  },
  removeEventListener(eventName, callback, capture) {
    document.removeEventListener(eventName, callback, capture);
  },
  adoptNode(node) {
    return document.adoptNode(node);
  },
  createAttribute(name) {
    return document.createAttribute(name);
  },
  createElement(tagName) {
    return document.createElement(tagName);
  },
  createTextNode(text) {
    return document.createTextNode(text);
  },
  createComment(text) {
    return document.createComment(text);
  },
  createDocumentFragment() {
    return document.createDocumentFragment();
  },
  createTemplateElement() {
    let template = document.createElement('template');
    return _FEATURE.ensureHTMLTemplateElement(template);
  },
  createMutationObserver(callback) {
    return new (window.MutationObserver || window.WebKitMutationObserver)(callback);
  },
  createCustomEvent(eventType, options) {
    return new window.CustomEvent(eventType, options);
  },
  dispatchEvent(evt) {
    document.dispatchEvent(evt);
  },
  getComputedStyle(element) {
    return window.getComputedStyle(element);
  },
  getElementById(id) {
    return document.getElementById(id);
  },
  querySelector(query) {
    return document.querySelector(query);
  },
  querySelectorAll(query) {
    return document.querySelectorAll(query);
  },
  nextElementSibling(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }
    do {
      element = element.nextSibling;
    } while (element && element.nodeType !== 1);
    return element;
  },
  createTemplateFromMarkup(markup) {
    let parser = document.createElement('div');
    parser.innerHTML = markup;

    let temp = parser.firstElementChild;
    if (!temp || temp.nodeName !== 'TEMPLATE') {
      throw new Error('Template markup must be wrapped in a <template> element e.g. <template> <!-- markup here --> </template>');
    }

    return _FEATURE.ensureHTMLTemplateElement(temp);
  },
  appendNode(newNode, parentNode) {
    (parentNode || document.body).appendChild(newNode);
  },
  replaceNode(newNode, node, parentNode) {
    if (node.parentNode) {
      node.parentNode.replaceChild(newNode, node);
    } else if (shadowPoly !== null) {
      shadowPoly.unwrap(parentNode).replaceChild(shadowPoly.unwrap(newNode), shadowPoly.unwrap(node));
    } else {
      parentNode.replaceChild(newNode, node);
    }
  },
  removeNode(node, parentNode) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    } else if (parentNode) {
      if (shadowPoly !== null) {
        shadowPoly.unwrap(parentNode).removeChild(shadowPoly.unwrap(node));
      } else {
        parentNode.removeChild(node);
      }
    }
  },
  injectStyles(styles, destination, prepend, id) {
    if (id) {
      let oldStyle = document.getElementById(id);
      if (oldStyle) {
        let isStyleTag = oldStyle.tagName.toLowerCase() === 'style';

        if (isStyleTag) {
          oldStyle.innerHTML = styles;
          return;
        }

        throw new Error('The provided id does not indicate a style tag.');
      }
    }

    let node = document.createElement('style');
    node.innerHTML = styles;
    node.type = 'text/css';

    if (id) {
      node.id = id;
    }

    destination = destination || document.head;

    if (prepend && destination.childNodes.length > 0) {
      destination.insertBefore(node, destination.childNodes[0]);
    } else {
      destination.appendChild(node);
    }

    return node;
  }
};

function initialize() {
  if (aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.isInitialized) {
    return;
  }

  (0,aurelia_pal__WEBPACK_IMPORTED_MODULE_0__.initializePAL)((platform, feature, dom) => {
    Object.assign(platform, _PLATFORM);
    Object.assign(feature, _FEATURE);
    Object.assign(dom, _DOM);

    Object.defineProperty(dom, 'title', {
      get: () => document.title,
      set: value => {
        document.title = value;
      }
    });

    Object.defineProperty(dom, 'activeElement', {
      get: () => document.activeElement
    });

    Object.defineProperty(platform, 'XMLHttpRequest', {
      get: () => platform.global.XMLHttpRequest
    });
  });
}

/***/ }),

/***/ "aurelia-templating-binding":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/aurelia-templating-binding/dist/es2015/aurelia-templating-binding.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AttributeMap: () => (/* binding */ AttributeMap),
/* harmony export */   ChildInterpolationBinding: () => (/* binding */ ChildInterpolationBinding),
/* harmony export */   InterpolationBinding: () => (/* binding */ InterpolationBinding),
/* harmony export */   InterpolationBindingExpression: () => (/* binding */ InterpolationBindingExpression),
/* harmony export */   LetBinding: () => (/* binding */ LetBinding),
/* harmony export */   LetExpression: () => (/* binding */ LetExpression),
/* harmony export */   LetInterpolationBinding: () => (/* binding */ LetInterpolationBinding),
/* harmony export */   LetInterpolationBindingExpression: () => (/* binding */ LetInterpolationBindingExpression),
/* harmony export */   SyntaxInterpreter: () => (/* binding */ SyntaxInterpreter),
/* harmony export */   TemplatingBindingLanguage: () => (/* binding */ TemplatingBindingLanguage),
/* harmony export */   configure: () => (/* binding */ configure)
/* harmony export */ });
/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-templating */ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js");
/* harmony import */ var aurelia_binding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-binding */ "../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js");
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");




class AttributeMap {
    constructor(svg) {
        this.elements = Object.create(null);
        this.allElements = Object.create(null);
        this.svg = svg;
        this.registerUniversal('accesskey', 'accessKey');
        this.registerUniversal('contenteditable', 'contentEditable');
        this.registerUniversal('tabindex', 'tabIndex');
        this.registerUniversal('textcontent', 'textContent');
        this.registerUniversal('innerhtml', 'innerHTML');
        this.registerUniversal('scrolltop', 'scrollTop');
        this.registerUniversal('scrollleft', 'scrollLeft');
        this.registerUniversal('readonly', 'readOnly');
        this.register('label', 'for', 'htmlFor');
        this.register('img', 'usemap', 'useMap');
        this.register('input', 'maxlength', 'maxLength');
        this.register('input', 'minlength', 'minLength');
        this.register('input', 'formaction', 'formAction');
        this.register('input', 'formenctype', 'formEncType');
        this.register('input', 'formmethod', 'formMethod');
        this.register('input', 'formnovalidate', 'formNoValidate');
        this.register('input', 'formtarget', 'formTarget');
        this.register('textarea', 'maxlength', 'maxLength');
        this.register('td', 'rowspan', 'rowSpan');
        this.register('td', 'colspan', 'colSpan');
        this.register('th', 'rowspan', 'rowSpan');
        this.register('th', 'colspan', 'colSpan');
    }
    register(elementName, attributeName, propertyName) {
        elementName = elementName.toLowerCase();
        attributeName = attributeName.toLowerCase();
        const element = this.elements[elementName] = (this.elements[elementName] || Object.create(null));
        element[attributeName] = propertyName;
    }
    registerUniversal(attributeName, propertyName) {
        attributeName = attributeName.toLowerCase();
        this.allElements[attributeName] = propertyName;
    }
    map(elementName, attributeName) {
        if (this.svg.isStandardSvgAttribute(elementName, attributeName)) {
            return attributeName;
        }
        elementName = elementName.toLowerCase();
        attributeName = attributeName.toLowerCase();
        const element = this.elements[elementName];
        if (element !== undefined && attributeName in element) {
            return element[attributeName];
        }
        if (attributeName in this.allElements) {
            return this.allElements[attributeName];
        }
        if (/(?:^data-)|(?:^aria-)|:/.test(attributeName)) {
            return attributeName;
        }
        return (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.camelCase)(attributeName);
    }
}
AttributeMap.inject = [aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.SVGAnalyzer];

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

class InterpolationBindingExpression {
    constructor(observerLocator, targetProperty, parts, mode, lookupFunctions, attribute) {
        this.observerLocator = observerLocator;
        this.targetProperty = targetProperty;
        this.parts = parts;
        this.mode = mode;
        this.lookupFunctions = lookupFunctions;
        this.attribute = this.attrToRemove = attribute;
        this.discrete = false;
    }
    createBinding(target) {
        if (this.parts.length === 3) {
            return new ChildInterpolationBinding(target, this.observerLocator, this.parts[1], this.mode, this.lookupFunctions, this.targetProperty, this.parts[0], this.parts[2]);
        }
        return new InterpolationBinding(this.observerLocator, this.parts, target, this.targetProperty, this.mode, this.lookupFunctions);
    }
}
function validateTarget(target, propertyName) {
    if (propertyName === 'style') {
        aurelia_logging__WEBPACK_IMPORTED_MODULE_2__.getLogger('templating-binding')
            .info('Internet Explorer does not support interpolation in "style" attributes.  Use the style attribute\'s alias, "css" instead.');
    }
    else if (target.parentElement && target.parentElement.nodeName === 'TEXTAREA' && propertyName === 'textContent') {
        throw new Error('Interpolation binding cannot be used in the content of a textarea element.  Use <textarea value.bind="expression"></textarea> instead.');
    }
}
class InterpolationBinding {
    constructor(observerLocator, parts, target, targetProperty, mode, lookupFunctions) {
        validateTarget(target, targetProperty);
        this.observerLocator = observerLocator;
        this.parts = parts;
        this.target = target;
        this.targetProperty = targetProperty;
        this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
        this.mode = mode;
        this.lookupFunctions = lookupFunctions;
    }
    interpolate() {
        if (this.isBound) {
            let value = '';
            let parts = this.parts;
            for (let i = 0, ii = parts.length; i < ii; i++) {
                value += (i % 2 === 0 ? parts[i] : this[`childBinding${i}`].value);
            }
            this.targetAccessor.setValue(value, this.target, this.targetProperty);
        }
    }
    updateOneTimeBindings() {
        for (let i = 1, ii = this.parts.length; i < ii; i += 2) {
            let child = this[`childBinding${i}`];
            if (child.mode === aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.oneTime) {
                child.call();
            }
        }
    }
    bind(source) {
        if (this.isBound) {
            if (this.source === source) {
                return;
            }
            this.unbind();
        }
        this.source = source;
        let parts = this.parts;
        for (let i = 1, ii = parts.length; i < ii; i += 2) {
            let binding = new ChildInterpolationBinding(this, this.observerLocator, parts[i], this.mode, this.lookupFunctions);
            binding.bind(source);
            this[`childBinding${i}`] = binding;
        }
        this.isBound = true;
        this.interpolate();
    }
    unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.source = null;
        let parts = this.parts;
        for (let i = 1, ii = parts.length; i < ii; i += 2) {
            let name = `childBinding${i}`;
            this[name].unbind();
        }
    }
}
let ChildInterpolationBinding = class ChildInterpolationBinding {
    constructor(target, observerLocator, sourceExpression, mode, lookupFunctions, targetProperty, left, right) {
        if (target instanceof InterpolationBinding) {
            this.parent = target;
        }
        else {
            validateTarget(target, targetProperty);
            this.target = target;
            this.targetProperty = targetProperty;
            this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
        }
        this.observerLocator = observerLocator;
        this.sourceExpression = sourceExpression;
        this.mode = mode;
        this.lookupFunctions = lookupFunctions;
        this.left = left;
        this.right = right;
    }
    updateTarget(value) {
        value = value === null || value === undefined ? '' : value.toString();
        if (value !== this.value) {
            this.value = value;
            if (this.parent) {
                this.parent.interpolate();
            }
            else {
                this.targetAccessor.setValue(this.left + value + this.right, this.target, this.targetProperty);
            }
        }
    }
    call() {
        if (!this.isBound) {
            return;
        }
        this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        this.updateTarget(this.rawValue);
        if (this.mode !== aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.oneTime) {
            this._version++;
            this.sourceExpression.connect(this, this.source);
            if (this.rawValue instanceof Array) {
                this.observeArray(this.rawValue);
            }
            this.unobserve(false);
        }
    }
    bind(source) {
        if (this.isBound) {
            if (this.source === source) {
                return;
            }
            this.unbind();
        }
        this.isBound = true;
        this.source = source;
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.bind) {
            sourceExpression.bind(this, source, this.lookupFunctions);
        }
        this.rawValue = sourceExpression.evaluate(source, this.lookupFunctions);
        this.updateTarget(this.rawValue);
        if (this.mode === aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.oneWay) {
            (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.enqueueBindingConnect)(this);
        }
    }
    unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        let sourceExpression = this.sourceExpression;
        if (sourceExpression.unbind) {
            sourceExpression.unbind(this, this.source);
        }
        this.source = null;
        this.value = null;
        this.rawValue = null;
        this.unobserve(true);
    }
    connect(evaluate) {
        if (!this.isBound) {
            return;
        }
        if (evaluate) {
            this.rawValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
            this.updateTarget(this.rawValue);
        }
        this.sourceExpression.connect(this, this.source);
        if (this.rawValue instanceof Array) {
            this.observeArray(this.rawValue);
        }
    }
};
ChildInterpolationBinding = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.connectable)()
], ChildInterpolationBinding);

class LetExpression {
    constructor(observerLocator, targetProperty, sourceExpression, lookupFunctions, toBindingContext) {
        this.observerLocator = observerLocator;
        this.sourceExpression = sourceExpression;
        this.targetProperty = targetProperty;
        this.lookupFunctions = lookupFunctions;
        this.toBindingContext = toBindingContext;
    }
    createBinding() {
        return new LetBinding(this.observerLocator, this.sourceExpression, this.targetProperty, this.lookupFunctions, this.toBindingContext);
    }
}
let LetBinding = class LetBinding {
    constructor(observerLocator, sourceExpression, targetProperty, lookupFunctions, toBindingContext) {
        this.observerLocator = observerLocator;
        this.sourceExpression = sourceExpression;
        this.targetProperty = targetProperty;
        this.lookupFunctions = lookupFunctions;
        this.source = null;
        this.target = null;
        this.toBindingContext = toBindingContext;
    }
    updateTarget() {
        const value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        this.target[this.targetProperty] = value;
    }
    call(context) {
        if (!this.isBound) {
            return;
        }
        if (context === aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.sourceContext) {
            this.updateTarget();
            return;
        }
        throw new Error(`Unexpected call context ${context}`);
    }
    bind(source) {
        if (this.isBound) {
            if (this.source === source) {
                return;
            }
            this.unbind();
        }
        this.isBound = true;
        this.source = source;
        this.target = this.toBindingContext ? source.bindingContext : source.overrideContext;
        if (this.sourceExpression.bind) {
            this.sourceExpression.bind(this, source, this.lookupFunctions);
        }
        (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.enqueueBindingConnect)(this);
    }
    unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        if (this.sourceExpression.unbind) {
            this.sourceExpression.unbind(this, this.source);
        }
        this.source = null;
        this.target = null;
        this.unobserve(true);
    }
    unobserve(arg0) {
        throw new Error('Method not implemented.');
    }
    connect() {
        if (!this.isBound) {
            return;
        }
        this.updateTarget();
        this.sourceExpression.connect(this, this.source);
    }
};
LetBinding = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.connectable)()
], LetBinding);

class LetInterpolationBindingExpression {
    constructor(observerLocator, targetProperty, parts, lookupFunctions, toBindingContext) {
        this.observerLocator = observerLocator;
        this.targetProperty = targetProperty;
        this.parts = parts;
        this.lookupFunctions = lookupFunctions;
        this.toBindingContext = toBindingContext;
    }
    createBinding() {
        return new LetInterpolationBinding(this.observerLocator, this.targetProperty, this.parts, this.lookupFunctions, this.toBindingContext);
    }
}
class LetInterpolationBinding {
    constructor(observerLocator, targetProperty, parts, lookupFunctions, toBindingContext) {
        this.observerLocator = observerLocator;
        this.parts = parts;
        this.targetProperty = targetProperty;
        this.lookupFunctions = lookupFunctions;
        this.toBindingContext = toBindingContext;
        this.target = null;
    }
    bind(source) {
        if (this.isBound) {
            if (this.source === source) {
                return;
            }
            this.unbind();
        }
        this.isBound = true;
        this.source = source;
        this.target = this.toBindingContext ? source.bindingContext : source.overrideContext;
        this.interpolationBinding = this.createInterpolationBinding();
        this.interpolationBinding.bind(source);
    }
    unbind() {
        if (!this.isBound) {
            return;
        }
        this.isBound = false;
        this.source = null;
        this.target = null;
        this.interpolationBinding.unbind();
        this.interpolationBinding = null;
    }
    createInterpolationBinding() {
        if (this.parts.length === 3) {
            return new ChildInterpolationBinding(this.target, this.observerLocator, this.parts[1], aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.toView, this.lookupFunctions, this.targetProperty, this.parts[0], this.parts[2]);
        }
        return new InterpolationBinding(this.observerLocator, this.parts, this.target, this.targetProperty, aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.toView, this.lookupFunctions);
    }
}

class SyntaxInterpreter {
    constructor(parser, observerLocator, eventManager, attributeMap) {
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.eventManager = eventManager;
        this.attributeMap = attributeMap;
    }
    interpret(resources, element, info, existingInstruction, context) {
        if (info.command in this) {
            return this[info.command](resources, element, info, existingInstruction, context);
        }
        return this.handleUnknownCommand(resources, element, info, existingInstruction, context);
    }
    handleUnknownCommand(resources, element, info, existingInstruction, context) {
        aurelia_logging__WEBPACK_IMPORTED_MODULE_2__.getLogger('templating-binding').warn('Unknown binding command.', info);
        return existingInstruction;
    }
    determineDefaultBindingMode(element, attrName, context) {
        let tagName = element.tagName.toLowerCase();
        if (tagName === 'input' && (attrName === 'value' || attrName === 'files') && element.type !== 'checkbox' && element.type !== 'radio'
            || tagName === 'input' && attrName === 'checked' && (element.type === 'checkbox' || element.type === 'radio')
            || (tagName === 'textarea' || tagName === 'select') && attrName === 'value'
            || (attrName === 'textcontent' || attrName === 'innerhtml') && element.contentEditable === 'true'
            || attrName === 'scrolltop'
            || attrName === 'scrollleft') {
            return aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.twoWay;
        }
        if (context
            && attrName in context.attributes
            && context.attributes[attrName]
            && context.attributes[attrName].defaultBindingMode >= aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.oneTime) {
            return context.attributes[attrName].defaultBindingMode;
        }
        return aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.toView;
    }
    bind(resources, element, info, existingInstruction, context) {
        let instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        instruction.attributes[info.attrName] = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), info.defaultBindingMode === undefined || info.defaultBindingMode === null
            ? this.determineDefaultBindingMode(element, info.attrName, context)
            : info.defaultBindingMode, resources.lookupFunctions);
        return instruction;
    }
    trigger(resources, element, info) {
        return new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.delegationStrategy.none, true, resources.lookupFunctions);
    }
    capture(resources, element, info) {
        return new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.delegationStrategy.capturing, true, resources.lookupFunctions);
    }
    delegate(resources, element, info) {
        return new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.delegationStrategy.bubbling, true, resources.lookupFunctions);
    }
    call(resources, element, info, existingInstruction) {
        let instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        instruction.attributes[info.attrName] = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.CallExpression(this.observerLocator, info.attrName, this.parser.parse(info.attrValue), resources.lookupFunctions);
        return instruction;
    }
    options(resources, element, info, existingInstruction, context) {
        let instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        let attrValue = info.attrValue;
        let language = this.language;
        let name = null;
        let target = '';
        let current;
        let i;
        let ii;
        let inString = false;
        let inEscape = false;
        let foundName = false;
        for (i = 0, ii = attrValue.length; i < ii; ++i) {
            current = attrValue[i];
            if (current === ';' && !inString) {
                if (!foundName) {
                    name = this._getPrimaryPropertyName(resources, context);
                }
                info = language.inspectAttribute(resources, '?', name, target.trim());
                language.createAttributeInstruction(resources, element, info, instruction, context);
                if (!instruction.attributes[info.attrName]) {
                    instruction.attributes[info.attrName] = info.attrValue;
                }
                target = '';
                name = null;
            }
            else if (current === ':' && name === null) {
                foundName = true;
                name = target.trim();
                target = '';
            }
            else if (current === '\\') {
                target += current;
                inEscape = true;
                continue;
            }
            else {
                target += current;
                if (name !== null && inEscape === false && current === '\'') {
                    inString = !inString;
                }
            }
            inEscape = false;
        }
        if (!foundName) {
            name = this._getPrimaryPropertyName(resources, context);
        }
        if (name !== null) {
            info = language.inspectAttribute(resources, '?', name, target.trim());
            language.createAttributeInstruction(resources, element, info, instruction, context);
            if (!instruction.attributes[info.attrName]) {
                instruction.attributes[info.attrName] = info.attrValue;
            }
        }
        return instruction;
    }
    _getPrimaryPropertyName(resources, context) {
        let type = resources.getAttribute(context.attributeName);
        if (type && type.primaryProperty) {
            return type.primaryProperty.attribute;
        }
        return null;
    }
    'for'(resources, element, info, existingInstruction) {
        let parts;
        let keyValue;
        let instruction;
        let attrValue;
        let isDestructuring;
        attrValue = info.attrValue;
        isDestructuring = attrValue.match(/^ *[[].+[\]]/);
        parts = isDestructuring ? attrValue.split('of ') : attrValue.split(' of ');
        if (parts.length !== 2) {
            throw new Error('Incorrect syntax for "for". The form is: "$local of $items" or "[$key, $value] of $items".');
        }
        instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        if (isDestructuring) {
            keyValue = parts[0].replace(/[[\]]/g, '').replace(/,/g, ' ').replace(/\s+/g, ' ').trim().split(' ');
            instruction.attributes.key = keyValue[0];
            instruction.attributes.value = keyValue[1];
        }
        else {
            instruction.attributes.local = parts[0];
        }
        instruction.attributes.items = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingExpression(this.observerLocator, 'items', this.parser.parse(parts[1]), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.toView, resources.lookupFunctions);
        return instruction;
    }
    'two-way'(resources, element, info, existingInstruction) {
        let instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        instruction.attributes[info.attrName] = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.twoWay, resources.lookupFunctions);
        return instruction;
    }
    'to-view'(resources, element, info, existingInstruction) {
        let instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        instruction.attributes[info.attrName] = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.toView, resources.lookupFunctions);
        return instruction;
    }
    'from-view'(resources, element, info, existingInstruction) {
        let instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        instruction.attributes[info.attrName] = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.fromView, resources.lookupFunctions);
        return instruction;
    }
    'one-time'(resources, element, info, existingInstruction) {
        let instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(info.attrName);
        instruction.attributes[info.attrName] = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.BindingExpression(this.observerLocator, this.attributeMap.map(element.tagName, info.attrName), this.parser.parse(info.attrValue), aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.oneTime, resources.lookupFunctions);
        return instruction;
    }
}
SyntaxInterpreter.inject = [aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Parser, aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ObserverLocator, aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.EventManager, AttributeMap];
Object.defineProperty(SyntaxInterpreter.prototype, 'one-way', Object.getOwnPropertyDescriptor(SyntaxInterpreter.prototype, 'to-view'));

let info = {};
class TemplatingBindingLanguage extends aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BindingLanguage {
    constructor(parser, observerLocator, syntaxInterpreter, attributeMap) {
        super();
        this.parser = parser;
        this.observerLocator = observerLocator;
        this.syntaxInterpreter = syntaxInterpreter;
        this.emptyStringExpression = this.parser.parse('\'\'');
        syntaxInterpreter.language = this;
        this.attributeMap = attributeMap;
        this.toBindingContextAttr = 'to-binding-context';
    }
    inspectAttribute(resources, elementName, attrName, attrValue) {
        let parts = attrName.split('.');
        info.defaultBindingMode = null;
        if (parts.length === 2) {
            info.attrName = parts[0].trim();
            info.attrValue = attrValue;
            info.command = parts[1].trim();
            if (info.command === 'ref') {
                info.expression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.NameExpression(this.parser.parse(attrValue), info.attrName, resources.lookupFunctions);
                info.command = null;
                info.attrName = 'ref';
            }
            else {
                info.expression = null;
            }
        }
        else if (attrName === 'ref') {
            info.attrName = attrName;
            info.attrValue = attrValue;
            info.command = null;
            info.expression = new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.NameExpression(this.parser.parse(attrValue), 'element', resources.lookupFunctions);
        }
        else {
            info.attrName = attrName;
            info.attrValue = attrValue;
            info.command = null;
            const interpolationParts = this.parseInterpolation(resources, attrValue);
            if (interpolationParts === null) {
                info.expression = null;
            }
            else {
                info.expression = new InterpolationBindingExpression(this.observerLocator, this.attributeMap.map(elementName, attrName), interpolationParts, aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.toView, resources.lookupFunctions, attrName);
            }
        }
        return info;
    }
    createAttributeInstruction(resources, element, theInfo, existingInstruction, context) {
        let instruction;
        if (theInfo.expression) {
            if (theInfo.attrName === 'ref') {
                return theInfo.expression;
            }
            instruction = existingInstruction || aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BehaviorInstruction.attribute(theInfo.attrName);
            instruction.attributes[theInfo.attrName] = theInfo.expression;
        }
        else if (theInfo.command) {
            instruction = this.syntaxInterpreter.interpret(resources, element, theInfo, existingInstruction, context);
        }
        return instruction;
    }
    createLetExpressions(resources, letElement) {
        let expressions = [];
        let attributes = letElement.attributes;
        let attr;
        let parts;
        let attrName;
        let attrValue;
        let command;
        let toBindingContextAttr = this.toBindingContextAttr;
        let toBindingContext = letElement.hasAttribute(toBindingContextAttr);
        for (let i = 0, ii = attributes.length; ii > i; ++i) {
            attr = attributes[i];
            attrName = attr.name;
            attrValue = attr.nodeValue;
            parts = attrName.split('.');
            if (attrName === toBindingContextAttr) {
                continue;
            }
            if (parts.length === 2) {
                command = parts[1];
                if (command !== 'bind') {
                    aurelia_logging__WEBPACK_IMPORTED_MODULE_2__.getLogger('templating-binding-language')
                        .warn(`Detected invalid let command. Expected "${parts[0]}.bind", given "${attrName}"`);
                    continue;
                }
                expressions.push(new LetExpression(this.observerLocator, (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.camelCase)(parts[0]), this.parser.parse(attrValue), resources.lookupFunctions, toBindingContext));
            }
            else {
                attrName = (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.camelCase)(attrName);
                parts = this.parseInterpolation(resources, attrValue);
                if (parts === null) {
                    aurelia_logging__WEBPACK_IMPORTED_MODULE_2__.getLogger('templating-binding-language')
                        .warn(`Detected string literal in let bindings. Did you mean "${attrName}.bind=${attrValue}" or "${attrName}=\${${attrValue}}" ?`);
                }
                if (parts) {
                    expressions.push(new LetInterpolationBindingExpression(this.observerLocator, attrName, parts, resources.lookupFunctions, toBindingContext));
                }
                else {
                    expressions.push(new LetExpression(this.observerLocator, attrName, new aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.LiteralString(attrValue), resources.lookupFunctions, toBindingContext));
                }
            }
        }
        return expressions;
    }
    inspectTextContent(resources, value) {
        const parts = this.parseInterpolation(resources, value);
        if (parts === null) {
            return null;
        }
        return new InterpolationBindingExpression(this.observerLocator, 'textContent', parts, aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.bindingMode.toView, resources.lookupFunctions, 'textContent');
    }
    parseInterpolation(resources, value) {
        let i = value.indexOf('${', 0);
        let ii = value.length;
        let char;
        let pos = 0;
        let open = 0;
        let quote = null;
        let interpolationStart;
        let parts;
        let partIndex = 0;
        while (i >= 0 && i < ii - 2) {
            open = 1;
            interpolationStart = i;
            i += 2;
            do {
                char = value[i];
                i++;
                if (char === "'" || char === '"') {
                    if (quote === null) {
                        quote = char;
                    }
                    else if (quote === char) {
                        quote = null;
                    }
                    continue;
                }
                if (char === '\\') {
                    i++;
                    continue;
                }
                if (quote !== null) {
                    continue;
                }
                if (char === '{') {
                    open++;
                }
                else if (char === '}') {
                    open--;
                }
            } while (open > 0 && i < ii);
            if (open === 0) {
                parts = parts || [];
                if (value[interpolationStart - 1] === '\\' && value[interpolationStart - 2] !== '\\') {
                    parts[partIndex] = value.substring(pos, interpolationStart - 1) + value.substring(interpolationStart, i);
                    partIndex++;
                    parts[partIndex] = this.emptyStringExpression;
                    partIndex++;
                }
                else {
                    parts[partIndex] = value.substring(pos, interpolationStart);
                    partIndex++;
                    parts[partIndex] = this.parser.parse(value.substring(interpolationStart + 2, i - 1));
                    partIndex++;
                }
                pos = i;
                i = value.indexOf('${', i);
            }
            else {
                break;
            }
        }
        if (partIndex === 0) {
            return null;
        }
        parts[partIndex] = value.substr(pos);
        return parts;
    }
}
TemplatingBindingLanguage.inject = [aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.Parser, aurelia_binding__WEBPACK_IMPORTED_MODULE_1__.ObserverLocator, SyntaxInterpreter, AttributeMap];

function configure(config) {
    config.container.registerSingleton(aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BindingLanguage, TemplatingBindingLanguage);
    config.container.registerAlias(aurelia_templating__WEBPACK_IMPORTED_MODULE_0__.BindingLanguage, TemplatingBindingLanguage);
}


//# sourceMappingURL=aurelia-templating-binding.js.map


/***/ }),

/***/ "aurelia-templating-resources":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/aurelia-templating-resources/dist/es2015/aurelia-templating-resources.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractRepeater: () => (/* binding */ AbstractRepeater),
/* harmony export */   ArrayRepeatStrategy: () => (/* binding */ ArrayRepeatStrategy),
/* harmony export */   AttrBindingBehavior: () => (/* binding */ AttrBindingBehavior),
/* harmony export */   BindingSignaler: () => (/* binding */ BindingSignaler),
/* harmony export */   Compose: () => (/* binding */ Compose),
/* harmony export */   ComposeActivationStrategy: () => (/* binding */ ActivationStrategy),
/* harmony export */   DebounceBindingBehavior: () => (/* binding */ DebounceBindingBehavior),
/* harmony export */   Else: () => (/* binding */ Else),
/* harmony export */   Focus: () => (/* binding */ Focus),
/* harmony export */   FromViewBindingBehavior: () => (/* binding */ FromViewBindingBehavior),
/* harmony export */   HTMLSanitizer: () => (/* binding */ HTMLSanitizer),
/* harmony export */   Hide: () => (/* binding */ Hide),
/* harmony export */   If: () => (/* binding */ If),
/* harmony export */   MapRepeatStrategy: () => (/* binding */ MapRepeatStrategy),
/* harmony export */   NullRepeatStrategy: () => (/* binding */ NullRepeatStrategy),
/* harmony export */   NumberRepeatStrategy: () => (/* binding */ NumberRepeatStrategy),
/* harmony export */   OneTimeBindingBehavior: () => (/* binding */ OneTimeBindingBehavior),
/* harmony export */   OneWayBindingBehavior: () => (/* binding */ OneWayBindingBehavior),
/* harmony export */   Repeat: () => (/* binding */ Repeat),
/* harmony export */   RepeatStrategyLocator: () => (/* binding */ RepeatStrategyLocator),
/* harmony export */   Replaceable: () => (/* binding */ Replaceable),
/* harmony export */   SanitizeHTMLValueConverter: () => (/* binding */ SanitizeHTMLValueConverter),
/* harmony export */   SelfBindingBehavior: () => (/* binding */ SelfBindingBehavior),
/* harmony export */   SetRepeatStrategy: () => (/* binding */ SetRepeatStrategy),
/* harmony export */   Show: () => (/* binding */ Show),
/* harmony export */   SignalBindingBehavior: () => (/* binding */ SignalBindingBehavior),
/* harmony export */   ThrottleBindingBehavior: () => (/* binding */ ThrottleBindingBehavior),
/* harmony export */   ToViewBindingBehavior: () => (/* binding */ ToViewBindingBehavior),
/* harmony export */   TwoWayBindingBehavior: () => (/* binding */ TwoWayBindingBehavior),
/* harmony export */   UpdateTriggerBindingBehavior: () => (/* binding */ UpdateTriggerBindingBehavior),
/* harmony export */   With: () => (/* binding */ With),
/* harmony export */   configure: () => (/* binding */ configure),
/* harmony export */   createFullOverrideContext: () => (/* binding */ createFullOverrideContext),
/* harmony export */   getItemsSourceExpression: () => (/* binding */ getItemsSourceExpression),
/* harmony export */   isOneTime: () => (/* binding */ isOneTime),
/* harmony export */   unwrapExpression: () => (/* binding */ unwrapExpression),
/* harmony export */   updateOneTimeBinding: () => (/* binding */ updateOneTimeBinding),
/* harmony export */   updateOverrideContext: () => (/* binding */ updateOverrideContext),
/* harmony export */   viewsRequireLifecycle: () => (/* binding */ viewsRequireLifecycle)
/* harmony export */ });
/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-dependency-injection */ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
/* harmony import */ var aurelia_task_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-task-queue */ "../../node_modules/aurelia-task-queue/dist/es2015/aurelia-task-queue.js");
/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-templating */ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js");
/* harmony import */ var aurelia_binding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-binding */ "../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js");
/* harmony import */ var aurelia_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! aurelia-loader */ "../../node_modules/aurelia-loader/dist/es2015/aurelia-loader.js");
/* harmony import */ var aurelia_path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! aurelia-path */ "../../node_modules/aurelia-path/dist/es2015/aurelia-path.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");










/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

var ActivationStrategy;
(function (ActivationStrategy) {
    ActivationStrategy["InvokeLifecycle"] = "invoke-lifecycle";
    ActivationStrategy["Replace"] = "replace";
})(ActivationStrategy || (ActivationStrategy = {}));
let Compose = class Compose {
    constructor(element, container, compositionEngine, viewSlot, viewResources, taskQueue) {
        this.activationStrategy = ActivationStrategy.InvokeLifecycle;
        this.element = element;
        this.container = container;
        this.compositionEngine = compositionEngine;
        this.viewSlot = viewSlot;
        this.viewResources = viewResources;
        this.taskQueue = taskQueue;
        this.currentController = null;
        this.currentViewModel = null;
        this.changes = Object.create(null);
    }
    static inject() {
        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.Element, aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Container, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionEngine, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewResources, aurelia_task_queue__WEBPACK_IMPORTED_MODULE_2__.TaskQueue];
    }
    created(owningView) {
        this.owningView = owningView;
    }
    bind(bindingContext, overrideContext) {
        this.bindingContext = bindingContext;
        this.overrideContext = overrideContext;
        let changes = this.changes;
        changes.view = this.view;
        changes.viewModel = this.viewModel;
        changes.model = this.model;
        if (!this.pendingTask) {
            processChanges(this);
        }
    }
    unbind() {
        this.changes = Object.create(null);
        this.bindingContext = null;
        this.overrideContext = null;
        let returnToCache = true;
        let skipAnimation = true;
        this.viewSlot.removeAll(returnToCache, skipAnimation);
    }
    modelChanged(newValue, oldValue) {
        this.changes.model = newValue;
        requestUpdate(this);
    }
    viewChanged(newValue, oldValue) {
        this.changes.view = newValue;
        requestUpdate(this);
    }
    viewModelChanged(newValue, oldValue) {
        this.changes.viewModel = newValue;
        requestUpdate(this);
    }
};
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Compose.prototype, "model", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Compose.prototype, "view", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Compose.prototype, "viewModel", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Compose.prototype, "activationStrategy", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Compose.prototype, "swapOrder", void 0);
Compose = __decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.noView,
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customElement)('compose')
], Compose);
function isEmpty(obj) {
    for (const _ in obj) {
        return false;
    }
    return true;
}
function tryActivateViewModel(vm, model) {
    if (vm && typeof vm.activate === 'function') {
        return Promise.resolve(vm.activate(model));
    }
}
function createInstruction(composer, instruction) {
    return Object.assign(instruction, {
        bindingContext: composer.bindingContext,
        overrideContext: composer.overrideContext,
        owningView: composer.owningView,
        container: composer.container,
        viewSlot: composer.viewSlot,
        viewResources: composer.viewResources,
        currentController: composer.currentController,
        host: composer.element,
        swapOrder: composer.swapOrder
    });
}
function processChanges(composer) {
    const changes = composer.changes;
    composer.changes = Object.create(null);
    const activationStrategy = determineActivationStrategy(composer);
    if (needsReInitialization(activationStrategy, changes)) {
        const currentViewModel = activationStrategy === ActivationStrategy.Replace ? null : composer.currentViewModel;
        let instruction = {
            view: composer.view,
            viewModel: currentViewModel || composer.viewModel,
            model: composer.model
        };
        instruction = Object.assign(instruction, changes);
        instruction = createInstruction(composer, instruction);
        composer.pendingTask = composer.compositionEngine.compose(instruction).then(controller => {
            composer.currentController = controller;
            composer.currentViewModel = controller ? controller.viewModel : null;
        });
    }
    else {
        composer.pendingTask = tryActivateViewModel(composer.currentViewModel, changes.model);
        if (!composer.pendingTask) {
            return;
        }
    }
    composer.pendingTask = composer.pendingTask
        .then(() => {
        completeCompositionTask(composer);
    }, reason => {
        completeCompositionTask(composer);
        throw reason;
    });
}
function completeCompositionTask(composer) {
    composer.pendingTask = null;
    if (!isEmpty(composer.changes)) {
        processChanges(composer);
    }
}
function requestUpdate(composer) {
    if (composer.pendingTask || composer.updateRequested) {
        return;
    }
    composer.updateRequested = true;
    composer.taskQueue.queueMicroTask(() => {
        composer.updateRequested = false;
        processChanges(composer);
    });
}
function determineActivationStrategy(composer) {
    let activationStrategy = composer.activationStrategy;
    const vm = composer.currentViewModel;
    if (vm && typeof vm.determineActivationStrategy === 'function') {
        activationStrategy = vm.determineActivationStrategy();
    }
    return activationStrategy;
}
function needsReInitialization(activationStrategy, changes) {
    return 'view' in changes
        || 'viewModel' in changes
        || activationStrategy === ActivationStrategy.Replace;
}

class IfCore {
    constructor(viewFactory, viewSlot) {
        this.viewFactory = viewFactory;
        this.viewSlot = viewSlot;
        this.view = null;
        this.bindingContext = null;
        this.overrideContext = null;
        this.showing = false;
        this.cache = true;
    }
    bind(bindingContext, overrideContext) {
        this.bindingContext = bindingContext;
        this.overrideContext = overrideContext;
    }
    unbind() {
        if (this.view === null) {
            return;
        }
        this.view.unbind();
        if (!this.viewFactory.isCaching) {
            return;
        }
        if (this.showing) {
            this.showing = false;
            this.viewSlot.remove(this.view, true, true);
        }
        else {
            this.view.returnToCache();
        }
        this.view = null;
    }
    _show() {
        if (this.showing) {
            if (!this.view.isBound) {
                this.view.bind(this.bindingContext, this.overrideContext);
            }
            return;
        }
        if (this.view === null) {
            this.view = this.viewFactory.create();
        }
        if (!this.view.isBound) {
            this.view.bind(this.bindingContext, this.overrideContext);
        }
        this.showing = true;
        return this.viewSlot.add(this.view);
    }
    _hide() {
        if (!this.showing) {
            return;
        }
        this.showing = false;
        let removed = this.viewSlot.remove(this.view);
        if (removed instanceof Promise) {
            return removed.then(() => {
                this._unbindView();
            });
        }
        this._unbindView();
    }
    _unbindView() {
        const cache = this.cache === 'false' ? false : !!this.cache;
        this.view.unbind();
        if (!cache) {
            this.view = null;
        }
    }
}

let If = class If extends IfCore {
    constructor() {
        super(...arguments);
        this.cache = true;
    }
    bind(bindingContext, overrideContext) {
        super.bind(bindingContext, overrideContext);
        if (this.condition) {
            this._show();
        }
        else {
            this._hide();
        }
    }
    conditionChanged(newValue) {
        this._update(newValue);
    }
    _update(show) {
        if (this.animating) {
            return;
        }
        let promise;
        if (this.elseVm) {
            promise = show ? this._swap(this.elseVm, this) : this._swap(this, this.elseVm);
        }
        else {
            promise = show ? this._show() : this._hide();
        }
        if (promise) {
            this.animating = true;
            promise.then(() => {
                this.animating = false;
                if (this.condition !== this.showing) {
                    this._update(this.condition);
                }
            });
        }
    }
    _swap(remove, add) {
        switch (this.swapOrder) {
            case 'before':
                return Promise.resolve(add._show()).then(() => remove._hide());
            case 'with':
                return Promise.all([remove._hide(), add._show()]);
            default:
                let promise = remove._hide();
                return promise ? promise.then(() => add._show()) : add._show();
        }
    }
};
__decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable)({ primaryProperty: true })
], If.prototype, "condition", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], If.prototype, "swapOrder", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], If.prototype, "cache", void 0);
If = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('if'),
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.templateController,
    (0,aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.inject)(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BoundViewFactory, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot)
], If);

let Else = class Else extends IfCore {
    constructor(viewFactory, viewSlot) {
        super(viewFactory, viewSlot);
        this._registerInIf();
    }
    bind(bindingContext, overrideContext) {
        super.bind(bindingContext, overrideContext);
        if (this.ifVm.condition) {
            this._hide();
        }
        else {
            this._show();
        }
    }
    _registerInIf() {
        let previous = this.viewSlot.anchor.previousSibling;
        while (previous && !previous.au) {
            previous = previous.previousSibling;
        }
        if (!previous || !previous.au.if) {
            throw new Error("Can't find matching If for Else custom attribute.");
        }
        this.ifVm = previous.au.if.viewModel;
        this.ifVm.elseVm = this;
    }
};
Else = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('else'),
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.templateController,
    (0,aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.inject)(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BoundViewFactory, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot)
], Else);

let With = class With {
    constructor(viewFactory, viewSlot) {
        this.viewFactory = viewFactory;
        this.viewSlot = viewSlot;
        this.parentOverrideContext = null;
        this.view = null;
    }
    bind(bindingContext, overrideContext) {
        this.parentOverrideContext = overrideContext;
        this.valueChanged(this.value);
    }
    valueChanged(newValue) {
        let overrideContext = (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.createOverrideContext)(newValue, this.parentOverrideContext);
        let view = this.view;
        if (!view) {
            view = this.view = this.viewFactory.create();
            view.bind(newValue, overrideContext);
            this.viewSlot.add(view);
        }
        else {
            view.bind(newValue, overrideContext);
        }
    }
    unbind() {
        let view = this.view;
        this.parentOverrideContext = null;
        if (view) {
            view.unbind();
        }
    }
};
With = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('with'),
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.templateController,
    (0,aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.inject)(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BoundViewFactory, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot)
], With);

const oneTime = aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.oneTime;
function updateOverrideContexts(views, startIndex) {
    let length = views.length;
    if (startIndex > 0) {
        startIndex = startIndex - 1;
    }
    for (; startIndex < length; ++startIndex) {
        updateOverrideContext(views[startIndex].overrideContext, startIndex, length);
    }
}
function createFullOverrideContext(repeat, data, index, length, key) {
    let bindingContext = {};
    let overrideContext = (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.createOverrideContext)(bindingContext, repeat.scope.overrideContext);
    if (typeof key !== 'undefined') {
        bindingContext[repeat.key] = key;
        bindingContext[repeat.value] = data;
    }
    else {
        bindingContext[repeat.local] = data;
    }
    updateOverrideContext(overrideContext, index, length);
    return overrideContext;
}
function updateOverrideContext(overrideContext, index, length) {
    let first = (index === 0);
    let last = (index === length - 1);
    let even = index % 2 === 0;
    overrideContext.$index = index;
    overrideContext.$first = first;
    overrideContext.$last = last;
    overrideContext.$middle = !(first || last);
    overrideContext.$odd = !even;
    overrideContext.$even = even;
}
function getItemsSourceExpression(instruction, attrName) {
    return instruction.behaviorInstructions
        .filter(bi => bi.originalAttrName === attrName)[0]
        .attributes
        .items
        .sourceExpression;
}
function unwrapExpression(expression) {
    let unwrapped = false;
    while (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.BindingBehavior) {
        expression = expression.expression;
    }
    while (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.ValueConverter) {
        expression = expression.expression;
        unwrapped = true;
    }
    return unwrapped ? expression : null;
}
function isOneTime(expression) {
    while (expression instanceof aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.BindingBehavior) {
        if (expression.name === 'oneTime') {
            return true;
        }
        expression = expression.expression;
    }
    return false;
}
function updateOneTimeBinding(binding) {
    if (binding.call && binding.mode === oneTime) {
        binding.call(aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.sourceContext);
    }
    else if (binding.updateOneTimeBindings) {
        binding.updateOneTimeBindings();
    }
}
function indexOf(array, item, matcher, startIndex) {
    if (!matcher) {
        return array.indexOf(item);
    }
    const length = array.length;
    for (let index = startIndex || 0; index < length; index++) {
        if (matcher(array[index], item)) {
            return index;
        }
    }
    return -1;
}

class ArrayRepeatStrategy {
    getCollectionObserver(observerLocator, items) {
        return observerLocator.getArrayObserver(items);
    }
    instanceChanged(repeat, items) {
        const $repeat = repeat;
        const itemsLength = items.length;
        if (!items || itemsLength === 0) {
            $repeat.removeAllViews(true, !$repeat.viewsRequireLifecycle);
            return;
        }
        const children = $repeat.views();
        const viewsLength = children.length;
        if (viewsLength === 0) {
            this._standardProcessInstanceChanged($repeat, items);
            return;
        }
        if ($repeat.viewsRequireLifecycle) {
            const childrenSnapshot = children.slice(0);
            const itemNameInBindingContext = $repeat.local;
            const matcher = $repeat.matcher();
            let itemsPreviouslyInViews = [];
            const viewsToRemove = [];
            for (let index = 0; index < viewsLength; index++) {
                const view = childrenSnapshot[index];
                const oldItem = view.bindingContext[itemNameInBindingContext];
                if (indexOf(items, oldItem, matcher) === -1) {
                    viewsToRemove.push(view);
                }
                else {
                    itemsPreviouslyInViews.push(oldItem);
                }
            }
            let updateViews;
            let removePromise;
            if (itemsPreviouslyInViews.length > 0) {
                removePromise = $repeat.removeViews(viewsToRemove, true, !$repeat.viewsRequireLifecycle);
                updateViews = () => {
                    for (let index = 0; index < itemsLength; index++) {
                        const item = items[index];
                        const indexOfView = indexOf(itemsPreviouslyInViews, item, matcher, index);
                        let view;
                        if (indexOfView === -1) {
                            const overrideContext = createFullOverrideContext($repeat, items[index], index, itemsLength);
                            $repeat.insertView(index, overrideContext.bindingContext, overrideContext);
                            itemsPreviouslyInViews.splice(index, 0, undefined);
                        }
                        else if (indexOfView === index) {
                            view = children[indexOfView];
                            itemsPreviouslyInViews[indexOfView] = undefined;
                        }
                        else {
                            view = children[indexOfView];
                            $repeat.moveView(indexOfView, index);
                            itemsPreviouslyInViews.splice(indexOfView, 1);
                            itemsPreviouslyInViews.splice(index, 0, undefined);
                        }
                        if (view) {
                            updateOverrideContext(view.overrideContext, index, itemsLength);
                        }
                    }
                    this._inPlaceProcessItems($repeat, items);
                };
            }
            else {
                removePromise = $repeat.removeAllViews(true, !$repeat.viewsRequireLifecycle);
                updateViews = () => this._standardProcessInstanceChanged($repeat, items);
            }
            if (removePromise instanceof Promise) {
                removePromise.then(updateViews);
            }
            else {
                updateViews();
            }
        }
        else {
            this._inPlaceProcessItems($repeat, items);
        }
    }
    _standardProcessInstanceChanged(repeat, items) {
        for (let i = 0, ii = items.length; i < ii; i++) {
            let overrideContext = createFullOverrideContext(repeat, items[i], i, ii);
            repeat.addView(overrideContext.bindingContext, overrideContext);
        }
    }
    _inPlaceProcessItems(repeat, items) {
        let itemsLength = items.length;
        let viewsLength = repeat.viewCount();
        while (viewsLength > itemsLength) {
            viewsLength--;
            repeat.removeView(viewsLength, true, !repeat.viewsRequireLifecycle);
        }
        let local = repeat.local;
        for (let i = 0; i < viewsLength; i++) {
            let view = repeat.view(i);
            let last = i === itemsLength - 1;
            let middle = i !== 0 && !last;
            let bindingContext = view.bindingContext;
            let overrideContext = view.overrideContext;
            if (bindingContext[local] === items[i]
                && overrideContext.$middle === middle
                && overrideContext.$last === last) {
                continue;
            }
            bindingContext[local] = items[i];
            overrideContext.$middle = middle;
            overrideContext.$last = last;
            repeat.updateBindings(view);
        }
        for (let i = viewsLength; i < itemsLength; i++) {
            let overrideContext = createFullOverrideContext(repeat, items[i], i, itemsLength);
            repeat.addView(overrideContext.bindingContext, overrideContext);
        }
    }
    instanceMutated(repeat, array, splices) {
        if (repeat.__queuedSplices) {
            for (let i = 0, ii = splices.length; i < ii; ++i) {
                let { index, removed, addedCount } = splices[i];
                (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.mergeSplice)(repeat.__queuedSplices, index, removed, addedCount);
            }
            repeat.__array = array.slice(0);
            return;
        }
        let maybePromise = this._runSplices(repeat, array.slice(0), splices);
        if (maybePromise instanceof Promise) {
            let queuedSplices = repeat.__queuedSplices = [];
            let runQueuedSplices = () => {
                if (!queuedSplices.length) {
                    repeat.__queuedSplices = undefined;
                    repeat.__array = undefined;
                    return;
                }
                let nextPromise = this._runSplices(repeat, repeat.__array, queuedSplices) || Promise.resolve();
                queuedSplices = repeat.__queuedSplices = [];
                nextPromise.then(runQueuedSplices);
            };
            maybePromise.then(runQueuedSplices);
        }
    }
    _runSplices(repeat, array, splices) {
        let removeDelta = 0;
        let rmPromises = [];
        for (let i = 0, ii = splices.length; i < ii; ++i) {
            let splice = splices[i];
            let removed = splice.removed;
            for (let j = 0, jj = removed.length; j < jj; ++j) {
                let viewOrPromise = repeat.removeView(splice.index + removeDelta + rmPromises.length, true);
                if (viewOrPromise instanceof Promise) {
                    rmPromises.push(viewOrPromise);
                }
            }
            removeDelta -= splice.addedCount;
        }
        if (rmPromises.length > 0) {
            return Promise.all(rmPromises).then(() => {
                let spliceIndexLow = this._handleAddedSplices(repeat, array, splices);
                updateOverrideContexts(repeat.views(), spliceIndexLow);
            });
        }
        let spliceIndexLow = this._handleAddedSplices(repeat, array, splices);
        updateOverrideContexts(repeat.views(), spliceIndexLow);
        return undefined;
    }
    _handleAddedSplices(repeat, array, splices) {
        let spliceIndex;
        let spliceIndexLow;
        let arrayLength = array.length;
        for (let i = 0, ii = splices.length; i < ii; ++i) {
            let splice = splices[i];
            let addIndex = spliceIndex = splice.index;
            let end = splice.index + splice.addedCount;
            if (typeof spliceIndexLow === 'undefined' || spliceIndexLow === null || spliceIndexLow > splice.index) {
                spliceIndexLow = spliceIndex;
            }
            for (; addIndex < end; ++addIndex) {
                let overrideContext = createFullOverrideContext(repeat, array[addIndex], addIndex, arrayLength);
                repeat.insertView(addIndex, overrideContext.bindingContext, overrideContext);
            }
        }
        return spliceIndexLow;
    }
}

class MapRepeatStrategy {
    getCollectionObserver(observerLocator, items) {
        return observerLocator.getMapObserver(items);
    }
    instanceChanged(repeat, items) {
        let removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
        if (removePromise instanceof Promise) {
            removePromise.then(() => this._standardProcessItems(repeat, items));
            return;
        }
        this._standardProcessItems(repeat, items);
    }
    _standardProcessItems(repeat, items) {
        let index = 0;
        let overrideContext;
        items.forEach((value, key) => {
            overrideContext = createFullOverrideContext(repeat, value, index, items.size, key);
            repeat.addView(overrideContext.bindingContext, overrideContext);
            ++index;
        });
    }
    instanceMutated(repeat, map, records) {
        let key;
        let i;
        let ii;
        let overrideContext;
        let removeIndex;
        let addIndex;
        let record;
        let rmPromises = [];
        let viewOrPromise;
        for (i = 0, ii = records.length; i < ii; ++i) {
            record = records[i];
            key = record.key;
            switch (record.type) {
                case 'update':
                    removeIndex = this._getViewIndexByKey(repeat, key);
                    viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
                    if (viewOrPromise instanceof Promise) {
                        rmPromises.push(viewOrPromise);
                    }
                    overrideContext = createFullOverrideContext(repeat, map.get(key), removeIndex, map.size, key);
                    repeat.insertView(removeIndex, overrideContext.bindingContext, overrideContext);
                    break;
                case 'add':
                    addIndex = repeat.viewCount() <= map.size - 1 ? repeat.viewCount() : map.size - 1;
                    overrideContext = createFullOverrideContext(repeat, map.get(key), addIndex, map.size, key);
                    repeat.insertView(map.size - 1, overrideContext.bindingContext, overrideContext);
                    break;
                case 'delete':
                    if (record.oldValue === undefined) {
                        return;
                    }
                    removeIndex = this._getViewIndexByKey(repeat, key);
                    viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
                    if (viewOrPromise instanceof Promise) {
                        rmPromises.push(viewOrPromise);
                    }
                    break;
                case 'clear':
                    repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
                    break;
                default:
                    continue;
            }
        }
        if (rmPromises.length > 0) {
            Promise.all(rmPromises).then(() => {
                updateOverrideContexts(repeat.views(), 0);
            });
        }
        else {
            updateOverrideContexts(repeat.views(), 0);
        }
    }
    _getViewIndexByKey(repeat, key) {
        let i;
        let ii;
        let child;
        for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
            child = repeat.view(i);
            if (child.bindingContext[repeat.key] === key) {
                return i;
            }
        }
        return undefined;
    }
}

class NullRepeatStrategy {
    instanceChanged(repeat, items) {
        repeat.removeAllViews(true);
    }
    getCollectionObserver(observerLocator, items) {
    }
}

class NumberRepeatStrategy {
    getCollectionObserver() {
        return null;
    }
    instanceChanged(repeat, value) {
        let removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
        if (removePromise instanceof Promise) {
            removePromise.then(() => this._standardProcessItems(repeat, value));
            return;
        }
        this._standardProcessItems(repeat, value);
    }
    _standardProcessItems(repeat, value) {
        let childrenLength = repeat.viewCount();
        let i;
        let ii;
        let overrideContext;
        let viewsToRemove;
        value = Math.floor(value);
        viewsToRemove = childrenLength - value;
        if (viewsToRemove > 0) {
            if (viewsToRemove > childrenLength) {
                viewsToRemove = childrenLength;
            }
            for (i = 0, ii = viewsToRemove; i < ii; ++i) {
                repeat.removeView(childrenLength - (i + 1), true, !repeat.viewsRequireLifecycle);
            }
            return;
        }
        for (i = childrenLength, ii = value; i < ii; ++i) {
            overrideContext = createFullOverrideContext(repeat, i, i, ii);
            repeat.addView(overrideContext.bindingContext, overrideContext);
        }
        updateOverrideContexts(repeat.views(), 0);
    }
}

class SetRepeatStrategy {
    getCollectionObserver(observerLocator, items) {
        return observerLocator.getSetObserver(items);
    }
    instanceChanged(repeat, items) {
        let removePromise = repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
        if (removePromise instanceof Promise) {
            removePromise.then(() => this._standardProcessItems(repeat, items));
            return;
        }
        this._standardProcessItems(repeat, items);
    }
    _standardProcessItems(repeat, items) {
        let index = 0;
        let overrideContext;
        items.forEach(value => {
            overrideContext = createFullOverrideContext(repeat, value, index, items.size);
            repeat.addView(overrideContext.bindingContext, overrideContext);
            ++index;
        });
    }
    instanceMutated(repeat, set, records) {
        let value;
        let i;
        let ii;
        let overrideContext;
        let removeIndex;
        let record;
        let rmPromises = [];
        let viewOrPromise;
        for (i = 0, ii = records.length; i < ii; ++i) {
            record = records[i];
            value = record.value;
            switch (record.type) {
                case 'add':
                    let size = Math.max(set.size - 1, 0);
                    overrideContext = createFullOverrideContext(repeat, value, size, set.size);
                    repeat.insertView(size, overrideContext.bindingContext, overrideContext);
                    break;
                case 'delete':
                    removeIndex = this._getViewIndexByValue(repeat, value);
                    viewOrPromise = repeat.removeView(removeIndex, true, !repeat.viewsRequireLifecycle);
                    if (viewOrPromise instanceof Promise) {
                        rmPromises.push(viewOrPromise);
                    }
                    break;
                case 'clear':
                    repeat.removeAllViews(true, !repeat.viewsRequireLifecycle);
                    break;
                default:
                    continue;
            }
        }
        if (rmPromises.length > 0) {
            Promise.all(rmPromises).then(() => {
                updateOverrideContexts(repeat.views(), 0);
            });
        }
        else {
            updateOverrideContexts(repeat.views(), 0);
        }
    }
    _getViewIndexByValue(repeat, value) {
        let i;
        let ii;
        let child;
        for (i = 0, ii = repeat.viewCount(); i < ii; ++i) {
            child = repeat.view(i);
            if (child.bindingContext[repeat.local] === value) {
                return i;
            }
        }
        return undefined;
    }
}

class RepeatStrategyLocator {
    constructor() {
        this.matchers = [];
        this.strategies = [];
        this.addStrategy(items => items === null || items === undefined, new NullRepeatStrategy());
        this.addStrategy(items => items instanceof Array, new ArrayRepeatStrategy());
        this.addStrategy(items => items instanceof Map, new MapRepeatStrategy());
        this.addStrategy(items => items instanceof Set, new SetRepeatStrategy());
        this.addStrategy(items => typeof items === 'number', new NumberRepeatStrategy());
    }
    addStrategy(matcher, strategy) {
        this.matchers.push(matcher);
        this.strategies.push(strategy);
    }
    getStrategy(items) {
        let matchers = this.matchers;
        for (let i = 0, ii = matchers.length; i < ii; ++i) {
            if (matchers[i](items)) {
                return this.strategies[i];
            }
        }
        return null;
    }
}

const lifecycleOptionalBehaviors = ['focus', 'if', 'else', 'repeat', 'show', 'hide', 'with'];
function behaviorRequiresLifecycle(instruction) {
    let t = instruction.type;
    let name = t.elementName !== null ? t.elementName : t.attributeName;
    return lifecycleOptionalBehaviors.indexOf(name) === -1 && (t.handlesAttached || t.handlesBind || t.handlesCreated || t.handlesDetached || t.handlesUnbind)
        || t.viewFactory && viewsRequireLifecycle(t.viewFactory)
        || instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
}
function targetRequiresLifecycle(instruction) {
    let behaviors = instruction.behaviorInstructions;
    if (behaviors) {
        let i = behaviors.length;
        while (i--) {
            if (behaviorRequiresLifecycle(behaviors[i])) {
                return true;
            }
        }
    }
    return instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
}
function viewsRequireLifecycle(viewFactory) {
    if ('_viewsRequireLifecycle' in viewFactory) {
        return viewFactory._viewsRequireLifecycle;
    }
    viewFactory._viewsRequireLifecycle = false;
    if (viewFactory.viewFactory) {
        viewFactory._viewsRequireLifecycle = viewsRequireLifecycle(viewFactory.viewFactory);
        return viewFactory._viewsRequireLifecycle;
    }
    if (viewFactory.template.querySelector('.au-animate')) {
        viewFactory._viewsRequireLifecycle = true;
        return true;
    }
    for (let id in viewFactory.instructions) {
        if (targetRequiresLifecycle(viewFactory.instructions[id])) {
            viewFactory._viewsRequireLifecycle = true;
            return true;
        }
    }
    viewFactory._viewsRequireLifecycle = false;
    return false;
}

class AbstractRepeater {
    constructor(options) {
        Object.assign(this, {
            local: 'items',
            viewsRequireLifecycle: true
        }, options);
    }
    viewCount() {
        throw new Error('subclass must implement `viewCount`');
    }
    views() {
        throw new Error('subclass must implement `views`');
    }
    view(index) {
        throw new Error('subclass must implement `view`');
    }
    matcher() {
        throw new Error('subclass must implement `matcher`');
    }
    addView(bindingContext, overrideContext) {
        throw new Error('subclass must implement `addView`');
    }
    insertView(index, bindingContext, overrideContext) {
        throw new Error('subclass must implement `insertView`');
    }
    moveView(sourceIndex, targetIndex) {
        throw new Error('subclass must implement `moveView`');
    }
    removeAllViews(returnToCache, skipAnimation) {
        throw new Error('subclass must implement `removeAllViews`');
    }
    removeViews(viewsToRemove, returnToCache, skipAnimation) {
        throw new Error('subclass must implement `removeView`');
    }
    removeView(index, returnToCache, skipAnimation) {
        throw new Error('subclass must implement `removeView`');
    }
    updateBindings(view) {
        throw new Error('subclass must implement `updateBindings`');
    }
}

var Repeat_1;
const matcherExtractionMarker = '__marker_extracted__';
let Repeat = Repeat_1 = class Repeat extends AbstractRepeater {
    constructor(viewFactory, instruction, viewSlot, viewResources, observerLocator, strategyLocator) {
        super({
            local: 'item',
            viewsRequireLifecycle: viewsRequireLifecycle(viewFactory)
        });
        this.viewFactory = viewFactory;
        this.instruction = instruction;
        this.viewSlot = viewSlot;
        this.lookupFunctions = viewResources.lookupFunctions;
        this.observerLocator = observerLocator;
        this.key = 'key';
        this.value = 'value';
        this.strategyLocator = strategyLocator;
        this.ignoreMutation = false;
        this.sourceExpression = getItemsSourceExpression(this.instruction, 'repeat.for');
        this.isOneTime = isOneTime(this.sourceExpression);
        this.viewsRequireLifecycle = viewsRequireLifecycle(viewFactory);
    }
    call(context, changes) {
        this[context](this.items, changes);
    }
    bind(bindingContext, overrideContext) {
        this.scope = { bindingContext, overrideContext };
        const instruction = this.instruction;
        if (!(matcherExtractionMarker in instruction)) {
            instruction[matcherExtractionMarker] = this._captureAndRemoveMatcherBinding();
        }
        this.matcherBinding = instruction[matcherExtractionMarker];
        this.itemsChanged();
    }
    unbind() {
        this.scope = null;
        this.items = null;
        this.matcherBinding = null;
        this.viewSlot.removeAll(true, true);
        this._unsubscribeCollection();
    }
    _unsubscribeCollection() {
        if (this.collectionObserver) {
            this.collectionObserver.unsubscribe(this.callContext, this);
            this.collectionObserver = null;
            this.callContext = null;
        }
    }
    itemsChanged() {
        this._unsubscribeCollection();
        if (!this.scope) {
            return;
        }
        let items = this.items;
        this.strategy = this.strategyLocator.getStrategy(items);
        if (!this.strategy) {
            throw new Error(`Value for '${this.sourceExpression}' is non-repeatable`);
        }
        if (!this.isOneTime && !this._observeInnerCollection()) {
            this._observeCollection();
        }
        this.ignoreMutation = true;
        this.strategy.instanceChanged(this, items);
        this.observerLocator.taskQueue.queueMicroTask(() => {
            this.ignoreMutation = false;
        });
    }
    _getInnerCollection() {
        let expression = unwrapExpression(this.sourceExpression);
        if (!expression) {
            return null;
        }
        return expression.evaluate(this.scope, null);
    }
    handleCollectionMutated(collection, changes) {
        if (!this.collectionObserver) {
            return;
        }
        if (this.ignoreMutation) {
            return;
        }
        this.strategy.instanceMutated(this, collection, changes);
    }
    handleInnerCollectionMutated(collection, changes) {
        if (!this.collectionObserver) {
            return;
        }
        if (this.ignoreMutation) {
            return;
        }
        this.ignoreMutation = true;
        let newItems = this.sourceExpression.evaluate(this.scope, this.lookupFunctions);
        this.observerLocator.taskQueue.queueMicroTask(() => this.ignoreMutation = false);
        if (newItems === this.items) {
            this.itemsChanged();
        }
        else {
            this.items = newItems;
        }
    }
    _observeInnerCollection() {
        let items = this._getInnerCollection();
        let strategy = this.strategyLocator.getStrategy(items);
        if (!strategy) {
            return false;
        }
        this.collectionObserver = strategy.getCollectionObserver(this.observerLocator, items);
        if (!this.collectionObserver) {
            return false;
        }
        this.callContext = 'handleInnerCollectionMutated';
        this.collectionObserver.subscribe(this.callContext, this);
        return true;
    }
    _observeCollection() {
        let items = this.items;
        this.collectionObserver = this.strategy.getCollectionObserver(this.observerLocator, items);
        if (this.collectionObserver) {
            this.callContext = 'handleCollectionMutated';
            this.collectionObserver.subscribe(this.callContext, this);
        }
    }
    _captureAndRemoveMatcherBinding() {
        const viewFactory = this.viewFactory.viewFactory;
        if (viewFactory) {
            const template = viewFactory.template;
            const instructions = viewFactory.instructions;
            if (Repeat_1.useInnerMatcher) {
                return extractMatcherBindingExpression(instructions);
            }
            if (getChildrenCount(template) > 1) {
                return undefined;
            }
            const repeatedElement = getFirstElementChild(template);
            if (!repeatedElement.hasAttribute('au-target-id')) {
                return undefined;
            }
            const repeatedElementTargetId = repeatedElement.getAttribute('au-target-id');
            return extractMatcherBindingExpression(instructions, repeatedElementTargetId);
        }
        return undefined;
    }
    viewCount() { return this.viewSlot.children.length; }
    views() { return this.viewSlot.children; }
    view(index) { return this.viewSlot.children[index]; }
    matcher() {
        const matcherBinding = this.matcherBinding;
        return matcherBinding
            ? matcherBinding.sourceExpression.evaluate(this.scope, matcherBinding.lookupFunctions)
            : null;
    }
    addView(bindingContext, overrideContext) {
        let view = this.viewFactory.create();
        view.bind(bindingContext, overrideContext);
        this.viewSlot.add(view);
    }
    insertView(index, bindingContext, overrideContext) {
        let view = this.viewFactory.create();
        view.bind(bindingContext, overrideContext);
        this.viewSlot.insert(index, view);
    }
    moveView(sourceIndex, targetIndex) {
        this.viewSlot.move(sourceIndex, targetIndex);
    }
    removeAllViews(returnToCache, skipAnimation) {
        return this.viewSlot.removeAll(returnToCache, skipAnimation);
    }
    removeViews(viewsToRemove, returnToCache, skipAnimation) {
        return this.viewSlot.removeMany(viewsToRemove, returnToCache, skipAnimation);
    }
    removeView(index, returnToCache, skipAnimation) {
        return this.viewSlot.removeAt(index, returnToCache, skipAnimation);
    }
    updateBindings(view) {
        const $view = view;
        let j = $view.bindings.length;
        while (j--) {
            updateOneTimeBinding($view.bindings[j]);
        }
        j = $view.controllers.length;
        while (j--) {
            let k = $view.controllers[j].boundProperties.length;
            while (k--) {
                let binding = $view.controllers[j].boundProperties[k].binding;
                updateOneTimeBinding(binding);
            }
        }
    }
};
Repeat.useInnerMatcher = true;
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Repeat.prototype, "items", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Repeat.prototype, "local", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Repeat.prototype, "key", void 0);
__decorate([
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable
], Repeat.prototype, "value", void 0);
Repeat = Repeat_1 = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('repeat'),
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.templateController,
    (0,aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.inject)(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BoundViewFactory, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.TargetInstruction, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewResources, aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.ObserverLocator, RepeatStrategyLocator)
], Repeat);
const extractMatcherBindingExpression = (instructions, targetedElementId) => {
    const instructionIds = Object.keys(instructions);
    for (let i = 0; i < instructionIds.length; i++) {
        const instructionId = instructionIds[i];
        if (targetedElementId !== undefined && instructionId !== targetedElementId) {
            continue;
        }
        const expressions = instructions[instructionId].expressions;
        if (expressions) {
            for (let ii = 0; ii < expressions.length; ii++) {
                if (expressions[ii].targetProperty === 'matcher') {
                    const matcherBindingExpression = expressions[ii];
                    expressions.splice(ii, 1);
                    return matcherBindingExpression;
                }
            }
        }
    }
};
const getChildrenCount = (el) => {
    const childNodes = el.childNodes;
    let count = 0;
    for (let i = 0, ii = childNodes.length; ii > i; ++i) {
        if (childNodes[i].nodeType === 1) {
            ++count;
        }
    }
    return count;
};
const getFirstElementChild = (el) => {
    let firstChild = el.firstChild;
    while (firstChild !== null) {
        if (firstChild.nodeType === 1) {
            return firstChild;
        }
        firstChild = firstChild.nextSibling;
    }
    return null;
};

const aureliaHideClassName = 'aurelia-hide';
const aureliaHideClass = `.${aureliaHideClassName} { display:none !important; }`;
function injectAureliaHideStyleAtHead() {
    aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.injectStyles(aureliaHideClass);
}
function injectAureliaHideStyleAtBoundary(domBoundary) {
    if (aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.FEATURE.shadowDOM && domBoundary && !domBoundary.hasAureliaHideStyle) {
        domBoundary.hasAureliaHideStyle = true;
        aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.injectStyles(aureliaHideClass, domBoundary);
    }
}

let Show = class Show {
    constructor(element, animator, domBoundary) {
        this.element = element;
        this.animator = animator;
        this.domBoundary = domBoundary;
    }
    static inject() {
        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.Element, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.Animator, aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Optional.of(aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.boundary, true)];
    }
    created() {
        injectAureliaHideStyleAtBoundary(this.domBoundary);
    }
    valueChanged(newValue) {
        let element = this.element;
        let animator = this.animator;
        if (newValue) {
            animator.removeClass(element, aureliaHideClassName);
        }
        else {
            animator.addClass(element, aureliaHideClassName);
        }
    }
    bind(bindingContext) {
        this.valueChanged(this.value);
    }
};
Show = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('show')
], Show);

let Hide = class Hide {
    constructor(element, animator, domBoundary) {
        this.element = element;
        this.animator = animator;
        this.domBoundary = domBoundary;
    }
    static inject() {
        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.Element, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.Animator, aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.Optional.of(aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.boundary, true)];
    }
    created() {
        injectAureliaHideStyleAtBoundary(this.domBoundary);
    }
    valueChanged(newValue) {
        if (newValue) {
            this.animator.addClass(this.element, aureliaHideClassName);
        }
        else {
            this.animator.removeClass(this.element, aureliaHideClassName);
        }
    }
    bind(bindingContext) {
        this.valueChanged(this.value);
    }
    value(value) {
        throw new Error('Method not implemented.');
    }
};
Hide = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('hide')
], Hide);

class HTMLSanitizer {
    sanitize(input) {
        throw new Error(`To protect the application against a wide variety of sophisticated XSS attacks.
Please see https://aurelia.io/docs/binding/basics#element-content for instructions on how to use a secure solution like DOMPurify or sanitize-html.`);
    }
}

let SanitizeHTMLValueConverter = class SanitizeHTMLValueConverter {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    toView(untrustedMarkup) {
        if (untrustedMarkup === null || untrustedMarkup === undefined) {
            return null;
        }
        return this.sanitizer.sanitize(untrustedMarkup);
    }
};
SanitizeHTMLValueConverter = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.valueConverter)('sanitizeHTML'),
    (0,aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.inject)(HTMLSanitizer)
], SanitizeHTMLValueConverter);

let Replaceable = class Replaceable {
    constructor(viewFactory, viewSlot) {
        this.viewFactory = viewFactory;
        this.viewSlot = viewSlot;
        this.view = null;
    }
    bind(bindingContext, overrideContext) {
        if (this.view === null) {
            this.view = this.viewFactory.create();
            this.viewSlot.add(this.view);
        }
        this.view.bind(bindingContext, overrideContext);
    }
    unbind() {
        this.view.unbind();
    }
};
Replaceable = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('replaceable'),
    aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.templateController,
    (0,aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_0__.inject)(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BoundViewFactory, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot)
], Replaceable);

let Focus = class Focus {
    constructor(element, taskQueue) {
        this.element = element;
        this.taskQueue = taskQueue;
        this.isAttached = false;
        this.needsApply = false;
    }
    static inject() {
        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.Element, aurelia_task_queue__WEBPACK_IMPORTED_MODULE_2__.TaskQueue];
    }
    valueChanged() {
        if (this.isAttached) {
            this._apply();
        }
        else {
            this.needsApply = true;
        }
    }
    _apply() {
        if (this.value) {
            this.taskQueue.queueMicroTask(() => {
                if (this.value) {
                    this.element.focus();
                }
            });
        }
        else {
            this.element.blur();
        }
    }
    attached() {
        this.isAttached = true;
        if (this.needsApply) {
            this.needsApply = false;
            this._apply();
        }
        this.element.addEventListener('focus', this);
        this.element.addEventListener('blur', this);
    }
    detached() {
        this.isAttached = false;
        this.element.removeEventListener('focus', this);
        this.element.removeEventListener('blur', this);
    }
    handleEvent(e) {
        if (e.type === 'focus') {
            this.value = true;
        }
        else if (aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.activeElement !== this.element) {
            this.value = false;
        }
    }
};
Focus = __decorate([
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customAttribute)('focus', aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.twoWay)
], Focus);

let cssUrlMatcher = /url\((?!['"]data)([^)]+)\)/gi;
function fixupCSSUrls(address, css) {
    if (typeof css !== 'string') {
        throw new Error(`Failed loading required CSS file: ${address}`);
    }
    return css.replace(cssUrlMatcher, (match, p1) => {
        let quote = p1.charAt(0);
        if (quote === '\'' || quote === '"') {
            p1 = p1.substr(1, p1.length - 2);
        }
        return 'url(\'' + (0,aurelia_path__WEBPACK_IMPORTED_MODULE_6__.relativeToFile)(p1, address) + '\')';
    });
}
class CSSResource {
    constructor(address) {
        this.address = address;
        this._scoped = null;
        this._global = false;
        this._alreadyGloballyInjected = false;
    }
    initialize(container, Target) {
        this._scoped = new Target(this);
    }
    register(registry, name) {
        if (name === 'scoped') {
            registry.registerViewEngineHooks(this._scoped);
        }
        else {
            this._global = true;
        }
    }
    load(container) {
        return container.get(aurelia_loader__WEBPACK_IMPORTED_MODULE_5__.Loader)
            .loadText(this.address)
            .catch(() => null)
            .then(text => {
            text = fixupCSSUrls(this.address, text);
            this._scoped.css = text;
            if (this._global) {
                this._alreadyGloballyInjected = true;
                aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.injectStyles(text);
            }
            return this;
        });
    }
}
class CSSViewEngineHooks {
    constructor(owner) {
        this.owner = owner;
        this.css = null;
    }
    beforeCompile(content, resources, instruction) {
        if (instruction.targetShadowDOM) {
            aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.injectStyles(this.css, content, true);
        }
        else if (aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.FEATURE.scopedCSS) {
            let styleNode = aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.injectStyles(this.css, content, true);
            styleNode.setAttribute('scoped', 'scoped');
        }
        else if (this._global && !this.owner._alreadyGloballyInjected) {
            aurelia_pal__WEBPACK_IMPORTED_MODULE_1__.DOM.injectStyles(this.css);
            this.owner._alreadyGloballyInjected = true;
        }
    }
}
function _createCSSResource(address) {
    let ViewCSS = class ViewCSS extends CSSViewEngineHooks {
    };
    ViewCSS = __decorate([
        (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.resource)(new CSSResource(address))
    ], ViewCSS);
    return ViewCSS;
}

let AttrBindingBehavior = class AttrBindingBehavior {
    bind(binding, source) {
        binding.targetObserver = new aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.DataAttributeObserver(binding.target, binding.targetProperty);
    }
    unbind(binding, source) {
    }
};
AttrBindingBehavior = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('attr')
], AttrBindingBehavior);

let modeBindingBehavior = {
    bind(binding, source, lookupFunctions) {
        binding.originalMode = binding.mode;
        binding.mode = this.mode;
    },
    unbind(binding, source) {
        binding.mode = binding.originalMode;
        binding.originalMode = null;
    }
};
let OneTimeBindingBehavior = class OneTimeBindingBehavior {
    constructor() {
        this.mode = aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.oneTime;
    }
};
OneTimeBindingBehavior = __decorate([
    (0,aurelia_metadata__WEBPACK_IMPORTED_MODULE_7__.mixin)(modeBindingBehavior),
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('oneTime')
], OneTimeBindingBehavior);
let OneWayBindingBehavior = class OneWayBindingBehavior {
    constructor() {
        this.mode = aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.toView;
    }
};
OneWayBindingBehavior = __decorate([
    (0,aurelia_metadata__WEBPACK_IMPORTED_MODULE_7__.mixin)(modeBindingBehavior),
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('oneWay')
], OneWayBindingBehavior);
let ToViewBindingBehavior = class ToViewBindingBehavior {
    constructor() {
        this.mode = aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.toView;
    }
};
ToViewBindingBehavior = __decorate([
    (0,aurelia_metadata__WEBPACK_IMPORTED_MODULE_7__.mixin)(modeBindingBehavior),
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('toView')
], ToViewBindingBehavior);
let FromViewBindingBehavior = class FromViewBindingBehavior {
    constructor() {
        this.mode = aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.fromView;
    }
};
FromViewBindingBehavior = __decorate([
    (0,aurelia_metadata__WEBPACK_IMPORTED_MODULE_7__.mixin)(modeBindingBehavior),
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('fromView')
], FromViewBindingBehavior);
let TwoWayBindingBehavior = class TwoWayBindingBehavior {
    constructor() {
        this.mode = aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.twoWay;
    }
};
TwoWayBindingBehavior = __decorate([
    (0,aurelia_metadata__WEBPACK_IMPORTED_MODULE_7__.mixin)(modeBindingBehavior),
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('twoWay')
], TwoWayBindingBehavior);

function throttle(newValue) {
    let state = this.throttleState;
    let elapsed = +new Date() - state.last;
    if (elapsed >= state.delay) {
        clearTimeout(state.timeoutId);
        state.timeoutId = null;
        state.last = +new Date();
        this.throttledMethod(newValue);
        return;
    }
    state.newValue = newValue;
    if (state.timeoutId === null) {
        state.timeoutId = setTimeout(() => {
            state.timeoutId = null;
            state.last = +new Date();
            this.throttledMethod(state.newValue);
        }, state.delay - elapsed);
    }
}
let ThrottleBindingBehavior = class ThrottleBindingBehavior {
    bind(binding, source, delay = 200) {
        let methodToThrottle = 'updateTarget';
        if (binding.callSource) {
            methodToThrottle = 'callSource';
        }
        else if (binding.updateSource && binding.mode === aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.twoWay) {
            methodToThrottle = 'updateSource';
        }
        binding.throttledMethod = binding[methodToThrottle];
        binding.throttledMethod.originalName = methodToThrottle;
        binding[methodToThrottle] = throttle;
        binding.throttleState = {
            delay: delay,
            last: 0,
            timeoutId: null
        };
    }
    unbind(binding, source) {
        let methodToRestore = binding.throttledMethod.originalName;
        binding[methodToRestore] = binding.throttledMethod;
        binding.throttledMethod = null;
        clearTimeout(binding.throttleState.timeoutId);
        binding.throttleState = null;
    }
};
ThrottleBindingBehavior = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('throttle')
], ThrottleBindingBehavior);

const unset = {};
function debounceCallSource(event) {
    const state = this.debounceState;
    clearTimeout(state.timeoutId);
    state.timeoutId = setTimeout(() => this.debouncedMethod(event), state.delay);
}
function debounceCall(context, newValue, oldValue) {
    const state = this.debounceState;
    clearTimeout(state.timeoutId);
    if (context !== state.callContextToDebounce) {
        state.oldValue = unset;
        this.debouncedMethod(context, newValue, oldValue);
        return;
    }
    if (state.oldValue === unset) {
        state.oldValue = oldValue;
    }
    state.timeoutId = setTimeout(() => {
        const _oldValue = state.oldValue;
        state.oldValue = unset;
        this.debouncedMethod(context, newValue, _oldValue);
    }, state.delay);
}
let DebounceBindingBehavior = class DebounceBindingBehavior {
    bind(binding, source, delay = 200) {
        const isCallSource = binding.callSource !== undefined;
        const methodToDebounce = isCallSource ? 'callSource' : 'call';
        const debouncer = isCallSource ? debounceCallSource : debounceCall;
        const mode = binding.mode;
        const callContextToDebounce = mode === aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.twoWay || mode === aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.fromView ? aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.targetContext : aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.sourceContext;
        binding.debouncedMethod = binding[methodToDebounce];
        binding.debouncedMethod.originalName = methodToDebounce;
        binding[methodToDebounce] = debouncer;
        binding.debounceState = {
            callContextToDebounce,
            delay,
            timeoutId: 0,
            oldValue: unset
        };
    }
    unbind(binding, source) {
        const methodToRestore = binding.debouncedMethod.originalName;
        binding[methodToRestore] = binding.debouncedMethod;
        binding.debouncedMethod = null;
        clearTimeout(binding.debounceState.timeoutId);
        binding.debounceState = null;
    }
};
DebounceBindingBehavior = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('debounce')
], DebounceBindingBehavior);

function findOriginalEventTarget(event) {
    return (event.path && event.path[0]) || (event.deepPath && event.deepPath[0]) || event.target;
}
function handleSelfEvent(event) {
    let target = findOriginalEventTarget(event);
    if (this.target !== target) {
        return;
    }
    this.selfEventCallSource(event);
}
let SelfBindingBehavior = class SelfBindingBehavior {
    bind(binding, source) {
        if (!binding.callSource || !binding.targetEvent) {
            throw new Error('Self binding behavior only supports event.');
        }
        binding.selfEventCallSource = binding.callSource;
        binding.callSource = handleSelfEvent;
    }
    unbind(binding, source) {
        binding.callSource = binding.selfEventCallSource;
        binding.selfEventCallSource = null;
    }
};
SelfBindingBehavior = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('self')
], SelfBindingBehavior);

class BindingSignaler {
    constructor() {
        this.signals = {};
    }
    signal(name) {
        let bindings = this.signals[name];
        if (!bindings) {
            return;
        }
        let i = bindings.length;
        while (i--) {
            bindings[i].call(aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.sourceContext);
        }
    }
}

let SignalBindingBehavior = class SignalBindingBehavior {
    constructor(bindingSignaler) {
        this.signals = bindingSignaler.signals;
    }
    static inject() { return [BindingSignaler]; }
    bind(binding, source, ...names) {
        if (!binding.updateTarget) {
            throw new Error('Only property bindings and string interpolation bindings can be signaled.  Trigger, delegate and call bindings cannot be signaled.');
        }
        let signals = this.signals;
        if (names.length === 1) {
            let name = names[0];
            let bindings = signals[name] || (signals[name] = []);
            bindings.push(binding);
            binding.signalName = name;
        }
        else if (names.length > 1) {
            let i = names.length;
            while (i--) {
                let name = names[i];
                let bindings = signals[name] || (signals[name] = []);
                bindings.push(binding);
            }
            binding.signalName = names;
        }
        else {
            throw new Error('Signal name is required.');
        }
    }
    unbind(binding, source) {
        let signals = this.signals;
        let name = binding.signalName;
        binding.signalName = null;
        if (Array.isArray(name)) {
            let names = name;
            let i = names.length;
            while (i--) {
                let n = names[i];
                let bindings = signals[n];
                bindings.splice(bindings.indexOf(binding), 1);
            }
        }
        else {
            let bindings = signals[name];
            bindings.splice(bindings.indexOf(binding), 1);
        }
    }
};
SignalBindingBehavior = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('signal')
], SignalBindingBehavior);

const eventNamesRequired = 'The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">';
const notApplicableMessage = 'The updateTrigger binding behavior can only be applied to two-way/ from-view bindings on input/select elements.';
let UpdateTriggerBindingBehavior = class UpdateTriggerBindingBehavior {
    bind(binding, source, ...events) {
        if (events.length === 0) {
            throw new Error(eventNamesRequired);
        }
        if (binding.mode !== aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.twoWay && binding.mode !== aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingMode.fromView) {
            throw new Error(notApplicableMessage);
        }
        let targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);
        if (!targetObserver.handler) {
            throw new Error(notApplicableMessage);
        }
        binding.targetObserver = targetObserver;
        targetObserver.originalHandler = binding.targetObserver.handler;
        let handler = new aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.EventSubscriber(events);
        targetObserver.handler = handler;
    }
    unbind(binding, source) {
        let targetObserver = binding.targetObserver;
        targetObserver.handler.dispose();
        targetObserver.handler = targetObserver.originalHandler;
        targetObserver.originalHandler = null;
    }
};
UpdateTriggerBindingBehavior = __decorate([
    (0,aurelia_binding__WEBPACK_IMPORTED_MODULE_4__.bindingBehavior)('updateTrigger')
], UpdateTriggerBindingBehavior);

function _createDynamicElement({ name, viewUrl, bindableNames, useShadowDOMmode }) {
    let DynamicElement = class DynamicElement {
        bind(bindingContext) {
            this.$parent = bindingContext;
        }
    };
    DynamicElement = __decorate([
        (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customElement)(name),
        (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useView)(viewUrl)
    ], DynamicElement);
    for (let i = 0, ii = bindableNames.length; i < ii; ++i) {
        (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.bindable)(bindableNames[i])(DynamicElement);
    }
    switch (useShadowDOMmode) {
        case 'open':
            (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useShadowDOM)({ mode: 'open' })(DynamicElement);
            break;
        case 'closed':
            (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useShadowDOM)({ mode: 'closed' })(DynamicElement);
            break;
        case '':
            (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useShadowDOM)(DynamicElement);
            break;
        case null:
            break;
        default:
            (0,aurelia_logging__WEBPACK_IMPORTED_MODULE_8__.getLogger)('aurelia-html-only-element')
                .warn(`Expected 'use-shadow-dom' value to be "close", "open" or "", received ${useShadowDOMmode}`);
            break;
    }
    return DynamicElement;
}

function getElementName(address) {
    return /([^\/^\?]+)\.html/i.exec(address)[1].toLowerCase();
}
function configure$1(config) {
    const viewEngine = config.container.get(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewEngine);
    const loader = config.aurelia.loader;
    viewEngine.addResourcePlugin('.html', {
        'fetch': function (viewUrl) {
            return loader.loadTemplate(viewUrl).then(registryEntry => {
                let bindableNames = registryEntry.template.getAttribute('bindable');
                const useShadowDOMmode = registryEntry.template.getAttribute('use-shadow-dom');
                const name = getElementName(viewUrl);
                if (bindableNames) {
                    bindableNames = bindableNames.split(',').map(x => x.trim());
                    registryEntry.template.removeAttribute('bindable');
                }
                else {
                    bindableNames = [];
                }
                return { [name]: _createDynamicElement({ name, viewUrl, bindableNames, useShadowDOMmode }) };
            });
        }
    });
}

function configure(config) {
    injectAureliaHideStyleAtHead();
    config.globalResources(Compose, If, Else, With, Repeat, Show, Hide, Replaceable, Focus, SanitizeHTMLValueConverter, OneTimeBindingBehavior, OneWayBindingBehavior, ToViewBindingBehavior, FromViewBindingBehavior, TwoWayBindingBehavior, ThrottleBindingBehavior, DebounceBindingBehavior, SelfBindingBehavior, SignalBindingBehavior, UpdateTriggerBindingBehavior, AttrBindingBehavior);
    configure$1(config);
    let viewEngine = config.container.get(aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewEngine);
    let styleResourcePlugin = {
        fetch(address) {
            return { [address]: _createCSSResource(address) };
        }
    };
    ['.css', '.less', '.sass', '.scss', '.styl'].forEach(ext => viewEngine.addResourcePlugin(ext, styleResourcePlugin));
}


//# sourceMappingURL=aurelia-templating-resources.js.map


/***/ }),

/***/ "aurelia-templating-router":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/aurelia-templating-router/dist/es2015/aurelia-templating-router.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RouteHref: () => (/* binding */ RouteHref),
/* harmony export */   RouterView: () => (/* binding */ RouterView),
/* harmony export */   RouterViewLocator: () => (/* binding */ RouterViewLocator),
/* harmony export */   TemplatingRouteLoader: () => (/* binding */ TemplatingRouteLoader),
/* harmony export */   configure: () => (/* binding */ configure)
/* harmony export */ });
/* harmony import */ var aurelia_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aurelia-router */ "../../node_modules/aurelia-router/dist/es2015/aurelia-router.js");
/* harmony import */ var aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! aurelia-metadata */ "../../node_modules/aurelia-metadata/dist/es2015/aurelia-metadata.js");
/* harmony import */ var aurelia_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! aurelia-path */ "../../node_modules/aurelia-path/dist/es2015/aurelia-path.js");
/* harmony import */ var aurelia_templating__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! aurelia-templating */ "../../node_modules/aurelia-templating/dist/es2015/aurelia-templating.js");
/* harmony import */ var aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! aurelia-dependency-injection */ "../../node_modules/aurelia-dependency-injection/dist/es2015/aurelia-dependency-injection.js");
/* harmony import */ var aurelia_binding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! aurelia-binding */ "../../node_modules/aurelia-binding/dist/es2015/aurelia-binding.js");
/* harmony import */ var aurelia_pal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! aurelia-pal */ "../../node_modules/aurelia-pal/dist/es2015/aurelia-pal.js");
/* harmony import */ var aurelia_logging__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! aurelia-logging */ "../../node_modules/aurelia-logging/dist/es2015/aurelia-logging.js");









class EmptyLayoutViewModel {
}
class RouterView {
    constructor(element, container, viewSlot, router, viewLocator, compositionTransaction, compositionEngine) {
        this.element = element;
        this.container = container;
        this.viewSlot = viewSlot;
        this.router = router;
        this.viewLocator = viewLocator;
        this.compositionTransaction = compositionTransaction;
        this.compositionEngine = compositionEngine;
        this.router.registerViewPort(this, this.element.getAttribute('name'));
        if (!('initialComposition' in compositionTransaction)) {
            compositionTransaction.initialComposition = true;
            this.compositionTransactionNotifier = compositionTransaction.enlist();
        }
    }
    static inject() {
        return [aurelia_pal__WEBPACK_IMPORTED_MODULE_6__.DOM.Element, aurelia_dependency_injection__WEBPACK_IMPORTED_MODULE_4__.Container, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewSlot, aurelia_router__WEBPACK_IMPORTED_MODULE_0__.Router, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ViewLocator, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionTransaction, aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionEngine];
    }
    created(owningView) {
        this.owningView = owningView;
    }
    bind(bindingContext, overrideContext) {
        this.container.viewModel = bindingContext;
        this.overrideContext = overrideContext;
    }
    process($viewPortInstruction, waitToSwap) {
        const viewPortInstruction = $viewPortInstruction;
        const component = viewPortInstruction.component;
        const childContainer = component.childContainer;
        const viewModel = component.viewModel;
        const viewModelResource = component.viewModelResource;
        const metadata = viewModelResource.metadata;
        const config = component.router.currentInstruction.config;
        const viewPortConfig = config.viewPorts ? (config.viewPorts[viewPortInstruction.name] || {}) : {};
        childContainer.get(RouterViewLocator)._notify(this);
        const layoutInstruction = {
            viewModel: viewPortConfig.layoutViewModel || config.layoutViewModel || this.layoutViewModel,
            view: viewPortConfig.layoutView || config.layoutView || this.layoutView,
            model: viewPortConfig.layoutModel || config.layoutModel || this.layoutModel,
            router: viewPortInstruction.component.router,
            childContainer: childContainer,
            viewSlot: this.viewSlot
        };
        const viewStrategy = this.viewLocator.getViewStrategy(component.view || viewModel);
        if (viewStrategy && component.view) {
            viewStrategy.makeRelativeTo(aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.Origin.get(component.router.container.viewModel.constructor).moduleId);
        }
        return metadata
            .load(childContainer, viewModelResource.value, null, viewStrategy, true)
            .then((viewFactory) => {
            if (!this.compositionTransactionNotifier) {
                this.compositionTransactionOwnershipToken = this.compositionTransaction.tryCapture();
            }
            if (layoutInstruction.viewModel || layoutInstruction.view) {
                viewPortInstruction.layoutInstruction = layoutInstruction;
            }
            const viewPortComponentBehaviorInstruction = aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.BehaviorInstruction.dynamic(this.element, viewModel, viewFactory);
            viewPortInstruction.controller = metadata.create(childContainer, viewPortComponentBehaviorInstruction);
            if (waitToSwap) {
                return null;
            }
            this.swap(viewPortInstruction);
        });
    }
    swap($viewPortInstruction) {
        const viewPortInstruction = $viewPortInstruction;
        const viewPortController = viewPortInstruction.controller;
        const layoutInstruction = viewPortInstruction.layoutInstruction;
        const previousView = this.view;
        const work = () => {
            const swapStrategy = aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.SwapStrategies[this.swapOrder] || aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.SwapStrategies.after;
            const viewSlot = this.viewSlot;
            swapStrategy(viewSlot, previousView, () => Promise.resolve(viewSlot.add(this.view))).then(() => {
                this._notify();
            });
        };
        const ready = (owningView_or_layoutView) => {
            viewPortController.automate(this.overrideContext, owningView_or_layoutView);
            const transactionOwnerShipToken = this.compositionTransactionOwnershipToken;
            if (transactionOwnerShipToken) {
                return transactionOwnerShipToken
                    .waitForCompositionComplete()
                    .then(() => {
                    this.compositionTransactionOwnershipToken = null;
                    return work();
                });
            }
            return work();
        };
        if (layoutInstruction) {
            if (!layoutInstruction.viewModel) {
                layoutInstruction.viewModel = new EmptyLayoutViewModel();
            }
            return this.compositionEngine
                .createController(layoutInstruction)
                .then((layoutController) => {
                const layoutView = layoutController.view;
                aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.ShadowDOM.distributeView(viewPortController.view, layoutController.slots || layoutView.slots);
                layoutController.automate((0,aurelia_binding__WEBPACK_IMPORTED_MODULE_5__.createOverrideContext)(layoutInstruction.viewModel), this.owningView);
                layoutView.children.push(viewPortController.view);
                return layoutView || layoutController;
            })
                .then((newView) => {
                this.view = newView;
                return ready(newView);
            });
        }
        this.view = viewPortController.view;
        return ready(this.owningView);
    }
    _notify() {
        const notifier = this.compositionTransactionNotifier;
        if (notifier) {
            notifier.done();
            this.compositionTransactionNotifier = null;
        }
    }
}
RouterView.$view = null;
RouterView.$resource = {
    name: 'router-view',
    bindables: ['swapOrder', 'layoutView', 'layoutViewModel', 'layoutModel', 'inherit-binding-context']
};
class RouterViewLocator {
    constructor() {
        this.promise = new Promise((resolve) => this.resolve = resolve);
    }
    findNearest() {
        return this.promise;
    }
    _notify(routerView) {
        this.resolve(routerView);
    }
}

class EmptyClass {
}
(0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.inlineView)('<template></template>')(EmptyClass);
class TemplatingRouteLoader extends aurelia_router__WEBPACK_IMPORTED_MODULE_0__.RouteLoader {
    constructor(compositionEngine) {
        super();
        this.compositionEngine = compositionEngine;
    }
    resolveViewModel(router, config) {
        return new Promise((resolve, reject) => {
            let viewModel;
            if ('moduleId' in config) {
                let moduleId = config.moduleId;
                if (moduleId === null) {
                    viewModel = EmptyClass;
                }
                else {
                    moduleId = (0,aurelia_path__WEBPACK_IMPORTED_MODULE_2__.relativeToFile)(moduleId, aurelia_metadata__WEBPACK_IMPORTED_MODULE_1__.Origin.get(router.container.viewModel.constructor).moduleId);
                    if (/\.html/i.test(moduleId)) {
                        viewModel = createDynamicClass(moduleId);
                    }
                    else {
                        viewModel = moduleId;
                    }
                }
                return resolve(viewModel);
            }
            reject(new Error('Invalid route config. No "moduleId" found.'));
        });
    }
    createChildContainer(router) {
        const childContainer = router.container.createChild();
        childContainer.registerSingleton(RouterViewLocator);
        childContainer.getChildRouter = function () {
            let childRouter;
            childContainer.registerHandler(aurelia_router__WEBPACK_IMPORTED_MODULE_0__.Router, () => childRouter || (childRouter = router.createChild(childContainer)));
            return childContainer.get(aurelia_router__WEBPACK_IMPORTED_MODULE_0__.Router);
        };
        return childContainer;
    }
    loadRoute(router, config, navInstruction) {
        return this
            .resolveViewModel(router, config)
            .then(viewModel => this.compositionEngine.ensureViewModel({
            viewModel: viewModel,
            childContainer: this.createChildContainer(router),
            view: config.view || config.viewStrategy,
            router: router
        }));
    }
}
TemplatingRouteLoader.inject = [aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.CompositionEngine];
function createDynamicClass(moduleId) {
    const name = /([^\/^\?]+)\.html/i.exec(moduleId)[1];
    class DynamicClass {
        bind(bindingContext) {
            this.$parent = bindingContext;
        }
    }
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.customElement)(name)(DynamicClass);
    (0,aurelia_templating__WEBPACK_IMPORTED_MODULE_3__.useView)(moduleId)(DynamicClass);
    return DynamicClass;
}

const logger = aurelia_logging__WEBPACK_IMPORTED_MODULE_7__.getLogger('route-href');
class RouteHref {
    constructor(router, element) {
        this.router = router;
        this.element = element;
        this.attribute = 'href';
    }
    static inject() {
        return [aurelia_router__WEBPACK_IMPORTED_MODULE_0__.Router, aurelia_pal__WEBPACK_IMPORTED_MODULE_6__.DOM.Element];
    }
    bind() {
        this.isActive = true;
        this.processChange();
    }
    unbind() {
        this.isActive = false;
    }
    attributeChanged(value, previous) {
        if (previous) {
            this.element.removeAttribute(previous);
        }
        return this.processChange();
    }
    processChange() {
        return this.router
            .ensureConfigured()
            .then(() => {
            if (!this.isActive) {
                return null;
            }
            const element = this.element;
            const href = this.router.generate(this.route, this.params);
            if (element.au.controller) {
                element.au.controller.viewModel[this.attribute] = href;
            }
            else {
                element.setAttribute(this.attribute, href);
            }
            return null;
        })
            .catch((reason) => {
            logger.error(reason);
        });
    }
}
RouteHref.$resource = {
    type: 'attribute',
    name: 'route-href',
    bindables: [
        { name: 'route', changeHandler: 'processChange', primaryProperty: true },
        { name: 'params', changeHandler: 'processChange' },
        'attribute'
    ]
};

function configure(config) {
    config
        .singleton(aurelia_router__WEBPACK_IMPORTED_MODULE_0__.RouteLoader, TemplatingRouteLoader)
        .singleton(aurelia_router__WEBPACK_IMPORTED_MODULE_0__.Router, aurelia_router__WEBPACK_IMPORTED_MODULE_0__.AppRouter)
        .globalResources(RouterView, RouteHref);
    config.container.registerAlias(aurelia_router__WEBPACK_IMPORTED_MODULE_0__.Router, aurelia_router__WEBPACK_IMPORTED_MODULE_0__.AppRouter);
}


//# sourceMappingURL=aurelia-templating-router.js.map


/***/ }),

/***/ "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" stroke=\"%23666\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 20 20\"><path d=\"m10 3 2 2H8l2-2v14l-2-2h4l-2 2\"/></svg>":
/*!****************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="%23666" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 20 20"><path d="m10 3 2 2H8l2-2v14l-2-2h4l-2 2"/></svg> ***!
  \****************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" stroke=\"%23666\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 20 20\"><path d=\"m10 3 2 2H8l2-2v14l-2-2h4l-2 2\"/></svg>";

/***/ }),

/***/ "gridstack/dist/gridstack.min.css":
/*!*******************************************************!*\
  !*** ./node_modules/gridstack/dist/gridstack.min.css ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../node_modules/css-loader/dist/runtime/getUrl.js */ "../../node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="%23666" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 20 20"><path d="m10 3 2 2H8l2-2v14l-2-2h4l-2 2"/></svg> */ "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" stroke=\"%23666\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 20 20\"><path d=\"m10 3 2 2H8l2-2v14l-2-2h4l-2 2\"/></svg>"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.grid-stack{position:relative}.grid-stack-rtl{direction:ltr}.grid-stack-rtl>.grid-stack-item{direction:rtl}.grid-stack-placeholder>.placeholder-content{background-color:rgba(0,0,0,.1);margin:0;position:absolute;width:auto;z-index:0!important}.grid-stack>.grid-stack-item{position:absolute;padding:0}.grid-stack>.grid-stack-item>.grid-stack-item-content{margin:0;position:absolute;width:auto;overflow-x:hidden;overflow-y:auto}.grid-stack>.grid-stack-item.size-to-content:not(.size-to-content-max)>.grid-stack-item-content{overflow-y:hidden}.grid-stack-item>.ui-resizable-handle{position:absolute;font-size:.1px;display:block;-ms-touch-action:none;touch-action:none}.grid-stack-item.ui-resizable-autohide>.ui-resizable-handle,.grid-stack-item.ui-resizable-disabled>.ui-resizable-handle{display:none}.grid-stack-item>.ui-resizable-ne,.grid-stack-item>.ui-resizable-nw,.grid-stack-item>.ui-resizable-se,.grid-stack-item>.ui-resizable-sw{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_0___});background-repeat:no-repeat;background-position:center}.grid-stack-item>.ui-resizable-ne{transform:translate(0,10px) rotate(45deg)}.grid-stack-item>.ui-resizable-sw{transform:rotate(45deg)}.grid-stack-item>.ui-resizable-nw{transform:translate(0,10px) rotate(-45deg)}.grid-stack-item>.ui-resizable-se{transform:rotate(-45deg)}.grid-stack-item>.ui-resizable-nw{cursor:nw-resize;width:20px;height:20px;top:0}.grid-stack-item>.ui-resizable-n{cursor:n-resize;height:10px;top:0;left:25px;right:25px}.grid-stack-item>.ui-resizable-ne{cursor:ne-resize;width:20px;height:20px;top:0}.grid-stack-item>.ui-resizable-e{cursor:e-resize;width:10px;top:15px;bottom:15px}.grid-stack-item>.ui-resizable-se{cursor:se-resize;width:20px;height:20px}.grid-stack-item>.ui-resizable-s{cursor:s-resize;height:10px;left:25px;bottom:0;right:25px}.grid-stack-item>.ui-resizable-sw{cursor:sw-resize;width:20px;height:20px}.grid-stack-item>.ui-resizable-w{cursor:w-resize;width:10px;top:15px;bottom:15px}.grid-stack-item.ui-draggable-dragging>.ui-resizable-handle{display:none!important}.grid-stack-item.ui-draggable-dragging{will-change:left,top;cursor:move}.grid-stack-item.ui-resizable-resizing{will-change:width,height}.ui-draggable-dragging,.ui-resizable-resizing{z-index:10000}.ui-draggable-dragging>.grid-stack-item-content,.ui-resizable-resizing>.grid-stack-item-content{box-shadow:1px 4px 6px rgba(0,0,0,.2);opacity:.8}.grid-stack-animate,.grid-stack-animate .grid-stack-item{transition:left .3s,top .3s,height .3s,width .3s}.grid-stack-animate .grid-stack-item.grid-stack-placeholder,.grid-stack-animate .grid-stack-item.ui-draggable-dragging,.grid-stack-animate .grid-stack-item.ui-resizable-resizing{transition:left 0s,top 0s,height 0s,width 0s}.grid-stack>.grid-stack-item[gs-y="0"]{top:0}.grid-stack>.grid-stack-item[gs-x="0"]{left:0}.gs-12>.grid-stack-item{width:8.333%}.gs-12>.grid-stack-item[gs-x="1"]{left:8.333%}.gs-12>.grid-stack-item[gs-w="2"]{width:16.667%}.gs-12>.grid-stack-item[gs-x="2"]{left:16.667%}.gs-12>.grid-stack-item[gs-w="3"]{width:25%}.gs-12>.grid-stack-item[gs-x="3"]{left:25%}.gs-12>.grid-stack-item[gs-w="4"]{width:33.333%}.gs-12>.grid-stack-item[gs-x="4"]{left:33.333%}.gs-12>.grid-stack-item[gs-w="5"]{width:41.667%}.gs-12>.grid-stack-item[gs-x="5"]{left:41.667%}.gs-12>.grid-stack-item[gs-w="6"]{width:50%}.gs-12>.grid-stack-item[gs-x="6"]{left:50%}.gs-12>.grid-stack-item[gs-w="7"]{width:58.333%}.gs-12>.grid-stack-item[gs-x="7"]{left:58.333%}.gs-12>.grid-stack-item[gs-w="8"]{width:66.667%}.gs-12>.grid-stack-item[gs-x="8"]{left:66.667%}.gs-12>.grid-stack-item[gs-w="9"]{width:75%}.gs-12>.grid-stack-item[gs-x="9"]{left:75%}.gs-12>.grid-stack-item[gs-w="10"]{width:83.333%}.gs-12>.grid-stack-item[gs-x="10"]{left:83.333%}.gs-12>.grid-stack-item[gs-w="11"]{width:91.667%}.gs-12>.grid-stack-item[gs-x="11"]{left:91.667%}.gs-12>.grid-stack-item[gs-w="12"]{width:100%}.gs-1>.grid-stack-item{width:100%}`, "",{"version":3,"sources":["webpack://./node_modules/gridstack/dist/gridstack.min.css"],"names":[],"mappings":"AAAA,YAAY,iBAAiB,CAAC,gBAAgB,aAAa,CAAC,iCAAiC,aAAa,CAAC,6CAA6C,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,UAAU,CAAC,mBAAmB,CAAC,6BAA6B,iBAAiB,CAAC,SAAS,CAAC,sDAAsD,QAAQ,CAAC,iBAAiB,CAAC,UAAU,CAAC,iBAAiB,CAAC,eAAe,CAAC,gGAAgG,iBAAiB,CAAC,sCAAsC,iBAAiB,CAAC,cAAc,CAAC,aAAa,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,wHAAwH,YAAY,CAAC,wIAAwI,wDAAwP,CAAC,2BAA2B,CAAC,0BAA0B,CAAC,kCAAkC,yCAAyC,CAAC,kCAAkC,uBAAuB,CAAC,kCAAkC,0CAA0C,CAAC,kCAAkC,wBAAwB,CAAC,kCAAkC,gBAAgB,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,iCAAiC,eAAe,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC,kCAAkC,gBAAgB,CAAC,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,iCAAiC,eAAe,CAAC,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,kCAAkC,gBAAgB,CAAC,UAAU,CAAC,WAAW,CAAC,iCAAiC,eAAe,CAAC,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,kCAAkC,gBAAgB,CAAC,UAAU,CAAC,WAAW,CAAC,iCAAiC,eAAe,CAAC,UAAU,CAAC,QAAQ,CAAC,WAAW,CAAC,4DAA4D,sBAAsB,CAAC,uCAAuC,oBAAoB,CAAC,WAAW,CAAC,uCAAuC,wBAAwB,CAAC,8CAA8C,aAAa,CAAC,gGAAgG,qCAAqC,CAAC,UAAU,CAAC,yDAAyD,gDAAgD,CAAC,kLAAkL,4CAA4C,CAAC,uCAAuC,KAAK,CAAC,uCAAuC,MAAM,CAAC,wBAAwB,YAAY,CAAC,kCAAkC,WAAW,CAAC,kCAAkC,aAAa,CAAC,kCAAkC,YAAY,CAAC,kCAAkC,SAAS,CAAC,kCAAkC,QAAQ,CAAC,kCAAkC,aAAa,CAAC,kCAAkC,YAAY,CAAC,kCAAkC,aAAa,CAAC,kCAAkC,YAAY,CAAC,kCAAkC,SAAS,CAAC,kCAAkC,QAAQ,CAAC,kCAAkC,aAAa,CAAC,kCAAkC,YAAY,CAAC,kCAAkC,aAAa,CAAC,kCAAkC,YAAY,CAAC,kCAAkC,SAAS,CAAC,kCAAkC,QAAQ,CAAC,mCAAmC,aAAa,CAAC,mCAAmC,YAAY,CAAC,mCAAmC,aAAa,CAAC,mCAAmC,YAAY,CAAC,mCAAmC,UAAU,CAAC,uBAAuB,UAAU","sourcesContent":[".grid-stack{position:relative}.grid-stack-rtl{direction:ltr}.grid-stack-rtl>.grid-stack-item{direction:rtl}.grid-stack-placeholder>.placeholder-content{background-color:rgba(0,0,0,.1);margin:0;position:absolute;width:auto;z-index:0!important}.grid-stack>.grid-stack-item{position:absolute;padding:0}.grid-stack>.grid-stack-item>.grid-stack-item-content{margin:0;position:absolute;width:auto;overflow-x:hidden;overflow-y:auto}.grid-stack>.grid-stack-item.size-to-content:not(.size-to-content-max)>.grid-stack-item-content{overflow-y:hidden}.grid-stack-item>.ui-resizable-handle{position:absolute;font-size:.1px;display:block;-ms-touch-action:none;touch-action:none}.grid-stack-item.ui-resizable-autohide>.ui-resizable-handle,.grid-stack-item.ui-resizable-disabled>.ui-resizable-handle{display:none}.grid-stack-item>.ui-resizable-ne,.grid-stack-item>.ui-resizable-nw,.grid-stack-item>.ui-resizable-se,.grid-stack-item>.ui-resizable-sw{background-image:url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" stroke=\"%23666\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 20 20\"><path d=\"m10 3 2 2H8l2-2v14l-2-2h4l-2 2\"/></svg>');background-repeat:no-repeat;background-position:center}.grid-stack-item>.ui-resizable-ne{transform:translate(0,10px) rotate(45deg)}.grid-stack-item>.ui-resizable-sw{transform:rotate(45deg)}.grid-stack-item>.ui-resizable-nw{transform:translate(0,10px) rotate(-45deg)}.grid-stack-item>.ui-resizable-se{transform:rotate(-45deg)}.grid-stack-item>.ui-resizable-nw{cursor:nw-resize;width:20px;height:20px;top:0}.grid-stack-item>.ui-resizable-n{cursor:n-resize;height:10px;top:0;left:25px;right:25px}.grid-stack-item>.ui-resizable-ne{cursor:ne-resize;width:20px;height:20px;top:0}.grid-stack-item>.ui-resizable-e{cursor:e-resize;width:10px;top:15px;bottom:15px}.grid-stack-item>.ui-resizable-se{cursor:se-resize;width:20px;height:20px}.grid-stack-item>.ui-resizable-s{cursor:s-resize;height:10px;left:25px;bottom:0;right:25px}.grid-stack-item>.ui-resizable-sw{cursor:sw-resize;width:20px;height:20px}.grid-stack-item>.ui-resizable-w{cursor:w-resize;width:10px;top:15px;bottom:15px}.grid-stack-item.ui-draggable-dragging>.ui-resizable-handle{display:none!important}.grid-stack-item.ui-draggable-dragging{will-change:left,top;cursor:move}.grid-stack-item.ui-resizable-resizing{will-change:width,height}.ui-draggable-dragging,.ui-resizable-resizing{z-index:10000}.ui-draggable-dragging>.grid-stack-item-content,.ui-resizable-resizing>.grid-stack-item-content{box-shadow:1px 4px 6px rgba(0,0,0,.2);opacity:.8}.grid-stack-animate,.grid-stack-animate .grid-stack-item{transition:left .3s,top .3s,height .3s,width .3s}.grid-stack-animate .grid-stack-item.grid-stack-placeholder,.grid-stack-animate .grid-stack-item.ui-draggable-dragging,.grid-stack-animate .grid-stack-item.ui-resizable-resizing{transition:left 0s,top 0s,height 0s,width 0s}.grid-stack>.grid-stack-item[gs-y=\"0\"]{top:0}.grid-stack>.grid-stack-item[gs-x=\"0\"]{left:0}.gs-12>.grid-stack-item{width:8.333%}.gs-12>.grid-stack-item[gs-x=\"1\"]{left:8.333%}.gs-12>.grid-stack-item[gs-w=\"2\"]{width:16.667%}.gs-12>.grid-stack-item[gs-x=\"2\"]{left:16.667%}.gs-12>.grid-stack-item[gs-w=\"3\"]{width:25%}.gs-12>.grid-stack-item[gs-x=\"3\"]{left:25%}.gs-12>.grid-stack-item[gs-w=\"4\"]{width:33.333%}.gs-12>.grid-stack-item[gs-x=\"4\"]{left:33.333%}.gs-12>.grid-stack-item[gs-w=\"5\"]{width:41.667%}.gs-12>.grid-stack-item[gs-x=\"5\"]{left:41.667%}.gs-12>.grid-stack-item[gs-w=\"6\"]{width:50%}.gs-12>.grid-stack-item[gs-x=\"6\"]{left:50%}.gs-12>.grid-stack-item[gs-w=\"7\"]{width:58.333%}.gs-12>.grid-stack-item[gs-x=\"7\"]{left:58.333%}.gs-12>.grid-stack-item[gs-w=\"8\"]{width:66.667%}.gs-12>.grid-stack-item[gs-x=\"8\"]{left:66.667%}.gs-12>.grid-stack-item[gs-w=\"9\"]{width:75%}.gs-12>.grid-stack-item[gs-x=\"9\"]{left:75%}.gs-12>.grid-stack-item[gs-w=\"10\"]{width:83.333%}.gs-12>.grid-stack-item[gs-x=\"10\"]{left:83.333%}.gs-12>.grid-stack-item[gs-w=\"11\"]{width:91.667%}.gs-12>.grid-stack-item[gs-x=\"11\"]{left:91.667%}.gs-12>.grid-stack-item[gs-w=\"12\"]{width:100%}.gs-1>.grid-stack-item{width:100%}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "src/main":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs"), __webpack_require__(/*! aurelia-framework */ "aurelia-framework"), __webpack_require__(/*! aurelia-bootstrapper */ "../../node_modules/aurelia-bootstrapper/dist/es2015/aurelia-bootstrapper.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, tslib_1, aurelia_framework_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", ({ value: true }));
    exports.configure = configure;
    function configure(aurelia) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            aurelia.use
                .standardConfiguration()
                .developmentLogging()
                .plugin('aurelia-gridstack');
            yield aurelia.start();
            yield aurelia.setRoot('app');
        });
    }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/Aurelia expose webpack internal */
/******/ 	(() => {
/******/ 		if (typeof __webpack_modules__ !== 'undefined') {
/******/ 		__webpack_require__.m = __webpack_require__.m || __webpack_modules__;
/******/ 		__webpack_require__.c = __webpack_require__.c || __webpack_module_cache__;
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("../../node_modules/aurelia-webpack-plugin/runtime/empty-entry.js");
/******/ 	__webpack_require__("../../node_modules/aurelia-webpack-plugin/runtime/pal-loader-entry.js");
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("src/main");
/******/ 	
/******/ })()
;
//# sourceMappingURL=app.8737e44e95335a9176d9.bundle.js.8737e44e95335a9176d9.bundle.map